{"version":3,"file":"less.min.js","sources":["../lib/less-browser/utils.js","../lib/less-browser/browser.js","../lib/less/data/colors.js","../lib/less/data/unit-conversions.js","../lib/less/data/index.js","../lib/less/tree/node.js","../lib/less/tree/color.js","../lib/less/tree/paren.js","../lib/less/tree/combinator.js","../lib/less/tree/element.js","../lib/less/constants.js","../node_modules/clone/clone.js","../lib/less/utils.js","../lib/less/less-error.js","../lib/less/tree/selector.js","../lib/less/tree/value.js","../lib/less/tree/keyword.js","../lib/less/tree/anonymous.js","../lib/less/tree/declaration.js","../lib/less/tree/debug-info.js","../lib/less/tree/comment.js","../lib/less/contexts.js","../lib/less/functions/function-registry.js","../lib/less/functions/default.js","../lib/less/tree/ruleset.js","../lib/less/tree/atrule.js","../lib/less/tree/detached-ruleset.js","../lib/less/tree/unit.js","../lib/less/tree/dimension.js","../lib/less/tree/operation.js","../lib/less/tree/expression.js","../lib/less/functions/function-caller.js","../lib/less/tree/call.js","../lib/less/tree/variable.js","../lib/less/tree/property.js","../lib/less/tree/attribute.js","../lib/less/tree/quoted.js","../lib/less/tree/url.js","../lib/less/tree/media.js","../lib/less/tree/import.js","../lib/less/tree/js-eval-node.js","../lib/less/tree/javascript.js","../lib/less/tree/assignment.js","../lib/less/tree/condition.js","../lib/less/tree/unicode-descriptor.js","../lib/less/tree/negative.js","../lib/less/tree/extend.js","../lib/less/tree/variable-call.js","../lib/less/tree/namespace-value.js","../lib/less/tree/mixin-definition.js","../lib/less/tree/mixin-call.js","../lib/less/tree/index.js","../lib/less/logger.js","../lib/less/environment/environment.js","../lib/less/environment/abstract-file-manager.js","../lib/less/environment/abstract-plugin-loader.js","../lib/less/visitors/visitor.js","../lib/less/visitors/import-sequencer.js","../lib/less/visitors/import-visitor.js","../lib/less/visitors/set-tree-visibility-visitor.js","../lib/less/visitors/extend-visitor.js","../lib/less/visitors/join-selector-visitor.js","../lib/less/visitors/to-css-visitor.js","../lib/less/visitors/index.js","../lib/less/parser/parser-input.js","../lib/less/parser/chunker.js","../lib/less/parser/parser.js","../lib/less/functions/color.js","../lib/less/functions/boolean.js","../lib/less/functions/color-blending.js","../lib/less/functions/list.js","../lib/less/functions/math-helper.js","../lib/less/functions/math.js","../lib/less/functions/number.js","../lib/less/plugin-manager.js","../lib/less/functions/string.js","../lib/less/functions/types.js","../lib/less/functions/index.js","../lib/less/functions/data-uri.js","../lib/less/functions/svg.js","../lib/less/transform-tree.js","../lib/less-browser/file-manager.js","../lib/less/index.js","../lib/less/source-map-output.js","../lib/less/source-map-builder.js","../lib/less/parse-tree.js","../lib/less/import-manager.js","../lib/less/render.js","../lib/less/parse.js","../lib/less-browser/plugin-loader.js","../lib/less-browser/error-reporting.js","../lib/less-browser/bootstrap.js","../lib/less/default-options.js","../lib/less-browser/add-default-options.js","../lib/less-browser/index.js","../lib/less-browser/log-listener.js","../lib/less-browser/cache.js","../lib/less-browser/image-size.js"],"sourcesContent":["\nexport function extractId(href) {\n    return href.replace(/^[a-z-]+:\\/+?[^\\/]+/, '')  // Remove protocol & domain\n        .replace(/[\\?\\&]livereload=\\w+/, '')        // Remove LiveReload cachebuster\n        .replace(/^\\//, '')                         // Remove root /\n        .replace(/\\.[a-zA-Z]+$/, '')                // Remove simple extension\n        .replace(/[^\\.\\w-]+/g, '-')                 // Replace illegal characters\n        .replace(/\\./g, ':');                       // Replace dots with colons(for valid id)\n}\n\nexport function addDataAttr(options, tag) {\n    for (const opt in tag.dataset) {\n        if (tag.dataset.hasOwnProperty(opt)) {\n            if (opt === 'env' || opt === 'dumpLineNumbers' || opt === 'rootpath' || opt === 'errorReporting') {\n                options[opt] = tag.dataset[opt];\n            } else {\n                try {\n                    options[opt] = JSON.parse(tag.dataset[opt]);\n                }\n                catch (_) {}\n            }\n        }\n    }\n}\n","import * as utils from './utils';\n\nexport default {\n    createCSS: function (document, styles, sheet) {\n        // Strip the query-string\n        const href = sheet.href || '';\n\n        // If there is no title set, use the filename, minus the extension\n        const id = `less:${sheet.title || utils.extractId(href)}`;\n\n        // If this has already been inserted into the DOM, we may need to replace it\n        const oldStyleNode = document.getElementById(id);\n        let keepOldStyleNode = false;\n\n        // Create a new stylesheet node for insertion or (if necessary) replacement\n        const styleNode = document.createElement('style');\n        styleNode.setAttribute('type', 'text/css');\n        if (sheet.media) {\n            styleNode.setAttribute('media', sheet.media);\n        }\n        styleNode.id = id;\n\n        if (!styleNode.styleSheet) {\n            styleNode.appendChild(document.createTextNode(styles));\n\n            // If new contents match contents of oldStyleNode, don't replace oldStyleNode\n            keepOldStyleNode = (oldStyleNode !== null && oldStyleNode.childNodes.length > 0 && styleNode.childNodes.length > 0 &&\n                oldStyleNode.firstChild.nodeValue === styleNode.firstChild.nodeValue);\n        }\n\n        const head = document.getElementsByTagName('head')[0];\n\n        // If there is no oldStyleNode, just append; otherwise, only append if we need\n        // to replace oldStyleNode with an updated stylesheet\n        if (oldStyleNode === null || keepOldStyleNode === false) {\n            const nextEl = sheet && sheet.nextSibling || null;\n            if (nextEl) {\n                nextEl.parentNode.insertBefore(styleNode, nextEl);\n            } else {\n                head.appendChild(styleNode);\n            }\n        }\n        if (oldStyleNode && keepOldStyleNode === false) {\n            oldStyleNode.parentNode.removeChild(oldStyleNode);\n        }\n\n        // For IE.\n        // This needs to happen *after* the style element is added to the DOM, otherwise IE 7 and 8 may crash.\n        // See http://social.msdn.microsoft.com/Forums/en-US/7e081b65-878a-4c22-8e68-c10d39c2ed32/internet-explorer-crashes-appending-style-element-to-head\n        if (styleNode.styleSheet) {\n            try {\n                styleNode.styleSheet.cssText = styles;\n            } catch (e) {\n                throw new Error('Couldn\\'t reassign styleSheet.cssText.');\n            }\n        }\n    },\n    currentScript: function(window) {\n        const document = window.document;\n        return document.currentScript || (() => {\n            const scripts = document.getElementsByTagName('script');\n            return scripts[scripts.length - 1];\n        })();\n    }\n};\n","export default {\n    'aliceblue':'#f0f8ff',\n    'antiquewhite':'#faebd7',\n    'aqua':'#00ffff',\n    'aquamarine':'#7fffd4',\n    'azure':'#f0ffff',\n    'beige':'#f5f5dc',\n    'bisque':'#ffe4c4',\n    'black':'#000000',\n    'blanchedalmond':'#ffebcd',\n    'blue':'#0000ff',\n    'blueviolet':'#8a2be2',\n    'brown':'#a52a2a',\n    'burlywood':'#deb887',\n    'cadetblue':'#5f9ea0',\n    'chartreuse':'#7fff00',\n    'chocolate':'#d2691e',\n    'coral':'#ff7f50',\n    'cornflowerblue':'#6495ed',\n    'cornsilk':'#fff8dc',\n    'crimson':'#dc143c',\n    'cyan':'#00ffff',\n    'darkblue':'#00008b',\n    'darkcyan':'#008b8b',\n    'darkgoldenrod':'#b8860b',\n    'darkgray':'#a9a9a9',\n    'darkgrey':'#a9a9a9',\n    'darkgreen':'#006400',\n    'darkkhaki':'#bdb76b',\n    'darkmagenta':'#8b008b',\n    'darkolivegreen':'#556b2f',\n    'darkorange':'#ff8c00',\n    'darkorchid':'#9932cc',\n    'darkred':'#8b0000',\n    'darksalmon':'#e9967a',\n    'darkseagreen':'#8fbc8f',\n    'darkslateblue':'#483d8b',\n    'darkslategray':'#2f4f4f',\n    'darkslategrey':'#2f4f4f',\n    'darkturquoise':'#00ced1',\n    'darkviolet':'#9400d3',\n    'deeppink':'#ff1493',\n    'deepskyblue':'#00bfff',\n    'dimgray':'#696969',\n    'dimgrey':'#696969',\n    'dodgerblue':'#1e90ff',\n    'firebrick':'#b22222',\n    'floralwhite':'#fffaf0',\n    'forestgreen':'#228b22',\n    'fuchsia':'#ff00ff',\n    'gainsboro':'#dcdcdc',\n    'ghostwhite':'#f8f8ff',\n    'gold':'#ffd700',\n    'goldenrod':'#daa520',\n    'gray':'#808080',\n    'grey':'#808080',\n    'green':'#008000',\n    'greenyellow':'#adff2f',\n    'honeydew':'#f0fff0',\n    'hotpink':'#ff69b4',\n    'indianred':'#cd5c5c',\n    'indigo':'#4b0082',\n    'ivory':'#fffff0',\n    'khaki':'#f0e68c',\n    'lavender':'#e6e6fa',\n    'lavenderblush':'#fff0f5',\n    'lawngreen':'#7cfc00',\n    'lemonchiffon':'#fffacd',\n    'lightblue':'#add8e6',\n    'lightcoral':'#f08080',\n    'lightcyan':'#e0ffff',\n    'lightgoldenrodyellow':'#fafad2',\n    'lightgray':'#d3d3d3',\n    'lightgrey':'#d3d3d3',\n    'lightgreen':'#90ee90',\n    'lightpink':'#ffb6c1',\n    'lightsalmon':'#ffa07a',\n    'lightseagreen':'#20b2aa',\n    'lightskyblue':'#87cefa',\n    'lightslategray':'#778899',\n    'lightslategrey':'#778899',\n    'lightsteelblue':'#b0c4de',\n    'lightyellow':'#ffffe0',\n    'lime':'#00ff00',\n    'limegreen':'#32cd32',\n    'linen':'#faf0e6',\n    'magenta':'#ff00ff',\n    'maroon':'#800000',\n    'mediumaquamarine':'#66cdaa',\n    'mediumblue':'#0000cd',\n    'mediumorchid':'#ba55d3',\n    'mediumpurple':'#9370d8',\n    'mediumseagreen':'#3cb371',\n    'mediumslateblue':'#7b68ee',\n    'mediumspringgreen':'#00fa9a',\n    'mediumturquoise':'#48d1cc',\n    'mediumvioletred':'#c71585',\n    'midnightblue':'#191970',\n    'mintcream':'#f5fffa',\n    'mistyrose':'#ffe4e1',\n    'moccasin':'#ffe4b5',\n    'navajowhite':'#ffdead',\n    'navy':'#000080',\n    'oldlace':'#fdf5e6',\n    'olive':'#808000',\n    'olivedrab':'#6b8e23',\n    'orange':'#ffa500',\n    'orangered':'#ff4500',\n    'orchid':'#da70d6',\n    'palegoldenrod':'#eee8aa',\n    'palegreen':'#98fb98',\n    'paleturquoise':'#afeeee',\n    'palevioletred':'#d87093',\n    'papayawhip':'#ffefd5',\n    'peachpuff':'#ffdab9',\n    'peru':'#cd853f',\n    'pink':'#ffc0cb',\n    'plum':'#dda0dd',\n    'powderblue':'#b0e0e6',\n    'purple':'#800080',\n    'rebeccapurple':'#663399',\n    'red':'#ff0000',\n    'rosybrown':'#bc8f8f',\n    'royalblue':'#4169e1',\n    'saddlebrown':'#8b4513',\n    'salmon':'#fa8072',\n    'sandybrown':'#f4a460',\n    'seagreen':'#2e8b57',\n    'seashell':'#fff5ee',\n    'sienna':'#a0522d',\n    'silver':'#c0c0c0',\n    'skyblue':'#87ceeb',\n    'slateblue':'#6a5acd',\n    'slategray':'#708090',\n    'slategrey':'#708090',\n    'snow':'#fffafa',\n    'springgreen':'#00ff7f',\n    'steelblue':'#4682b4',\n    'tan':'#d2b48c',\n    'teal':'#008080',\n    'thistle':'#d8bfd8',\n    'tomato':'#ff6347',\n    'turquoise':'#40e0d0',\n    'violet':'#ee82ee',\n    'wheat':'#f5deb3',\n    'white':'#ffffff',\n    'whitesmoke':'#f5f5f5',\n    'yellow':'#ffff00',\n    'yellowgreen':'#9acd32'\n};","export default {\n    length: {\n        'm': 1,\n        'cm': 0.01,\n        'mm': 0.001,\n        'in': 0.0254,\n        'px': 0.0254 / 96,\n        'pt': 0.0254 / 72,\n        'pc': 0.0254 / 72 * 12\n    },\n    duration: {\n        's': 1,\n        'ms': 0.001\n    },\n    angle: {\n        'rad': 1 / (2 * Math.PI),\n        'deg': 1 / 360,\n        'grad': 1 / 400,\n        'turn': 1\n    }\n};","import colors from './colors';\nimport unitConversions from './unit-conversions';\n\nexport default { colors, unitConversions };\n","class Node {\n    constructor() {\n        this.parent = null;\n        this.visibilityBlocks = undefined;\n        this.nodeVisible = undefined;\n        this.rootNode = null;\n        this.parsed = null;\n\n        const self = this;\n        Object.defineProperty(this, 'currentFileInfo', {\n            get: function() { return self.fileInfo(); }\n        });\n        Object.defineProperty(this, 'index', {\n            get: function() { return self.getIndex(); }\n        });\n\n    }\n\n    setParent(nodes, parent) {\n        function set(node) {\n            if (node && node instanceof Node) {\n                node.parent = parent;\n            }\n        }\n        if (Array.isArray(nodes)) {\n            nodes.forEach(set);\n        }\n        else {\n            set(nodes);\n        }\n    }\n\n    getIndex() {\n        return this._index || (this.parent && this.parent.getIndex()) || 0;\n    }\n\n    fileInfo() {\n        return this._fileInfo || (this.parent && this.parent.fileInfo()) || {};\n    }\n\n    isRulesetLike() {\n        return false;\n    }\n\n    toCSS(context) {\n        const strs = [];\n        this.genCSS(context, {\n            add: function(chunk, fileInfo, index) {\n                strs.push(chunk);\n            },\n            isEmpty: function () {\n                return strs.length === 0;\n            }\n        });\n        return strs.join('');\n    }\n\n    genCSS(context, output) {\n        output.add(this.value);\n    }\n\n    accept(visitor) {\n        this.value = visitor.visit(this.value);\n    }\n\n    eval() { return this; }\n\n    _operate(context, op, a, b) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n            case '/': return a / b;\n        }\n    }\n\n    fround(context, value) {\n        const precision = context && context.numPrecision;\n        // add \"epsilon\" to ensure numbers like 1.000000005 (represented as 1.000000004999...) are properly rounded:\n        return (precision) ? Number((value + 2e-16).toFixed(precision)) : value;\n    }\n\n    // Returns true if this node represents root of ast imported by reference\n    blocksVisibility() {\n        if (this.visibilityBlocks == null) {\n            this.visibilityBlocks = 0;\n        }\n        return this.visibilityBlocks !== 0;\n    }\n\n    addVisibilityBlock() {\n        if (this.visibilityBlocks == null) {\n            this.visibilityBlocks = 0;\n        }\n        this.visibilityBlocks = this.visibilityBlocks + 1;\n    }\n\n    removeVisibilityBlock() {\n        if (this.visibilityBlocks == null) {\n            this.visibilityBlocks = 0;\n        }\n        this.visibilityBlocks = this.visibilityBlocks - 1;\n    }\n\n    // Turns on node visibility - if called node will be shown in output regardless\n    // of whether it comes from import by reference or not\n    ensureVisibility() {\n        this.nodeVisible = true;\n    }\n\n    // Turns off node visibility - if called node will NOT be shown in output regardless\n    // of whether it comes from import by reference or not\n    ensureInvisibility() {\n        this.nodeVisible = false;\n    }\n\n    // return values:\n    // false - the node must not be visible\n    // true - the node must be visible\n    // undefined or null - the node has the same visibility as its parent\n    isVisible() {\n        return this.nodeVisible;\n    }\n\n    visibilityInfo() {\n        return {\n            visibilityBlocks: this.visibilityBlocks,\n            nodeVisible: this.nodeVisible\n        };\n    }\n\n    copyVisibilityInfo(info) {\n        if (!info) {\n            return;\n        }\n        this.visibilityBlocks = info.visibilityBlocks;\n        this.nodeVisible = info.nodeVisible;\n    }\n}\n\nNode.compare = (a, b) => {\n    /* returns:\n     -1: a < b\n     0: a = b\n     1: a > b\n     and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */\n\n    if ((a.compare) &&\n        // for \"symmetric results\" force toCSS-based comparison\n        // of Quoted or Anonymous if either value is one of those\n        !(b.type === 'Quoted' || b.type === 'Anonymous')) {\n        return a.compare(b);\n    } else if (b.compare) {\n        return -b.compare(a);\n    } else if (a.type !== b.type) {\n        return undefined;\n    }\n\n    a = a.value;\n    b = b.value;\n    if (!Array.isArray(a)) {\n        return a === b ? 0 : undefined;\n    }\n    if (a.length !== b.length) {\n        return undefined;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (Node.compare(a[i], b[i]) !== 0) {\n            return undefined;\n        }\n    }\n    return 0;\n};\n\nNode.numericCompare = (a, b) => a  <  b ? -1\n    : a === b ?  0\n        : a  >  b ?  1 : undefined;\nexport default Node;\n","import Node from './node';\nimport colors from '../data/colors';\n\n//\n// RGB Colors - #ff0014, #eee\n//\nclass Color extends Node {\n    constructor(rgb, a, originalForm) {\n        super();\n\n        const self = this;\n        //\n        // The end goal here, is to parse the arguments\n        // into an integer triplet, such as `128, 255, 0`\n        //\n        // This facilitates operations and conversions.\n        //\n        if (Array.isArray(rgb)) {\n            this.rgb = rgb;\n        } else if (rgb.length >= 6) {\n            this.rgb = [];\n            rgb.match(/.{2}/g).map((c, i) => {\n                if (i < 3) {\n                    self.rgb.push(parseInt(c, 16));\n                } else {\n                    self.alpha = (parseInt(c, 16)) / 255;\n                }\n            });\n        } else {\n            this.rgb = [];\n            rgb.split('').map((c, i) => {\n                if (i < 3) {\n                    self.rgb.push(parseInt(c + c, 16));\n                } else {\n                    self.alpha = (parseInt(c + c, 16)) / 255;\n                }\n            });\n        }\n        this.alpha = this.alpha || (typeof a === 'number' ? a : 1);\n        if (typeof originalForm !== 'undefined') {\n            this.value = originalForm;\n        }\n    }\n\n    luma() {\n        let r = this.rgb[0] / 255;\n        let g = this.rgb[1] / 255;\n        let b = this.rgb[2] / 255;\n\n        r = (r <= 0.03928) ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);\n        g = (g <= 0.03928) ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);\n        b = (b <= 0.03928) ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);\n\n        return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    }\n\n    genCSS(context, output) {\n        output.add(this.toCSS(context));\n    }\n\n    toCSS(context, doNotCompress) {\n        const compress = context && context.compress && !doNotCompress;\n        let color;\n        let alpha;\n        let colorFunction;\n        let args = [];\n\n        // `value` is set if this color was originally\n        // converted from a named color string so we need\n        // to respect this and try to output named color too.\n        alpha = this.fround(context, this.alpha);\n\n        if (this.value) {\n            if (this.value.indexOf('rgb') === 0) {\n                if (alpha < 1) {\n                    colorFunction = 'rgba';\n                }\n            } else if (this.value.indexOf('hsl') === 0) {\n                if (alpha < 1) {\n                    colorFunction = 'hsla';\n                } else {\n                    colorFunction = 'hsl';\n                }\n            } else {\n                return this.value;\n            }\n        } else {\n            if (alpha < 1) {\n                colorFunction = 'rgba';\n            }\n        }\n\n        switch (colorFunction) {\n            case 'rgba':\n                args = this.rgb.map(c => clamp(Math.round(c), 255)).concat(clamp(alpha, 1));\n                break;\n            case 'hsla':\n                args.push(clamp(alpha, 1));\n            case 'hsl':\n                color = this.toHSL();\n                args = [\n                    this.fround(context, color.h),\n                    `${this.fround(context, color.s * 100)}%`,\n                    `${this.fround(context, color.l * 100)}%`\n                ].concat(args);\n        }\n\n        if (colorFunction) {\n            // Values are capped between `0` and `255`, rounded and zero-padded.\n            return `${colorFunction}(${args.join(`,${compress ? '' : ' '}`)})`;\n        }\n\n        color = this.toRGB();\n\n        if (compress) {\n            const splitcolor = color.split('');\n\n            // Convert color to short format\n            if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {\n                color = `#${splitcolor[1]}${splitcolor[3]}${splitcolor[5]}`;\n            }\n        }\n\n        return color;\n    }\n\n    //\n    // Operations have to be done per-channel, if not,\n    // channels will spill onto each other. Once we have\n    // our result, in the form of an integer triplet,\n    // we create a new Color node to hold the result.\n    //\n    operate(context, op, other) {\n        const rgb = new Array(3);\n        const alpha = this.alpha * (1 - other.alpha) + other.alpha;\n        for (let c = 0; c < 3; c++) {\n            rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);\n        }\n        return new Color(rgb, alpha);\n    }\n\n    toRGB() {\n        return toHex(this.rgb);\n    }\n\n    toHSL() {\n        const r = this.rgb[0] / 255;\n        const g = this.rgb[1] / 255;\n        const b = this.rgb[2] / 255;\n        const a = this.alpha;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        let h;\n        let s;\n        const l = (max + min) / 2;\n        const d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2;               break;\n                case b: h = (r - g) / d + 4;               break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s, l, a };\n    }\n\n    // Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n    toHSV() {\n        const r = this.rgb[0] / 255;\n        const g = this.rgb[1] / 255;\n        const b = this.rgb[2] / 255;\n        const a = this.alpha;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        let h;\n        let s;\n        const v = max;\n\n        const d = max - min;\n        if (max === 0) {\n            s = 0;\n        } else {\n            s = d / max;\n        }\n\n        if (max === min) {\n            h = 0;\n        } else {\n            switch (max) {\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2; break;\n                case b: h = (r - g) / d + 4; break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s, v, a };\n    }\n\n    toARGB() {\n        return toHex([this.alpha * 255].concat(this.rgb));\n    }\n\n    compare(x) {\n        return (x.rgb &&\n            x.rgb[0] === this.rgb[0] &&\n            x.rgb[1] === this.rgb[1] &&\n            x.rgb[2] === this.rgb[2] &&\n            x.alpha  === this.alpha) ? 0 : undefined;\n    }\n}\n\nColor.prototype.type = 'Color';\n\nfunction clamp(v, max) {\n    return Math.min(Math.max(v, 0), max);\n}\n\nfunction toHex(v) {\n    return `#${v.map(c => {\n        c = clamp(Math.round(c), 255);\n        return (c < 16 ? '0' : '') + c.toString(16);\n    }).join('')}`;\n}\n\nColor.fromKeyword = keyword => {\n    let c;\n    const key = keyword.toLowerCase();\n    if (colors.hasOwnProperty(key)) {\n        c = new Color(colors[key].slice(1));\n    }\n    else if (key === 'transparent') {\n        c = new Color([0, 0, 0], 0);\n    }\n\n    if (c) {\n        c.value = keyword;\n        return c;\n    }\n};\nexport default Color;\n","import Node from './node';\n\nclass Paren extends Node {\n    constructor(node) {\n        super();\n\n        this.value = node;\n    }\n\n    genCSS(context, output) {\n        output.add('(');\n        this.value.genCSS(context, output);\n        output.add(')');\n    }\n\n    eval(context) {\n        return new Paren(this.value.eval(context));\n    }\n}\n\nParen.prototype.type = 'Paren';\nexport default Paren;\n","import Node from './node';\nconst _noSpaceCombinators = {\n    '': true,\n    ' ': true,\n    '|': true\n};\n\nclass Combinator extends Node {\n    constructor(value) {\n        super();\n\n        if (value === ' ') {\n            this.value = ' ';\n            this.emptyOrWhitespace = true;\n        } else {\n            this.value = value ? value.trim() : '';\n            this.emptyOrWhitespace = this.value === '';\n        }\n    }\n\n    genCSS(context, output) {\n        const spaceOrEmpty = (context.compress || _noSpaceCombinators[this.value]) ? '' : ' ';\n        output.add(spaceOrEmpty + this.value + spaceOrEmpty);\n    }\n}\n\nCombinator.prototype.type = 'Combinator';\n\nexport default Combinator;\n","import Node from './node';\nimport Paren from './paren';\nimport Combinator from './combinator';\n\nclass Element extends Node {\n    constructor(combinator, value, isVariable, index, currentFileInfo, visibilityInfo) {\n        super();\n\n        this.combinator = combinator instanceof Combinator ?\n            combinator : new Combinator(combinator);\n\n        if (typeof value === 'string') {\n            this.value = value.trim();\n        } else if (value) {\n            this.value = value;\n        } else {\n            this.value = '';\n        }\n        this.isVariable = isVariable;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.setParent(this.combinator, this);\n    }\n\n    accept(visitor) {\n        const value = this.value;\n        this.combinator = visitor.visit(this.combinator);\n        if (typeof value === 'object') {\n            this.value = visitor.visit(value);\n        }\n    }\n\n    eval(context) {\n        return new Element(this.combinator,\n            this.value.eval ? this.value.eval(context) : this.value,\n            this.isVariable,\n            this.getIndex(),\n            this.fileInfo(), this.visibilityInfo());\n    }\n\n    clone() {\n        return new Element(this.combinator,\n            this.value,\n            this.isVariable,\n            this.getIndex(),\n            this.fileInfo(), this.visibilityInfo());\n    }\n\n    genCSS(context, output) {\n        output.add(this.toCSS(context), this.fileInfo(), this.getIndex());\n    }\n\n    toCSS(context = {}) {\n        let value = this.value;\n        const firstSelector = context.firstSelector;\n        if (value instanceof Paren) {\n            // selector in parens should not be affected by outer selector\n            // flags (breaks only interpolated selectors - see #1973)\n            context.firstSelector = true;\n        }\n        value = value.toCSS ? value.toCSS(context) : value;\n        context.firstSelector = firstSelector;\n        if (value === '' && this.combinator.value.charAt(0) === '&') {\n            return '';\n        } else {\n            return this.combinator.toCSS(context) + value;\n        }\n    }\n}\n\nElement.prototype.type = 'Element';\nexport default Element;\n","\nexport const Math = {\n    ALWAYS: 0,\n    PARENS_DIVISION: 1,\n    PARENS: 2,\n    STRICT_LEGACY: 3\n};\n\nexport const RewriteUrls = {\n    OFF: 0,\n    LOCAL: 1,\n    ALL: 2\n};","var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","/* jshint proto: true */\nimport * as Constants from './constants';\nimport CloneHelper from 'clone';\n\nexport function getLocation(index, inputStream) {\n    let n = index + 1;\n    let line = null;\n    let column = -1;\n\n    while (--n >= 0 && inputStream.charAt(n) !== '\\n') {\n        column++;\n    }\n\n    if (typeof index === 'number') {\n        line = (inputStream.slice(0, index).match(/\\n/g) || '').length;\n    }\n\n    return {\n        line,\n        column\n    };\n}\n\nexport function copyArray(arr) {\n    let i;\n    const length = arr.length;\n    const copy = new Array(length);\n\n    for (i = 0; i < length; i++) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\n\nexport function clone(obj) {\n    const cloned = {};\n    for (const prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            cloned[prop] = obj[prop];\n        }\n    }\n    return cloned;\n}\n\nexport function defaults(obj1, obj2) {\n    let newObj = obj2 || {};\n    if (!obj2._defaults) {\n        newObj = {};\n        const defaults = CloneHelper(obj1);\n        newObj._defaults = defaults;\n        const cloned = obj2 ? CloneHelper(obj2) : {};\n        Object.assign(newObj, defaults, cloned);\n    }\n    return newObj;\n}\n\nexport function copyOptions(obj1, obj2) {\n    if (obj2 && obj2._defaults) {\n        return obj2;\n    }\n    const opts = defaults(obj1, obj2);\n    if (opts.strictMath) {\n        opts.math = Constants.Math.STRICT_LEGACY;\n    }\n    // Back compat with changed relativeUrls option\n    if (opts.relativeUrls) {\n        opts.rewriteUrls = Constants.RewriteUrls.ALL;\n    }\n    if (typeof opts.math === 'string') {\n        switch (opts.math.toLowerCase()) {\n            case 'always':\n                opts.math = Constants.Math.ALWAYS;\n                break;\n            case 'parens-division':\n                opts.math = Constants.Math.PARENS_DIVISION;\n                break;\n            case 'strict':\n            case 'parens':\n                opts.math = Constants.Math.PARENS;\n                break;\n            case 'strict-legacy':\n                opts.math = Constants.Math.STRICT_LEGACY;\n        }\n    }\n    if (typeof opts.rewriteUrls === 'string') {\n        switch (opts.rewriteUrls.toLowerCase()) {\n            case 'off':\n                opts.rewriteUrls = Constants.RewriteUrls.OFF;\n                break;\n            case 'local':\n                opts.rewriteUrls = Constants.RewriteUrls.LOCAL;\n                break;\n            case 'all':\n                opts.rewriteUrls = Constants.RewriteUrls.ALL;\n                break;\n        }\n    }\n    return opts;\n}\n\nexport function merge(obj1, obj2) {\n    for (const prop in obj2) {\n        if (obj2.hasOwnProperty(prop)) {\n            obj1[prop] = obj2[prop];\n        }\n    }\n    return obj1;\n}\n\nexport function flattenArray(arr, result = []) {\n    for (let i = 0, length = arr.length; i < length; i++) {\n        const value = arr[i];\n        if (Array.isArray(value)) {\n            flattenArray(value, result);\n        } else {\n            if (value !== undefined) {\n                result.push(value);\n            }\n        }\n    }\n    return result;\n}","import * as utils from './utils';\n\nconst anonymousFunc = /(<anonymous>|Function):(\\d+):(\\d+)/;\n\n/**\n * This is a centralized class of any error that could be thrown internally (mostly by the parser).\n * Besides standard .message it keeps some additional data like a path to the file where the error\n * occurred along with line and column numbers.\n *\n * @class\n * @extends Error\n * @type {module.LessError}\n *\n * @prop {string} type\n * @prop {string} filename\n * @prop {number} index\n * @prop {number} line\n * @prop {number} column\n * @prop {number} callLine\n * @prop {number} callExtract\n * @prop {string[]} extract\n *\n * @param {Object} e              - An error object to wrap around or just a descriptive object\n * @param {Object} fileContentMap - An object with file contents in 'contents' property (like importManager) @todo - move to fileManager?\n * @param {string} [currentFilename]\n */\nconst LessError = function LessError(e, fileContentMap, currentFilename) {\n    Error.call(this);\n\n    const filename = e.filename || currentFilename;\n\n    this.message = e.message;\n    this.stack = e.stack;\n\n    if (fileContentMap && filename) {\n        const input = fileContentMap.contents[filename];\n        const loc = utils.getLocation(e.index, input);\n        const line = loc.line;\n        const col  = loc.column;\n        const callLine = e.call && utils.getLocation(e.call, input).line;\n        const lines = input ? input.split('\\n') : '';\n\n        this.type = e.type || 'Syntax';\n        this.filename = filename;\n        this.index = e.index;\n        this.line = typeof line === 'number' ? line + 1 : null;\n        this.column = col;\n\n        if (!this.line && this.stack) {\n            const found = this.stack.match(anonymousFunc);\n\n            /**\n             * We have to figure out how this environment stringifies anonymous functions\n             * so we can correctly map plugin errors.\n             */\n            const func = new Function('throw new Error()');\n            let lineAdjust = 0 \n            try {\n                func()\n            } catch (e) {\n                const match = e.stack.match(anonymousFunc);\n                const line = parseInt(match[2]);\n                lineAdjust = 1 - line\n            }\n\n            if (found) {\n                if (found[2]) {\n                    this.line = parseInt(found[2]) + lineAdjust;\n                }\n                if (found[3]) {\n                    this.column = parseInt(found[3]);\n                }\n            }\n        }\n\n        this.callLine = callLine + 1;\n        this.callExtract = lines[callLine];\n\n        this.extract = [\n            lines[this.line - 2],\n            lines[this.line - 1],\n            lines[this.line]\n        ];\n    }\n\n};\n\nif (typeof Object.create === 'undefined') {\n    const F = () => {};\n    F.prototype = Error.prototype;\n    LessError.prototype = new F();\n} else {\n    LessError.prototype = Object.create(Error.prototype);\n}\n\nLessError.prototype.constructor = LessError;\n\n/**\n * An overridden version of the default Object.prototype.toString\n * which uses additional information to create a helpful message.\n *\n * @param {Object} options\n * @returns {string}\n */\nLessError.prototype.toString = function(options = {}) {\n    let message = '';\n    const extract = this.extract || [];\n    let error = [];\n    let stylize = str => str;\n    if (options.stylize) {\n        const type = typeof options.stylize;\n        if (type !== 'function') {\n            throw Error(`options.stylize should be a function, got a ${type}!`);\n        }\n        stylize = options.stylize;\n    }\n\n    if (this.line !== null) {\n        if (typeof extract[0] === 'string') {\n            error.push(stylize(`${this.line - 1} ${extract[0]}`, 'grey'));\n        }\n\n        if (typeof extract[1] === 'string') {\n            let errorTxt = `${this.line} `;\n            if (extract[1]) {\n                errorTxt += extract[1].slice(0, this.column) +\n                    stylize(stylize(stylize(extract[1].substr(this.column, 1), 'bold') +\n                        extract[1].slice(this.column + 1), 'red'), 'inverse');\n            }\n            error.push(errorTxt);\n        }\n\n        if (typeof extract[2] === 'string') {\n            error.push(stylize(`${this.line + 1} ${extract[2]}`, 'grey'));\n        }\n        error = `${error.join('\\n') + stylize('', 'reset')}\\n`;\n    }\n\n    message += stylize(`${this.type}Error: ${this.message}`, 'red');\n    if (this.filename) {\n        message += stylize(' in ', 'red') + this.filename;\n    }\n    if (this.line) {\n        message += stylize(` on line ${this.line}, column ${this.column + 1}:`, 'grey');\n    }\n\n    message += `\\n${error}`;\n\n    if (this.callLine) {\n        message += `${stylize('from ', 'red') + (this.filename || '')}/n`;\n        message += `${stylize(this.callLine, 'grey')} ${this.callExtract}/n`;\n    }\n\n    return message;\n};\n\nexport default LessError;","import Node from './node';\nimport Element from './element';\nimport LessError from '../less-error';\n\nclass Selector extends Node {\n    constructor(elements, extendList, condition, index, currentFileInfo, visibilityInfo) {\n        super();\n\n        this.extendList = extendList;\n        this.condition = condition;\n        this.evaldCondition = !condition;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.elements = this.getElements(elements);\n        this.mixinElements_ = undefined;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.setParent(this.elements, this);\n    }\n\n    accept(visitor) {\n        if (this.elements) {\n            this.elements = visitor.visitArray(this.elements);\n        }\n        if (this.extendList) {\n            this.extendList = visitor.visitArray(this.extendList);\n        }\n        if (this.condition) {\n            this.condition = visitor.visit(this.condition);\n        }\n    }\n\n    createDerived(elements, extendList, evaldCondition) {\n        elements = this.getElements(elements);\n        const newSelector = new Selector(elements, extendList || this.extendList,\n            null, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n        newSelector.evaldCondition = (evaldCondition != null) ? evaldCondition : this.evaldCondition;\n        newSelector.mediaEmpty = this.mediaEmpty;\n        return newSelector;\n    }\n\n    getElements(els) {\n        if (!els) {\n            return [new Element('', '&', false, this._index, this._fileInfo)];\n        }\n        if (typeof els === 'string') {\n            this.parse.parseNode(\n                els, \n                ['selector'],\n                this._index, \n                this._fileInfo, \n                function(err, result) {\n                    if (err) {\n                        throw new LessError({\n                            index: err.index,\n                            message: err.message\n                        }, this.parse.imports, this._fileInfo.filename);\n                    }\n                    els = result[0].elements;\n                });\n        }\n        return els;\n    }\n\n    createEmptySelectors() {\n        const el = new Element('', '&', false, this._index, this._fileInfo);\n        const sels = [new Selector([el], null, null, this._index, this._fileInfo)];\n        sels[0].mediaEmpty = true;\n        return sels;\n    }\n\n    match(other) {\n        const elements = this.elements;\n        const len = elements.length;\n        let olen;\n        let i;\n\n        other = other.mixinElements();\n        olen = other.length;\n        if (olen === 0 || len < olen) {\n            return 0;\n        } else {\n            for (i = 0; i < olen; i++) {\n                if (elements[i].value !== other[i]) {\n                    return 0;\n                }\n            }\n        }\n\n        return olen; // return number of matched elements\n    }\n\n    mixinElements() {\n        if (this.mixinElements_) {\n            return this.mixinElements_;\n        }\n\n        let elements = this.elements.map( v => v.combinator.value + (v.value.value || v.value)).join('').match(/[,&#\\*\\.\\w-]([\\w-]|(\\\\.))*/g);\n\n        if (elements) {\n            if (elements[0] === '&') {\n                elements.shift();\n            }\n        } else {\n            elements = [];\n        }\n\n        return (this.mixinElements_ = elements);\n    }\n\n    isJustParentSelector() {\n        return !this.mediaEmpty &&\n            this.elements.length === 1 &&\n            this.elements[0].value === '&' &&\n            (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');\n    }\n\n    eval(context) {\n        const evaldCondition = this.condition && this.condition.eval(context);\n        let elements = this.elements;\n        let extendList = this.extendList;\n\n        elements = elements && elements.map(e => e.eval(context));\n        extendList = extendList && extendList.map(extend => extend.eval(context));\n\n        return this.createDerived(elements, extendList, evaldCondition);\n    }\n\n    genCSS(context, output) {\n        let i;\n        let element;\n        if ((!context || !context.firstSelector) && this.elements[0].combinator.value === '') {\n            output.add(' ', this.fileInfo(), this.getIndex());\n        }\n        for (i = 0; i < this.elements.length; i++) {\n            element = this.elements[i];\n            element.genCSS(context, output);\n        }\n    }\n\n    getIsOutput() {\n        return this.evaldCondition;\n    }\n}\n\nSelector.prototype.type = 'Selector';\nexport default Selector;\n","import Node from './node';\n\nclass Value extends Node {\n    constructor(value) {\n        super();\n\n        if (!value) {\n            throw new Error('Value requires an array argument');\n        }\n        if (!Array.isArray(value)) {\n            this.value = [ value ];\n        }\n        else {\n            this.value = value;\n        }\n    }\n\n    accept(visitor) {\n        if (this.value) {\n            this.value = visitor.visitArray(this.value);\n        }\n    }\n\n    eval(context) {\n        if (this.value.length === 1) {\n            return this.value[0].eval(context);\n        } else {\n            return new Value(this.value.map(v => v.eval(context)));\n        }\n    }\n\n    genCSS(context, output) {\n        let i;\n        for (i = 0; i < this.value.length; i++) {\n            this.value[i].genCSS(context, output);\n            if (i + 1 < this.value.length) {\n                output.add((context && context.compress) ? ',' : ', ');\n            }\n        }\n    }\n}\n\nValue.prototype.type = 'Value';\nexport default Value;\n","import Node from './node';\n\nclass Keyword extends Node {\n    constructor(value) {\n        super();\n\n        this.value = value;\n    }\n\n    genCSS(context, output) {\n        if (this.value === '%') { throw { type: 'Syntax', message: 'Invalid % without number' }; }\n        output.add(this.value);\n    }\n}\n\nKeyword.prototype.type = 'Keyword';\n\nKeyword.True = new Keyword('true');\nKeyword.False = new Keyword('false');\n\nexport default Keyword;\n","import Node from './node';\n\nclass Anonymous extends Node {\n    constructor(value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {\n        super();\n\n        this.value = value;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.mapLines = mapLines;\n        this.rulesetLike = (typeof rulesetLike === 'undefined') ? false : rulesetLike;\n        this.allowRoot = true;\n        this.copyVisibilityInfo(visibilityInfo);\n    }\n\n    eval() {\n        return new Anonymous(this.value, this._index, this._fileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());\n    }\n\n    compare(other) {\n        return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;\n    }\n\n    isRulesetLike() {\n        return this.rulesetLike;\n    }\n\n    genCSS(context, output) {\n        this.nodeVisible = Boolean(this.value);\n        if (this.nodeVisible) {\n            output.add(this.value, this._fileInfo, this._index, this.mapLines);\n        }\n    }\n}\n\nAnonymous.prototype.type = 'Anonymous';\nexport default Anonymous;\n","import Node from './node';\nimport Value from './value';\nimport Keyword from './keyword';\nimport Anonymous from './anonymous';\nimport * as Constants from '../constants';\nconst MATH = Constants.Math;\n\n\nclass Declaration extends Node {\n    constructor(name, value, important, merge, index, currentFileInfo, inline, variable) {\n        super();\n\n        this.name = name;\n        this.value = (value instanceof Node) ? value : new Value([value ? new Anonymous(value) : null]);\n        this.important = important ? ` ${important.trim()}` : '';\n        this.merge = merge;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.inline = inline || false;\n        this.variable = (variable !== undefined) ? variable\n            : (name.charAt && (name.charAt(0) === '@'));\n        this.allowRoot = true;\n        this.setParent(this.value, this);\n    }\n\n    genCSS(context, output) {\n        output.add(this.name + (context.compress ? ':' : ': '), this.fileInfo(), this.getIndex());\n        try {\n            this.value.genCSS(context, output);\n        }\n        catch (e) {\n            e.index = this._index;\n            e.filename = this._fileInfo.filename;\n            throw e;\n        }\n        output.add(this.important + ((this.inline || (context.lastRule && context.compress)) ? '' : ';'), this._fileInfo, this._index);\n    }\n\n    eval(context) {\n        let mathBypass = false;\n        let prevMath;\n        let name = this.name;\n        let evaldValue;\n        let variable = this.variable;\n        if (typeof name !== 'string') {\n            // expand 'primitive' name directly to get\n            // things faster (~10% for benchmark.less):\n            name = (name.length === 1) && (name[0] instanceof Keyword) ?\n                name[0].value : evalName(context, name);\n            variable = false; // never treat expanded interpolation as new variable name\n        }\n\n        // @todo remove when parens-division is default\n        if (name === 'font' && context.math === MATH.ALWAYS) {\n            mathBypass = true;\n            prevMath = context.math;\n            context.math = MATH.PARENS_DIVISION;\n        }\n        try {\n            context.importantScope.push({});\n            evaldValue = this.value.eval(context);\n\n            if (!this.variable && evaldValue.type === 'DetachedRuleset') {\n                throw { message: 'Rulesets cannot be evaluated on a property.',\n                    index: this.getIndex(), filename: this.fileInfo().filename };\n            }\n            let important = this.important;\n            const importantResult = context.importantScope.pop();\n            if (!important && importantResult.important) {\n                important = importantResult.important;\n            }\n\n            return new Declaration(name,\n                evaldValue,\n                important,\n                this.merge,\n                this.getIndex(), this.fileInfo(), this.inline,\n                variable);\n        }\n        catch (e) {\n            if (typeof e.index !== 'number') {\n                e.index = this.getIndex();\n                e.filename = this.fileInfo().filename;\n            }\n            throw e;\n        }\n        finally {\n            if (mathBypass) {\n                context.math = prevMath;\n            }\n        }\n    }\n\n    makeImportant() {\n        return new Declaration(this.name,\n            this.value,\n            '!important',\n            this.merge,\n            this.getIndex(), this.fileInfo(), this.inline);\n    }\n}\n\nfunction evalName(context, name) {\n    let value = '';\n    let i;\n    const n = name.length;\n    const output = {add: function (s) {value += s;}};\n    for (i = 0; i < n; i++) {\n        name[i].eval(context).genCSS(context, output);\n    }\n    return value;\n}\n\nDeclaration.prototype.type = 'Declaration';\nexport default Declaration;","const debugInfo = (context, ctx, lineSeparator) => {\n    let result = '';\n    if (context.dumpLineNumbers && !context.compress) {\n        switch (context.dumpLineNumbers) {\n            case 'comments':\n                result = debugInfo.asComment(ctx);\n                break;\n            case 'mediaquery':\n                result = debugInfo.asMediaQuery(ctx);\n                break;\n            case 'all':\n                result = debugInfo.asComment(ctx) + (lineSeparator || '') + debugInfo.asMediaQuery(ctx);\n                break;\n        }\n    }\n    return result;\n};\n\ndebugInfo.asComment = ctx => `/* line ${ctx.debugInfo.lineNumber}, ${ctx.debugInfo.fileName} */\\n`;\n\ndebugInfo.asMediaQuery = ctx => {\n    let filenameWithProtocol = ctx.debugInfo.fileName;\n    if (!/^[a-z]+:\\/\\//i.test(filenameWithProtocol)) {\n        filenameWithProtocol = `file://${filenameWithProtocol}`;\n    }\n    return `@media -sass-debug-info{filename{font-family:${filenameWithProtocol.replace(/([.:\\/\\\\])/g, a => {\n        if (a == '\\\\') {\n            a = '\\/';\n        }\n        return `\\\\${a}`;\n    })}}line{font-family:\\\\00003${ctx.debugInfo.lineNumber}}}\\n`;\n};\n\nexport default debugInfo;\n","import Node from './node';\nimport getDebugInfo from './debug-info';\n\nclass Comment extends Node {\n    constructor(value, isLineComment, index, currentFileInfo) {\n        super();\n\n        this.value = value;\n        this.isLineComment = isLineComment;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.allowRoot = true;\n    }\n\n    genCSS(context, output) {\n        if (this.debugInfo) {\n            output.add(getDebugInfo(context, this), this.fileInfo(), this.getIndex());\n        }\n        output.add(this.value);\n    }\n\n    isSilent(context) {\n        const isCompressed = context.compress && this.value[2] !== '!';\n        return this.isLineComment || isCompressed;\n    }\n}\n\nComment.prototype.type = 'Comment';\nexport default Comment;\n","const contexts = {};\nexport default contexts;\nimport * as Constants from './constants';\n\nconst copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {\n    if (!original) { return; }\n\n    for (let i = 0; i < propertiesToCopy.length; i++) {\n        if (original.hasOwnProperty(propertiesToCopy[i])) {\n            destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];\n        }\n    }\n};\n\n/*\n parse is used whilst parsing\n */\nconst parseCopyProperties = [\n    // options\n    'paths',            // option - unmodified - paths to search for imports on\n    'rewriteUrls',      // option - whether to adjust URL's to be relative\n    'rootpath',         // option - rootpath to append to URL's\n    'strictImports',    // option -\n    'insecure',         // option - whether to allow imports from insecure ssl hosts\n    'dumpLineNumbers',  // option - whether to dump line numbers\n    'compress',         // option - whether to compress\n    'syncImport',       // option - whether to import synchronously\n    'chunkInput',       // option - whether to chunk input. more performant but causes parse issues.\n    'mime',             // browser only - mime type for sheet import\n    'useFileCache',     // browser only - whether to use the per file session cache\n    // context\n    'processImports',   // option & context - whether to process imports. if false then imports will not be imported.\n    // Used by the import manager to stop multiple import visitors being created.\n    'pluginManager'     // Used as the plugin manager for the session\n];\n\ncontexts.Parse = function(options) {\n    copyFromOriginal(options, this, parseCopyProperties);\n\n    if (typeof this.paths === 'string') { this.paths = [this.paths]; }\n};\n\nconst evalCopyProperties = [\n    'paths',             // additional include paths\n    'compress',          // whether to compress\n    'math',              // whether math has to be within parenthesis\n    'strictUnits',       // whether units need to evaluate correctly\n    'sourceMap',         // whether to output a source map\n    'importMultiple',    // whether we are currently importing multiple copies\n    'urlArgs',           // whether to add args into url tokens\n    'javascriptEnabled', // option - whether Inline JavaScript is enabled. if undefined, defaults to false\n    'pluginManager',     // Used as the plugin manager for the session\n    'importantScope',    // used to bubble up !important statements\n    'rewriteUrls'        // option - whether to adjust URL's to be relative\n];\n\nfunction isPathRelative(path) {\n    return !/^(?:[a-z-]+:|\\/|#)/i.test(path);\n}\n\nfunction isPathLocalRelative(path) {\n    return path.charAt(0) === '.';\n}\n\ncontexts.Eval = class {\n    constructor(options, frames) {\n        copyFromOriginal(options, this, evalCopyProperties);\n\n        if (typeof this.paths === 'string') { this.paths = [this.paths]; }\n\n        this.frames = frames || [];\n        this.importantScope = this.importantScope || [];\n        this.inCalc = false;\n        this.mathOn = true;\n    }\n\n    enterCalc() {\n        if (!this.calcStack) {\n            this.calcStack = [];\n        }\n        this.calcStack.push(true);\n        this.inCalc = true;\n    }\n\n    exitCalc() {\n        this.calcStack.pop();\n        if (!this.calcStack) {\n            this.inCalc = false;\n        }\n    }\n\n    inParenthesis() {\n        if (!this.parensStack) {\n            this.parensStack = [];\n        }\n        this.parensStack.push(true);\n    };\n\n    outOfParenthesis() {\n        this.parensStack.pop();\n    };\n\n    isMathOn(op) {\n        if (!this.mathOn) {\n            return false;\n        }\n        if (op === '/' && this.math !== Constants.Math.ALWAYS && (!this.parensStack || !this.parensStack.length)) {\n            return false;\n        }\n        if (this.math > Constants.Math.PARENS_DIVISION) {\n            return this.parensStack && this.parensStack.length;\n        }\n        return true;\n    }\n\n    pathRequiresRewrite(path) {\n        const isRelative = this.rewriteUrls === Constants.RewriteUrls.LOCAL ? isPathLocalRelative : isPathRelative;\n\n        return isRelative(path);\n    }\n\n    rewritePath(path, rootpath) {\n        let newPath;\n\n        rootpath = rootpath || '';\n        newPath = this.normalizePath(rootpath + path);\n\n        // If a path was explicit relative and the rootpath was not an absolute path\n        // we must ensure that the new path is also explicit relative.\n        if (isPathLocalRelative(path) &&\n            isPathRelative(rootpath) &&\n            isPathLocalRelative(newPath) === false) {\n            newPath = `./${newPath}`;\n        }\n\n        return newPath;\n    }\n\n    normalizePath(path) {\n        const segments = path.split('/').reverse();\n        let segment;\n\n        path = [];\n        while (segments.length !== 0) {\n            segment = segments.pop();\n            switch ( segment ) {\n                case '.':\n                    break;\n                case '..':\n                    if ((path.length === 0) || (path[path.length - 1] === '..')) {\n                        path.push( segment );\n                    } else {\n                        path.pop();\n                    }\n                    break;\n                default:\n                    path.push(segment);\n                    break;\n            }\n        }\n\n        return path.join('/');\n    }\n}\n","function makeRegistry( base ) {\n    return {\n        _data: {},\n        add: function(name, func) {\n            // precautionary case conversion, as later querying of\n            // the registry by function-caller uses lower case as well.\n            name = name.toLowerCase();\n\n            if (this._data.hasOwnProperty(name)) {\n                // TODO warn\n            }\n            this._data[name] = func;\n        },\n        addMultiple: function(functions) {\n            Object.keys(functions).forEach(\n                name => {\n                    this.add(name, functions[name]);\n                });\n        },\n        get: function(name) {\n            return this._data[name] || ( base && base.get( name ));\n        },\n        getLocalFunctions: function() {\n            return this._data;\n        },\n        inherit: function() {\n            return makeRegistry( this );\n        },\n        create: function(base) {\n            return makeRegistry(base);\n        }\n    };\n}\n\nexport default makeRegistry( null );","import Keyword from '../tree/keyword';\n\nconst defaultFunc = {\n    eval: function () {\n        const v = this.value_;\n        const e = this.error_;\n        if (e) {\n            throw e;\n        }\n        if (v != null) {\n            return v ? Keyword.True : Keyword.False;\n        }\n    },\n    value: function (v) {\n        this.value_ = v;\n    },\n    error: function (e) {\n        this.error_ = e;\n    },\n    reset: function () {\n        this.value_ = this.error_ = null;\n    }\n};\n\nexport default defaultFunc;\n","import Node from './node';\nimport Declaration from './declaration';\nimport Keyword from './keyword';\nimport Comment from './comment';\nimport Paren from './paren';\nimport Selector from './selector';\nimport Element from './element';\nimport Anonymous from './anonymous';\nimport contexts from '../contexts';\nimport globalFunctionRegistry from '../functions/function-registry';\nimport defaultFunc from '../functions/default';\nimport getDebugInfo from './debug-info';\nimport * as utils from '../utils';\n\nclass Ruleset extends Node {\n    constructor(selectors, rules, strictImports, visibilityInfo) {\n        super();\n\n        this.selectors = selectors;\n        this.rules = rules;\n        this._lookups = {};\n        this._variables = null;\n        this._properties = null;\n        this.strictImports = strictImports;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.allowRoot = true;\n\n        this.setParent(this.selectors, this);\n        this.setParent(this.rules, this);\n\n    }\n\n    isRulesetLike() {\n        return true;\n    }\n\n    accept(visitor) {\n        if (this.paths) {\n            this.paths = visitor.visitArray(this.paths, true);\n        } else if (this.selectors) {\n            this.selectors = visitor.visitArray(this.selectors);\n        }\n        if (this.rules && this.rules.length) {\n            this.rules = visitor.visitArray(this.rules);\n        }\n    }\n\n    eval(context) {\n        const that = this;\n        let selectors;\n        let selCnt;\n        let selector;\n        let i;\n        let hasVariable;\n        let hasOnePassingSelector = false;\n\n        if (this.selectors && (selCnt = this.selectors.length)) {\n            selectors = new Array(selCnt);\n            defaultFunc.error({\n                type: 'Syntax',\n                message: 'it is currently only allowed in parametric mixin guards,'\n            });\n\n            for (i = 0; i < selCnt; i++) {\n                selector = this.selectors[i].eval(context);\n                for (var j = 0; j < selector.elements.length; j++) {\n                    if (selector.elements[j].isVariable) {\n                        hasVariable = true;\n                        break;\n                    }\n                }\n                selectors[i] = selector;\n                if (selector.evaldCondition) {\n                    hasOnePassingSelector = true;\n                }\n            }\n\n            if (hasVariable) {\n                const toParseSelectors = new Array(selCnt);\n                for (i = 0; i < selCnt; i++) {\n                    selector = selectors[i];\n                    toParseSelectors[i] = selector.toCSS(context);\n                }\n                this.parse.parseNode(\n                    toParseSelectors.join(','),\n                    [\"selectors\"], \n                    selectors[0].getIndex(), \n                    selectors[0].fileInfo(), \n                    (err, result) => {\n                        if (result) {\n                            selectors = utils.flattenArray(result);\n                        }\n                    });\n            }\n\n            defaultFunc.reset();\n        } else {\n            hasOnePassingSelector = true;\n        }\n\n        let rules = this.rules ? utils.copyArray(this.rules) : null;\n        const ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo());\n        let rule;\n        let subRule;\n\n        ruleset.originalRuleset = this;\n        ruleset.root = this.root;\n        ruleset.firstRoot = this.firstRoot;\n        ruleset.allowImports = this.allowImports;\n\n        if (this.debugInfo) {\n            ruleset.debugInfo = this.debugInfo;\n        }\n\n        if (!hasOnePassingSelector) {\n            rules.length = 0;\n        }\n\n        // inherit a function registry from the frames stack when possible;\n        // otherwise from the global registry\n        ruleset.functionRegistry = (frames => {\n            let i = 0;\n            const n = frames.length;\n            let found;\n            for ( ; i !== n ; ++i ) {\n                found = frames[ i ].functionRegistry;\n                if ( found ) { return found; }\n            }\n            return globalFunctionRegistry;\n        })(context.frames).inherit();\n\n        // push the current ruleset to the frames stack\n        const ctxFrames = context.frames;\n        ctxFrames.unshift(ruleset);\n\n        // currrent selectors\n        let ctxSelectors = context.selectors;\n        if (!ctxSelectors) {\n            context.selectors = ctxSelectors = [];\n        }\n        ctxSelectors.unshift(this.selectors);\n\n        // Evaluate imports\n        if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {\n            ruleset.evalImports(context);\n        }\n\n        // Store the frames around mixin definitions,\n        // so they can be evaluated like closures when the time comes.\n        const rsRules = ruleset.rules;\n        for (i = 0; (rule = rsRules[i]); i++) {\n            if (rule.evalFirst) {\n                rsRules[i] = rule.eval(context);\n            }\n        }\n\n        const mediaBlockCount = (context.mediaBlocks && context.mediaBlocks.length) || 0;\n\n        // Evaluate mixin calls.\n        for (i = 0; (rule = rsRules[i]); i++) {\n            if (rule.type === 'MixinCall') {\n                /* jshint loopfunc:true */\n                rules = rule.eval(context).filter(r => {\n                    if ((r instanceof Declaration) && r.variable) {\n                        // do not pollute the scope if the variable is\n                        // already there. consider returning false here\n                        // but we need a way to \"return\" variable from mixins\n                        return !(ruleset.variable(r.name));\n                    }\n                    return true;\n                });\n                rsRules.splice(...[i, 1].concat(rules));\n                i += rules.length - 1;\n                ruleset.resetCache();\n            } else if (rule.type ===  'VariableCall') {\n                /* jshint loopfunc:true */\n                rules = rule.eval(context).rules.filter(r => {\n                    if ((r instanceof Declaration) && r.variable) {\n                        // do not pollute the scope at all\n                        return false;\n                    }\n                    return true;\n                });\n                rsRules.splice(...[i, 1].concat(rules));\n                i += rules.length - 1;\n                ruleset.resetCache();\n            }\n        }\n\n        // Evaluate everything else\n        for (i = 0; (rule = rsRules[i]); i++) {\n            if (!rule.evalFirst) {\n                rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;\n            }\n        }\n\n        // Evaluate everything else\n        for (i = 0; (rule = rsRules[i]); i++) {\n            // for rulesets, check if it is a css guard and can be removed\n            if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {\n                // check if it can be folded in (e.g. & where)\n                if (rule.selectors[0] && rule.selectors[0].isJustParentSelector()) {\n                    rsRules.splice(i--, 1);\n\n                    for (var j = 0; (subRule = rule.rules[j]); j++) {\n                        if (subRule instanceof Node) {\n                            subRule.copyVisibilityInfo(rule.visibilityInfo());\n                            if (!(subRule instanceof Declaration) || !subRule.variable) {\n                                rsRules.splice(++i, 0, subRule);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Pop the stack\n        ctxFrames.shift();\n        ctxSelectors.shift();\n\n        if (context.mediaBlocks) {\n            for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {\n                context.mediaBlocks[i].bubbleSelectors(selectors);\n            }\n        }\n\n        return ruleset;\n    }\n\n    evalImports(context) {\n        const rules = this.rules;\n        let i;\n        let importRules;\n        if (!rules) { return; }\n\n        for (i = 0; i < rules.length; i++) {\n            if (rules[i].type === 'Import') {\n                importRules = rules[i].eval(context);\n                if (importRules && (importRules.length || importRules.length === 0)) {\n                    rules.splice(...[i, 1].concat(importRules));\n                    i += importRules.length - 1;\n                } else {\n                    rules.splice(i, 1, importRules);\n                }\n                this.resetCache();\n            }\n        }\n    }\n\n    makeImportant() {\n        const result = new Ruleset(this.selectors, this.rules.map(r => {\n            if (r.makeImportant) {\n                return r.makeImportant();\n            } else {\n                return r;\n            }\n        }), this.strictImports, this.visibilityInfo());\n\n        return result;\n    }\n\n    matchArgs(args) {\n        return !args || args.length === 0;\n    }\n\n    // lets you call a css selector with a guard\n    matchCondition(args, context) {\n        const lastSelector = this.selectors[this.selectors.length - 1];\n        if (!lastSelector.evaldCondition) {\n            return false;\n        }\n        if (lastSelector.condition &&\n            !lastSelector.condition.eval(\n                new contexts.Eval(context,\n                    context.frames))) {\n            return false;\n        }\n        return true;\n    }\n\n    resetCache() {\n        this._rulesets = null;\n        this._variables = null;\n        this._properties = null;\n        this._lookups = {};\n    }\n\n    variables() {\n        if (!this._variables) {\n            this._variables = !this.rules ? {} : this.rules.reduce((hash, r) => {\n                if (r instanceof Declaration && r.variable === true) {\n                    hash[r.name] = r;\n                }\n                // when evaluating variables in an import statement, imports have not been eval'd\n                // so we need to go inside import statements.\n                // guard against root being a string (in the case of inlined less)\n                if (r.type === 'Import' && r.root && r.root.variables) {\n                    const vars = r.root.variables();\n                    for (const name in vars) {\n                        if (vars.hasOwnProperty(name)) {\n                            hash[name] = r.root.variable(name);\n                        }\n                    }\n                }\n                return hash;\n            }, {});\n        }\n        return this._variables;\n    }\n\n    properties() {\n        if (!this._properties) {\n            this._properties = !this.rules ? {} : this.rules.reduce((hash, r) => {\n                if (r instanceof Declaration && r.variable !== true) {\n                    const name = (r.name.length === 1) && (r.name[0] instanceof Keyword) ?\n                        r.name[0].value : r.name;\n                    // Properties don't overwrite as they can merge\n                    if (!hash[`$${name}`]) {\n                        hash[`$${name}`] = [ r ];\n                    }\n                    else {\n                        hash[`$${name}`].push(r);\n                    }\n                }\n                return hash;\n            }, {});\n        }\n        return this._properties;\n    }\n\n    variable(name) {\n        const decl = this.variables()[name];\n        if (decl) {\n            return this.parseValue(decl);\n        }\n    }\n\n    property(name) {\n        const decl = this.properties()[name];\n        if (decl) {\n            return this.parseValue(decl);\n        }\n    }\n\n    lastDeclaration() {\n        for (let i = this.rules.length; i > 0; i--) {\n            const decl = this.rules[i - 1];\n            if (decl instanceof Declaration) {\n                return this.parseValue(decl);\n            }\n        }\n    }\n\n    parseValue(toParse) {\n        const self = this;\n        function transformDeclaration(decl) {\n            if (decl.value instanceof Anonymous && !decl.parsed) {\n                if (typeof decl.value.value === 'string') {\n                    this.parse.parseNode(\n                        decl.value.value,\n                        ['value', 'important'], \n                        decl.value.getIndex(), \n                        decl.fileInfo(), \n                        (err, result) => {\n                            if (err) {\n                                decl.parsed = true;\n                            }\n                            if (result) {\n                                decl.value = result[0];\n                                decl.important = result[1] || '';\n                                decl.parsed = true;\n                            }\n                        });\n                } else {\n                    decl.parsed = true;\n                }\n\n                return decl;\n            }\n            else {\n                return decl;\n            }\n        }\n        if (!Array.isArray(toParse)) {\n            return transformDeclaration.call(self, toParse);\n        }\n        else {\n            const nodes = [];\n            toParse.forEach(n => {\n                nodes.push(transformDeclaration.call(self, n));\n            });\n            return nodes;\n        }\n    }\n\n    rulesets() {\n        if (!this.rules) { return []; }\n\n        const filtRules = [];\n        const rules = this.rules;\n        let i;\n        let rule;\n\n        for (i = 0; (rule = rules[i]); i++) {\n            if (rule.isRuleset) {\n                filtRules.push(rule);\n            }\n        }\n\n        return filtRules;\n    }\n\n    prependRule(rule) {\n        const rules = this.rules;\n        if (rules) {\n            rules.unshift(rule);\n        } else {\n            this.rules = [ rule ];\n        }\n        this.setParent(rule, this);\n    }\n\n    find(selector, self = this, filter) {\n        const rules = [];\n        let match;\n        let foundMixins;\n        const key = selector.toCSS();\n\n        if (key in this._lookups) { return this._lookups[key]; }\n\n        this.rulesets().forEach(rule => {\n            if (rule !== self) {\n                for (let j = 0; j < rule.selectors.length; j++) {\n                    match = selector.match(rule.selectors[j]);\n                    if (match) {\n                        if (selector.elements.length > match) {\n                            if (!filter || filter(rule)) {\n                                foundMixins = rule.find(new Selector(selector.elements.slice(match)), self, filter);\n                                for (let i = 0; i < foundMixins.length; ++i) {\n                                    foundMixins[i].path.push(rule);\n                                }\n                                Array.prototype.push.apply(rules, foundMixins);\n                            }\n                        } else {\n                            rules.push({ rule, path: []});\n                        }\n                        break;\n                    }\n                }\n            }\n        });\n        this._lookups[key] = rules;\n        return rules;\n    }\n\n    genCSS(context, output) {\n        let i;\n        let j;\n        const charsetRuleNodes = [];\n        let ruleNodes = [];\n\n        let // Line number debugging\n            debugInfo;\n\n        let rule;\n        let path;\n\n        context.tabLevel = (context.tabLevel || 0);\n\n        if (!this.root) {\n            context.tabLevel++;\n        }\n\n        const tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join('  ');\n        const tabSetStr = context.compress ? '' : Array(context.tabLevel).join('  ');\n        let sep;\n\n        let charsetNodeIndex = 0;\n        let importNodeIndex = 0;\n        for (i = 0; (rule = this.rules[i]); i++) {\n            if (rule instanceof Comment) {\n                if (importNodeIndex === i) {\n                    importNodeIndex++;\n                }\n                ruleNodes.push(rule);\n            } else if (rule.isCharset && rule.isCharset()) {\n                ruleNodes.splice(charsetNodeIndex, 0, rule);\n                charsetNodeIndex++;\n                importNodeIndex++;\n            } else if (rule.type === 'Import') {\n                ruleNodes.splice(importNodeIndex, 0, rule);\n                importNodeIndex++;\n            } else {\n                ruleNodes.push(rule);\n            }\n        }\n        ruleNodes = charsetRuleNodes.concat(ruleNodes);\n\n        // If this is the root node, we don't render\n        // a selector, or {}.\n        if (!this.root) {\n            debugInfo = getDebugInfo(context, this, tabSetStr);\n\n            if (debugInfo) {\n                output.add(debugInfo);\n                output.add(tabSetStr);\n            }\n\n            const paths = this.paths;\n            const pathCnt = paths.length;\n            let pathSubCnt;\n\n            sep = context.compress ? ',' : (`,\\n${tabSetStr}`);\n\n            for (i = 0; i < pathCnt; i++) {\n                path = paths[i];\n                if (!(pathSubCnt = path.length)) { continue; }\n                if (i > 0) { output.add(sep); }\n\n                context.firstSelector = true;\n                path[0].genCSS(context, output);\n\n                context.firstSelector = false;\n                for (j = 1; j < pathSubCnt; j++) {\n                    path[j].genCSS(context, output);\n                }\n            }\n\n            output.add((context.compress ? '{' : ' {\\n') + tabRuleStr);\n        }\n\n        // Compile rules and rulesets\n        for (i = 0; (rule = ruleNodes[i]); i++) {\n\n            if (i + 1 === ruleNodes.length) {\n                context.lastRule = true;\n            }\n\n            const currentLastRule = context.lastRule;\n            if (rule.isRulesetLike(rule)) {\n                context.lastRule = false;\n            }\n\n            if (rule.genCSS) {\n                rule.genCSS(context, output);\n            } else if (rule.value) {\n                output.add(rule.value.toString());\n            }\n\n            context.lastRule = currentLastRule;\n\n            if (!context.lastRule && rule.isVisible()) {\n                output.add(context.compress ? '' : (`\\n${tabRuleStr}`));\n            } else {\n                context.lastRule = false;\n            }\n        }\n\n        if (!this.root) {\n            output.add((context.compress ? '}' : `\\n${tabSetStr}}`));\n            context.tabLevel--;\n        }\n\n        if (!output.isEmpty() && !context.compress && this.firstRoot) {\n            output.add('\\n');\n        }\n    }\n\n    joinSelectors(paths, context, selectors) {\n        for (let s = 0; s < selectors.length; s++) {\n            this.joinSelector(paths, context, selectors[s]);\n        }\n    }\n\n    joinSelector(paths, context, selector) {\n        function createParenthesis(elementsToPak, originalElement) {\n            let replacementParen;\n            let j;\n            if (elementsToPak.length === 0) {\n                replacementParen = new Paren(elementsToPak[0]);\n            } else {\n                const insideParent = new Array(elementsToPak.length);\n                for (j = 0; j < elementsToPak.length; j++) {\n                    insideParent[j] = new Element(\n                        null,\n                        elementsToPak[j],\n                        originalElement.isVariable,\n                        originalElement._index,\n                        originalElement._fileInfo\n                    );\n                }\n                replacementParen = new Paren(new Selector(insideParent));\n            }\n            return replacementParen;\n        }\n\n        function createSelector(containedElement, originalElement) {\n            let element;\n            let selector;\n            element = new Element(null, containedElement, originalElement.isVariable, originalElement._index, originalElement._fileInfo);\n            selector = new Selector([element]);\n            return selector;\n        }\n\n        // joins selector path from `beginningPath` with selector path in `addPath`\n        // `replacedElement` contains element that is being replaced by `addPath`\n        // returns concatenated path\n        function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {\n            let newSelectorPath;\n            let lastSelector;\n            let newJoinedSelector;\n            // our new selector path\n            newSelectorPath = [];\n\n            // construct the joined selector - if & is the first thing this will be empty,\n            // if not newJoinedSelector will be the last set of elements in the selector\n            if (beginningPath.length > 0) {\n                newSelectorPath = utils.copyArray(beginningPath);\n                lastSelector = newSelectorPath.pop();\n                newJoinedSelector = originalSelector.createDerived(utils.copyArray(lastSelector.elements));\n            }\n            else {\n                newJoinedSelector = originalSelector.createDerived([]);\n            }\n\n            if (addPath.length > 0) {\n                // /deep/ is a CSS4 selector - (removed, so should deprecate)\n                // that is valid without anything in front of it\n                // so if the & does not have a combinator that is \"\" or \" \" then\n                // and there is a combinator on the parent, then grab that.\n                // this also allows + a { & .b { .a & { ... though not sure why you would want to do that\n                let combinator = replacedElement.combinator;\n\n                const parentEl = addPath[0].elements[0];\n                if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {\n                    combinator = parentEl.combinator;\n                }\n                // join the elements so far with the first part of the parent\n                newJoinedSelector.elements.push(new Element(\n                    combinator,\n                    parentEl.value,\n                    replacedElement.isVariable,\n                    replacedElement._index,\n                    replacedElement._fileInfo\n                ));\n                newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));\n            }\n\n            // now add the joined selector - but only if it is not empty\n            if (newJoinedSelector.elements.length !== 0) {\n                newSelectorPath.push(newJoinedSelector);\n            }\n\n            // put together the parent selectors after the join (e.g. the rest of the parent)\n            if (addPath.length > 1) {\n                let restOfPath = addPath.slice(1);\n                restOfPath = restOfPath.map(selector => selector.createDerived(selector.elements, []));\n                newSelectorPath = newSelectorPath.concat(restOfPath);\n            }\n            return newSelectorPath;\n        }\n\n        // joins selector path from `beginningPath` with every selector path in `addPaths` array\n        // `replacedElement` contains element that is being replaced by `addPath`\n        // returns array with all concatenated paths\n        function addAllReplacementsIntoPath( beginningPath, addPaths, replacedElement, originalSelector, result) {\n            let j;\n            for (j = 0; j < beginningPath.length; j++) {\n                const newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);\n                result.push(newSelectorPath);\n            }\n            return result;\n        }\n\n        function mergeElementsOnToSelectors(elements, selectors) {\n            let i;\n            let sel;\n\n            if (elements.length === 0) {\n                return ;\n            }\n            if (selectors.length === 0) {\n                selectors.push([ new Selector(elements) ]);\n                return;\n            }\n\n            for (i = 0; (sel = selectors[i]); i++) {\n                // if the previous thing in sel is a parent this needs to join on to it\n                if (sel.length > 0) {\n                    sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));\n                }\n                else {\n                    sel.push(new Selector(elements));\n                }\n            }\n        }\n\n        // replace all parent selectors inside `inSelector` by content of `context` array\n        // resulting selectors are returned inside `paths` array\n        // returns true if `inSelector` contained at least one parent selector\n        function replaceParentSelector(paths, context, inSelector) {\n            // The paths are [[Selector]]\n            // The first list is a list of comma separated selectors\n            // The inner list is a list of inheritance separated selectors\n            // e.g.\n            // .a, .b {\n            //   .c {\n            //   }\n            // }\n            // == [[.a] [.c]] [[.b] [.c]]\n            //\n            let i;\n\n            let j;\n            let k;\n            let currentElements;\n            let newSelectors;\n            let selectorsMultiplied;\n            let sel;\n            let el;\n            let hadParentSelector = false;\n            let length;\n            let lastSelector;\n            function findNestedSelector(element) {\n                let maybeSelector;\n                if (!(element.value instanceof Paren)) {\n                    return null;\n                }\n\n                maybeSelector = element.value.value;\n                if (!(maybeSelector instanceof Selector)) {\n                    return null;\n                }\n\n                return maybeSelector;\n            }\n\n            // the elements from the current selector so far\n            currentElements = [];\n            // the current list of new selectors to add to the path.\n            // We will build it up. We initiate it with one empty selector as we \"multiply\" the new selectors\n            // by the parents\n            newSelectors = [\n                []\n            ];\n\n            for (i = 0; (el = inSelector.elements[i]); i++) {\n                // non parent reference elements just get added\n                if (el.value !== '&') {\n                    const nestedSelector = findNestedSelector(el);\n                    if (nestedSelector != null) {\n                        // merge the current list of non parent selector elements\n                        // on to the current list of selectors to add\n                        mergeElementsOnToSelectors(currentElements, newSelectors);\n\n                        const nestedPaths = [];\n                        let replaced;\n                        const replacedNewSelectors = [];\n                        replaced = replaceParentSelector(nestedPaths, context, nestedSelector);\n                        hadParentSelector = hadParentSelector || replaced;\n                        // the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors\n                        for (k = 0; k < nestedPaths.length; k++) {\n                            const replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);\n                            addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);\n                        }\n                        newSelectors = replacedNewSelectors;\n                        currentElements = [];\n                    } else {\n                        currentElements.push(el);\n                    }\n\n                } else {\n                    hadParentSelector = true;\n                    // the new list of selectors to add\n                    selectorsMultiplied = [];\n\n                    // merge the current list of non parent selector elements\n                    // on to the current list of selectors to add\n                    mergeElementsOnToSelectors(currentElements, newSelectors);\n\n                    // loop through our current selectors\n                    for (j = 0; j < newSelectors.length; j++) {\n                        sel = newSelectors[j];\n                        // if we don't have any parent paths, the & might be in a mixin so that it can be used\n                        // whether there are parents or not\n                        if (context.length === 0) {\n                            // the combinator used on el should now be applied to the next element instead so that\n                            // it is not lost\n                            if (sel.length > 0) {\n                                sel[0].elements.push(new Element(el.combinator, '', el.isVariable, el._index, el._fileInfo));\n                            }\n                            selectorsMultiplied.push(sel);\n                        }\n                        else {\n                            // and the parent selectors\n                            for (k = 0; k < context.length; k++) {\n                                // We need to put the current selectors\n                                // then join the last selector's elements on to the parents selectors\n                                const newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);\n                                // add that to our new set of selectors\n                                selectorsMultiplied.push(newSelectorPath);\n                            }\n                        }\n                    }\n\n                    // our new selectors has been multiplied, so reset the state\n                    newSelectors = selectorsMultiplied;\n                    currentElements = [];\n                }\n            }\n\n            // if we have any elements left over (e.g. .a& .b == .b)\n            // add them on to all the current selectors\n            mergeElementsOnToSelectors(currentElements, newSelectors);\n\n            for (i = 0; i < newSelectors.length; i++) {\n                length = newSelectors[i].length;\n                if (length > 0) {\n                    paths.push(newSelectors[i]);\n                    lastSelector = newSelectors[i][length - 1];\n                    newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);\n                }\n            }\n\n            return hadParentSelector;\n        }\n\n        function deriveSelector(visibilityInfo, deriveFrom) {\n            const newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);\n            newSelector.copyVisibilityInfo(visibilityInfo);\n            return newSelector;\n        }\n\n        // joinSelector code follows\n        let i;\n\n        let newPaths;\n        let hadParentSelector;\n\n        newPaths = [];\n        hadParentSelector = replaceParentSelector(newPaths, context, selector);\n\n        if (!hadParentSelector) {\n            if (context.length > 0) {\n                newPaths = [];\n                for (i = 0; i < context.length; i++) {\n\n                    const concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));\n\n                    concatenated.push(selector);\n                    newPaths.push(concatenated);\n                }\n            }\n            else {\n                newPaths = [[selector]];\n            }\n        }\n\n        for (i = 0; i < newPaths.length; i++) {\n            paths.push(newPaths[i]);\n        }\n    }\n}\n\nRuleset.prototype.type = 'Ruleset';\nRuleset.prototype.isRuleset = true;\nexport default Ruleset;\n","import Node from './node';\nimport Selector from './selector';\nimport Ruleset from './ruleset';\nimport Anonymous from './anonymous';\n\nclass AtRule extends Node {\n    constructor(\n        name,\n        value,\n        rules,\n        index,\n        currentFileInfo,\n        debugInfo,\n        isRooted,\n        visibilityInfo\n    ) {\n        super();\n\n        let i;\n\n        this.name  = name;\n        this.value = (value instanceof Node) ? value : (value ? new Anonymous(value) : value);\n        if (rules) {\n            if (Array.isArray(rules)) {\n                this.rules = rules;\n            } else {\n                this.rules = [rules];\n                this.rules[0].selectors = (new Selector([], null, null, index, currentFileInfo)).createEmptySelectors();\n            }\n            for (i = 0; i < this.rules.length; i++) {\n                this.rules[i].allowImports = true;\n            }\n            this.setParent(this.rules, this);\n        }\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.debugInfo = debugInfo;\n        this.isRooted = isRooted || false;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.allowRoot = true;\n    }\n\n    accept(visitor) {\n        const value = this.value;\n        const rules = this.rules;\n        if (rules) {\n            this.rules = visitor.visitArray(rules);\n        }\n        if (value) {\n            this.value = visitor.visit(value);\n        }\n    }\n\n    isRulesetLike() {\n        return this.rules || !this.isCharset();\n    }\n\n    isCharset() {\n        return '@charset' === this.name;\n    }\n\n    genCSS(context, output) {\n        const value = this.value;\n        const rules = this.rules;\n        output.add(this.name, this.fileInfo(), this.getIndex());\n        if (value) {\n            output.add(' ');\n            value.genCSS(context, output);\n        }\n        if (rules) {\n            this.outputRuleset(context, output, rules);\n        } else {\n            output.add(';');\n        }\n    }\n\n    eval(context) {\n        let mediaPathBackup;\n        let mediaBlocksBackup;\n        let value = this.value;\n        let rules = this.rules;\n\n        // media stored inside other atrule should not bubble over it\n        // backpup media bubbling information\n        mediaPathBackup = context.mediaPath;\n        mediaBlocksBackup = context.mediaBlocks;\n        // deleted media bubbling information\n        context.mediaPath = [];\n        context.mediaBlocks = [];\n\n        if (value) {\n            value = value.eval(context);\n        }\n        if (rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            rules = [rules[0].eval(context)];\n            rules[0].root = true;\n        }\n        // restore media bubbling information\n        context.mediaPath = mediaPathBackup;\n        context.mediaBlocks = mediaBlocksBackup;\n\n        return new AtRule(this.name, value, rules,\n            this.getIndex(), this.fileInfo(), this.debugInfo, this.isRooted, this.visibilityInfo());\n    }\n\n    variable(name) {\n        if (this.rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            return Ruleset.prototype.variable.call(this.rules[0], name);\n        }\n    }\n\n    find(...args) {\n        if (this.rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            return Ruleset.prototype.find.apply(this.rules[0], args);\n        }\n    }\n\n    rulesets() {\n        if (this.rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            return Ruleset.prototype.rulesets.apply(this.rules[0]);\n        }\n    }\n\n    outputRuleset(context, output, rules) {\n        const ruleCnt = rules.length;\n        let i;\n        context.tabLevel = (context.tabLevel | 0) + 1;\n\n        // Compressed\n        if (context.compress) {\n            output.add('{');\n            for (i = 0; i < ruleCnt; i++) {\n                rules[i].genCSS(context, output);\n            }\n            output.add('}');\n            context.tabLevel--;\n            return;\n        }\n\n        // Non-compressed\n        const tabSetStr = `\\n${Array(context.tabLevel).join('  ')}`;\n\n        const tabRuleStr = `${tabSetStr}  `;\n        if (!ruleCnt) {\n            output.add(` {${tabSetStr}}`);\n        } else {\n            output.add(` {${tabRuleStr}`);\n            rules[0].genCSS(context, output);\n            for (i = 1; i < ruleCnt; i++) {\n                output.add(tabRuleStr);\n                rules[i].genCSS(context, output);\n            }\n            output.add(`${tabSetStr}}`);\n        }\n\n        context.tabLevel--;\n    }\n}\n\nAtRule.prototype.type = 'AtRule';\nexport default AtRule;\n","import Node from './node';\nimport contexts from '../contexts';\nimport * as utils from '../utils';\n\nclass DetachedRuleset extends Node {\n    constructor(ruleset, frames) {\n        super();\n\n        this.ruleset = ruleset;\n        this.frames = frames;\n        this.setParent(this.ruleset, this);\n    }\n\n    accept(visitor) {\n        this.ruleset = visitor.visit(this.ruleset);\n    }\n\n    eval(context) {\n        const frames = this.frames || utils.copyArray(context.frames);\n        return new DetachedRuleset(this.ruleset, frames);\n    }\n\n    callEval(context) {\n        return this.ruleset.eval(this.frames ? new contexts.Eval(context, this.frames.concat(context.frames)) : context);\n    }\n}\n\nDetachedRuleset.prototype.type = 'DetachedRuleset';\nDetachedRuleset.prototype.evalFirst = true;\nexport default DetachedRuleset;\n","import Node from './node';\nimport unitConversions from '../data/unit-conversions';\nimport * as utils from '../utils';\n\nclass Unit extends Node {\n    constructor(numerator, denominator, backupUnit) {\n        super();\n\n        this.numerator = numerator ? utils.copyArray(numerator).sort() : [];\n        this.denominator = denominator ? utils.copyArray(denominator).sort() : [];\n        if (backupUnit) {\n            this.backupUnit = backupUnit;\n        } else if (numerator && numerator.length) {\n            this.backupUnit = numerator[0];\n        }\n    }\n\n    clone() {\n        return new Unit(utils.copyArray(this.numerator), utils.copyArray(this.denominator), this.backupUnit);\n    }\n\n    genCSS(context, output) {\n        // Dimension checks the unit is singular and throws an error if in strict math mode.\n        const strictUnits = context && context.strictUnits;\n        if (this.numerator.length === 1) {\n            output.add(this.numerator[0]); // the ideal situation\n        } else if (!strictUnits && this.backupUnit) {\n            output.add(this.backupUnit);\n        } else if (!strictUnits && this.denominator.length) {\n            output.add(this.denominator[0]);\n        }\n    }\n\n    toString() {\n        let i;\n        let returnStr = this.numerator.join('*');\n        for (i = 0; i < this.denominator.length; i++) {\n            returnStr += `/${this.denominator[i]}`;\n        }\n        return returnStr;\n    }\n\n    compare(other) {\n        return this.is(other.toString()) ? 0 : undefined;\n    }\n\n    is(unitString) {\n        return this.toString().toUpperCase() === unitString.toUpperCase();\n    }\n\n    isLength() {\n        return RegExp('^(px|em|ex|ch|rem|in|cm|mm|pc|pt|ex|vw|vh|vmin|vmax)$', 'gi').test(this.toCSS());\n    }\n\n    isEmpty() {\n        return this.numerator.length === 0 && this.denominator.length === 0;\n    }\n\n    isSingular() {\n        return this.numerator.length <= 1 && this.denominator.length === 0;\n    }\n\n    map(callback) {\n        let i;\n\n        for (i = 0; i < this.numerator.length; i++) {\n            this.numerator[i] = callback(this.numerator[i], false);\n        }\n\n        for (i = 0; i < this.denominator.length; i++) {\n            this.denominator[i] = callback(this.denominator[i], true);\n        }\n    }\n\n    usedUnits() {\n        let group;\n        const result = {};\n        let mapUnit;\n        let groupName;\n\n        mapUnit = atomicUnit => {\n            /* jshint loopfunc:true */\n            if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {\n                result[groupName] = atomicUnit;\n            }\n\n            return atomicUnit;\n        };\n\n        for (groupName in unitConversions) {\n            if (unitConversions.hasOwnProperty(groupName)) {\n                group = unitConversions[groupName];\n\n                this.map(mapUnit);\n            }\n        }\n\n        return result;\n    }\n\n    cancel() {\n        const counter = {};\n        let atomicUnit;\n        let i;\n\n        for (i = 0; i < this.numerator.length; i++) {\n            atomicUnit = this.numerator[i];\n            counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;\n        }\n\n        for (i = 0; i < this.denominator.length; i++) {\n            atomicUnit = this.denominator[i];\n            counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;\n        }\n\n        this.numerator = [];\n        this.denominator = [];\n\n        for (atomicUnit in counter) {\n            if (counter.hasOwnProperty(atomicUnit)) {\n                const count = counter[atomicUnit];\n\n                if (count > 0) {\n                    for (i = 0; i < count; i++) {\n                        this.numerator.push(atomicUnit);\n                    }\n                } else if (count < 0) {\n                    for (i = 0; i < -count; i++) {\n                        this.denominator.push(atomicUnit);\n                    }\n                }\n            }\n        }\n\n        this.numerator.sort();\n        this.denominator.sort();\n    }\n}\n\nUnit.prototype.type = 'Unit';\nexport default Unit;\n","import Node from './node';\nimport unitConversions from '../data/unit-conversions';\nimport Unit from './unit';\nimport Color from './color';\n\n//\n// A number with a unit\n//\nclass Dimension extends Node {\n    constructor(value, unit) {\n        super();\n\n        this.value = parseFloat(value);\n        if (isNaN(this.value)) {\n            throw new Error('Dimension is not a number.');\n        }\n        this.unit = (unit && unit instanceof Unit) ? unit :\n            new Unit(unit ? [unit] : undefined);\n        this.setParent(this.unit, this);\n    }\n\n    accept(visitor) {\n        this.unit = visitor.visit(this.unit);\n    }\n\n    eval(context) {\n        return this;\n    }\n\n    toColor() {\n        return new Color([this.value, this.value, this.value]);\n    }\n\n    genCSS(context, output) {\n        if ((context && context.strictUnits) && !this.unit.isSingular()) {\n            throw new Error(`Multiple units in dimension. Correct the units or use the unit function. Bad unit: ${this.unit.toString()}`);\n        }\n\n        const value = this.fround(context, this.value);\n        let strValue = String(value);\n\n        if (value !== 0 && value < 0.000001 && value > -0.000001) {\n            // would be output 1e-6 etc.\n            strValue = value.toFixed(20).replace(/0+$/, '');\n        }\n\n        if (context && context.compress) {\n            // Zero values doesn't need a unit\n            if (value === 0 && this.unit.isLength()) {\n                output.add(strValue);\n                return;\n            }\n\n            // Float values doesn't need a leading zero\n            if (value > 0 && value < 1) {\n                strValue = (strValue).substr(1);\n            }\n        }\n\n        output.add(strValue);\n        this.unit.genCSS(context, output);\n    }\n\n    // In an operation between two Dimensions,\n    // we default to the first Dimension's unit,\n    // so `1px + 2` will yield `3px`.\n    operate(context, op, other) {\n        /* jshint noempty:false */\n        let value = this._operate(context, op, this.value, other.value);\n\n        let unit = this.unit.clone();\n\n        if (op === '+' || op === '-') {\n            if (unit.numerator.length === 0 && unit.denominator.length === 0) {\n                unit = other.unit.clone();\n                if (this.unit.backupUnit) {\n                    unit.backupUnit = this.unit.backupUnit;\n                }\n            } else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) {\n                // do nothing\n            } else {\n                other = other.convertTo(this.unit.usedUnits());\n\n                if (context.strictUnits && other.unit.toString() !== unit.toString()) {\n                    throw new Error(`Incompatible units. Change the units or use the unit function. ` + \n                        `Bad units: '${unit.toString()}' and '${other.unit.toString()}'.`);\n                }\n\n                value = this._operate(context, op, this.value, other.value);\n            }\n        } else if (op === '*') {\n            unit.numerator = unit.numerator.concat(other.unit.numerator).sort();\n            unit.denominator = unit.denominator.concat(other.unit.denominator).sort();\n            unit.cancel();\n        } else if (op === '/') {\n            unit.numerator = unit.numerator.concat(other.unit.denominator).sort();\n            unit.denominator = unit.denominator.concat(other.unit.numerator).sort();\n            unit.cancel();\n        }\n        return new Dimension(value, unit);\n    }\n\n    compare(other) {\n        let a;\n        let b;\n\n        if (!(other instanceof Dimension)) {\n            return undefined;\n        }\n\n        if (this.unit.isEmpty() || other.unit.isEmpty()) {\n            a = this;\n            b = other;\n        } else {\n            a = this.unify();\n            b = other.unify();\n            if (a.unit.compare(b.unit) !== 0) {\n                return undefined;\n            }\n        }\n\n        return Node.numericCompare(a.value, b.value);\n    }\n\n    unify() {\n        return this.convertTo({ length: 'px', duration: 's', angle: 'rad' });\n    }\n\n    convertTo(conversions) {\n        let value = this.value;\n        const unit = this.unit.clone();\n        let i;\n        let groupName;\n        let group;\n        let targetUnit;\n        let derivedConversions = {};\n        let applyUnit;\n\n        if (typeof conversions === 'string') {\n            for (i in unitConversions) {\n                if (unitConversions[i].hasOwnProperty(conversions)) {\n                    derivedConversions = {};\n                    derivedConversions[i] = conversions;\n                }\n            }\n            conversions = derivedConversions;\n        }\n        applyUnit = (atomicUnit, denominator) => {\n            /* jshint loopfunc:true */\n            if (group.hasOwnProperty(atomicUnit)) {\n                if (denominator) {\n                    value = value / (group[atomicUnit] / group[targetUnit]);\n                } else {\n                    value = value * (group[atomicUnit] / group[targetUnit]);\n                }\n\n                return targetUnit;\n            }\n\n            return atomicUnit;\n        };\n\n        for (groupName in conversions) {\n            if (conversions.hasOwnProperty(groupName)) {\n                targetUnit = conversions[groupName];\n                group = unitConversions[groupName];\n\n                unit.map(applyUnit);\n            }\n        }\n\n        unit.cancel();\n\n        return new Dimension(value, unit);\n    }\n}\n\nDimension.prototype.type = 'Dimension';\nexport default Dimension;\n","import Node from './node';\nimport Color from './color';\nimport Dimension from './dimension';\nimport * as Constants from '../constants';\nconst MATH = Constants.Math;\n\n\nclass Operation extends Node {\n    constructor(op, operands, isSpaced) {\n        super();\n\n        this.op = op.trim();\n        this.operands = operands;\n        this.isSpaced = isSpaced;\n    }\n\n    accept(visitor) {\n        this.operands = visitor.visitArray(this.operands);\n    }\n\n    eval(context) {\n        let a = this.operands[0].eval(context);\n        let b = this.operands[1].eval(context);\n        let op;\n\n        if (context.isMathOn(this.op)) {\n            op = this.op === './' ? '/' : this.op;\n            if (a instanceof Dimension && b instanceof Color) {\n                a = a.toColor();\n            }\n            if (b instanceof Dimension && a instanceof Color) {\n                b = b.toColor();\n            }\n            if (!a.operate) {\n                if (a instanceof Operation && a.op === '/' && context.math === MATH.PARENS_DIVISION) {\n                    return new Operation(this.op, [a, b], this.isSpaced);\n                }\n                throw { type: 'Operation',\n                    message: 'Operation on an invalid type' };\n            }\n\n            return a.operate(context, op, b);\n        } else {\n            return new Operation(this.op, [a, b], this.isSpaced);\n        }\n    }\n\n    genCSS(context, output) {\n        this.operands[0].genCSS(context, output);\n        if (this.isSpaced) {\n            output.add(' ');\n        }\n        output.add(this.op);\n        if (this.isSpaced) {\n            output.add(' ');\n        }\n        this.operands[1].genCSS(context, output);\n    }\n}\n\nOperation.prototype.type = 'Operation';\nexport default Operation;\n","import Node from './node';\nimport Paren from './paren';\nimport Comment from './comment';\nimport Dimension from './dimension';\nimport * as Constants from '../constants';\nconst MATH = Constants.Math;\n\nclass Expression extends Node {\n    constructor(value, noSpacing) {\n        super();\n\n        this.value = value;\n        this.noSpacing = noSpacing;\n        if (!value) {\n            throw new Error('Expression requires an array parameter');\n        }\n    }\n\n    accept(visitor) {\n        this.value = visitor.visitArray(this.value);\n    }\n\n    eval(context) {\n        let returnValue;\n        const mathOn = context.isMathOn();\n\n        const inParenthesis = this.parens && \n            (context.math !== MATH.STRICT_LEGACY || !this.parensInOp);\n\n        let doubleParen = false;\n        if (inParenthesis) {\n            context.inParenthesis();\n        }\n        if (this.value.length > 1) {\n            returnValue = new Expression(this.value.map(e => {\n                if (!e.eval) {\n                    return e;\n                }\n                return e.eval(context);\n            }), this.noSpacing);\n        } else if (this.value.length === 1) {\n            if (this.value[0].parens && !this.value[0].parensInOp && !context.inCalc) {\n                doubleParen = true;\n            }\n            returnValue = this.value[0].eval(context);\n        } else {\n            returnValue = this;\n        }\n        if (inParenthesis) {\n            context.outOfParenthesis();\n        }\n        if (this.parens && this.parensInOp && !mathOn && !doubleParen \n            && (!(returnValue instanceof Dimension))) {\n            returnValue = new Paren(returnValue);\n        }\n        return returnValue;\n    }\n\n    genCSS(context, output) {\n        for (let i = 0; i < this.value.length; i++) {\n            this.value[i].genCSS(context, output);\n            if (!this.noSpacing && i + 1 < this.value.length) {\n                output.add(' ');\n            }\n        }\n    }\n\n    throwAwayComments() {\n        this.value = this.value.filter(v => !(v instanceof Comment));\n    }\n}\n\nExpression.prototype.type = 'Expression';\nexport default Expression;\n","import Expression from '../tree/expression';\n\nclass functionCaller {\n    constructor(name, context, index, currentFileInfo) {\n        this.name = name.toLowerCase();\n        this.index = index;\n        this.context = context;\n        this.currentFileInfo = currentFileInfo;\n\n        this.func = context.frames[0].functionRegistry.get(this.name);\n    }\n\n    isValid() {\n        return Boolean(this.func);\n    }\n\n    call(args) {\n        // This code is terrible and should be replaced as per this issue...\n        // https://github.com/less/less.js/issues/2477\n        if (Array.isArray(args)) {\n            args = args.filter(item => {\n                if (item.type === 'Comment') {\n                    return false;\n                }\n                return true;\n            })\n                .map(item => {\n                    if (item.type === 'Expression') {\n                        const subNodes = item.value.filter(item => {\n                            if (item.type === 'Comment') {\n                                return false;\n                            }\n                            return true;\n                        });\n                        if (subNodes.length === 1) {\n                            return subNodes[0];\n                        } else {\n                            return new Expression(subNodes);\n                        }\n                    }\n                    return item;\n                });\n        }\n\n        return this.func(...args);\n    }\n}\n\nexport default functionCaller;\n","import Node from './node';\nimport Anonymous from './anonymous';\nimport FunctionCaller from '../functions/function-caller';\n\n//\n// A function call node.\n//\nclass Call extends Node {\n    constructor(name, args, index, currentFileInfo) {\n        super();\n\n        this.name = name;\n        this.args = args;\n        this.calc = name === 'calc';\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n    }\n\n    accept(visitor) {\n        if (this.args) {\n            this.args = visitor.visitArray(this.args);\n        }\n    }\n\n    //\n    // When evaluating a function call,\n    // we either find the function in the functionRegistry,\n    // in which case we call it, passing the  evaluated arguments,\n    // if this returns null or we cannot find the function, we\n    // simply print it out as it appeared originally [2].\n    //\n    // The reason why we evaluate the arguments, is in the case where\n    // we try to pass a variable to a function, like: `saturate(@color)`.\n    // The function should receive the value, not the variable.\n    //\n    eval(context) {\n        /**\n         * Turn off math for calc(), and switch back on for evaluating nested functions\n         */\n        const currentMathContext = context.mathOn;\n        context.mathOn = !this.calc;\n        if (this.calc || context.inCalc) {\n            context.enterCalc();\n        }\n        const args = this.args.map(a => a.eval(context));\n        if (this.calc || context.inCalc) {\n            context.exitCalc();\n        }\n        context.mathOn = currentMathContext;\n\n        let result;\n        const funcCaller = new FunctionCaller(this.name, context, this.getIndex(), this.fileInfo());\n\n        if (funcCaller.isValid()) {\n            try {\n                result = funcCaller.call(args);\n            } catch (e) {\n                throw { \n                    type: e.type || 'Runtime',\n                    message: `error evaluating function \\`${this.name}\\`${e.message ? `: ${e.message}` : ''}`,\n                    index: this.getIndex(), \n                    filename: this.fileInfo().filename,\n                    line: e.lineNumber,\n                    column: e.columnNumber\n                };\n            }\n\n            if (result !== null && result !== undefined) {\n                // Results that that are not nodes are cast as Anonymous nodes\n                // Falsy values or booleans are returned as empty nodes\n                if (!(result instanceof Node)) {\n                    if (!result || result === true) {\n                        result = new Anonymous(null); \n                    }\n                    else {\n                        result = new Anonymous(result.toString()); \n                    }\n                    \n                }\n                result._index = this._index;\n                result._fileInfo = this._fileInfo;\n                return result;\n            }\n\n        }\n\n        return new Call(this.name, args, this.getIndex(), this.fileInfo());\n    }\n\n    genCSS(context, output) {\n        output.add(`${this.name}(`, this.fileInfo(), this.getIndex());\n\n        for (let i = 0; i < this.args.length; i++) {\n            this.args[i].genCSS(context, output);\n            if (i + 1 < this.args.length) {\n                output.add(', ');\n            }\n        }\n\n        output.add(')');\n    }\n}\n\nCall.prototype.type = 'Call';\nexport default Call;\n","import Node from './node';\nimport Call from './call';\n\nclass Variable extends Node {\n    constructor(name, index, currentFileInfo) {\n        super();\n\n        this.name = name;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n    }\n\n    eval(context) {\n        let variable;\n        let name = this.name;\n\n        if (name.indexOf('@@') === 0) {\n            name = `@${new Variable(name.slice(1), this.getIndex(), this.fileInfo()).eval(context).value}`;\n        }\n\n        if (this.evaluating) {\n            throw { type: 'Name',\n                message: `Recursive variable definition for ${name}`,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n\n        this.evaluating = true;\n\n        variable = this.find(context.frames, frame => {\n            const v = frame.variable(name);\n            if (v) {\n                if (v.important) {\n                    const importantScope = context.importantScope[context.importantScope.length - 1];\n                    importantScope.important = v.important;\n                }\n                // If in calc, wrap vars in a function call to cascade evaluate args first\n                if (context.inCalc) {\n                    return (new Call('_SELF', [v.value])).eval(context);\n                }\n                else {\n                    return v.value.eval(context);\n                }\n            }\n        });\n        if (variable) {\n            this.evaluating = false;\n            return variable;\n        } else {\n            throw { type: 'Name',\n                message: `variable ${name} is undefined`,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n    }\n\n    find(obj, fun) {\n        for (let i = 0, r; i < obj.length; i++) {\n            r = fun.call(obj, obj[i]);\n            if (r) { return r; }\n        }\n        return null;\n    }\n}\n\nVariable.prototype.type = 'Variable';\nexport default Variable;\n","import Node from './node';\nimport Declaration from './declaration';\n\nclass Property extends Node {\n    constructor(name, index, currentFileInfo) {\n        super();\n\n        this.name = name;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n    }\n\n    eval(context) {\n        let property;\n        const name = this.name;\n        // TODO: shorten this reference\n        const mergeRules = context.pluginManager.less.visitors.ToCSSVisitor.prototype._mergeRules;\n\n        if (this.evaluating) {\n            throw { type: 'Name',\n                message: `Recursive property reference for ${name}`,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n\n        this.evaluating = true;\n\n        property = this.find(context.frames, frame => {\n            let v;\n            const vArr = frame.property(name);\n            if (vArr) {\n                for (let i = 0; i < vArr.length; i++) {\n                    v = vArr[i];\n\n                    vArr[i] = new Declaration(v.name,\n                        v.value,\n                        v.important,\n                        v.merge,\n                        v.index,\n                        v.currentFileInfo,\n                        v.inline,\n                        v.variable\n                    );\n                }\n                mergeRules(vArr);\n\n                v = vArr[vArr.length - 1];\n                if (v.important) {\n                    const importantScope = context.importantScope[context.importantScope.length - 1];\n                    importantScope.important = v.important;\n                }\n                v = v.value.eval(context);\n                return v;\n            }\n        });\n        if (property) {\n            this.evaluating = false;\n            return property;\n        } else {\n            throw { type: 'Name',\n                message: `Property '${name}' is undefined`,\n                filename: this.currentFileInfo.filename,\n                index: this.index };\n        }\n    }\n\n    find(obj, fun) {\n        for (let i = 0, r; i < obj.length; i++) {\n            r = fun.call(obj, obj[i]);\n            if (r) { return r; }\n        }\n        return null;\n    }\n}\n\nProperty.prototype.type = 'Property';\nexport default Property;\n","import Node from './node';\n\nclass Attribute extends Node {\n    constructor(key, op, value) {\n        super();\n\n        this.key = key;\n        this.op = op;\n        this.value = value;\n    }\n\n    eval(context) {\n        return new Attribute(this.key.eval ? this.key.eval(context) : this.key,\n            this.op, (this.value && this.value.eval) ? this.value.eval(context) : this.value);\n    }\n\n    genCSS(context, output) {\n        output.add(this.toCSS(context));\n    }\n\n    toCSS(context) {\n        let value = this.key.toCSS ? this.key.toCSS(context) : this.key;\n\n        if (this.op) {\n            value += this.op;\n            value += (this.value.toCSS ? this.value.toCSS(context) : this.value);\n        }\n\n        return `[${value}]`;\n    }\n}\n\nAttribute.prototype.type = 'Attribute';\nexport default Attribute;\n","import Node from './node';\nimport Variable from './variable';\nimport Property from './property';\n\n\nclass Quoted extends Node {\n    constructor(str, content, escaped, index, currentFileInfo) {\n        super();\n\n        this.escaped = (escaped == null) ? true : escaped;\n        this.value = content || '';\n        this.quote = str.charAt(0);\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.variableRegex = /@\\{([\\w-]+)\\}/g;\n        this.propRegex = /\\$\\{([\\w-]+)\\}/g;\n        this.allowRoot = escaped;\n    }\n\n    genCSS(context, output) {\n        if (!this.escaped) {\n            output.add(this.quote, this.fileInfo(), this.getIndex());\n        }\n        output.add(this.value);\n        if (!this.escaped) {\n            output.add(this.quote);\n        }\n    }\n\n    containsVariables() {\n        return this.value.match(this.variableRegex);\n    }\n\n    eval(context) {\n        const that = this;\n        let value = this.value;\n        const variableReplacement = (_, name) => {\n            const v = new Variable(`@${name}`, that.getIndex(), that.fileInfo()).eval(context, true);\n            return (v instanceof Quoted) ? v.value : v.toCSS();\n        };\n        const propertyReplacement = (_, name) => {\n            const v = new Property(`$${name}`, that.getIndex(), that.fileInfo()).eval(context, true);\n            return (v instanceof Quoted) ? v.value : v.toCSS();\n        };\n        function iterativeReplace(value, regexp, replacementFnc) {\n            let evaluatedValue = value;\n            do {\n                value = evaluatedValue.toString();\n                evaluatedValue = value.replace(regexp, replacementFnc);\n            } while (value !== evaluatedValue);\n            return evaluatedValue;\n        }\n        value = iterativeReplace(value, this.variableRegex, variableReplacement);\n        value = iterativeReplace(value, this.propRegex, propertyReplacement);\n\n        return new Quoted(this.quote + value + this.quote, value, this.escaped, this.getIndex(), this.fileInfo());\n    }\n\n    compare(other) {\n        // when comparing quoted strings allow the quote to differ\n        if (other.type === 'Quoted' && !this.escaped && !other.escaped) {\n            return Node.numericCompare(this.value, other.value);\n        } else {\n            return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;\n        }\n    }\n}\n\nQuoted.prototype.type = 'Quoted';\nexport default Quoted;\n","import Node from './node';\n\nclass URL extends Node {\n    constructor(val, index, currentFileInfo, isEvald) {\n        super();\n\n        this.value = val;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.isEvald = isEvald;\n    }\n\n    accept(visitor) {\n        this.value = visitor.visit(this.value);\n    }\n\n    genCSS(context, output) {\n        output.add('url(');\n        this.value.genCSS(context, output);\n        output.add(')');\n    }\n\n    eval(context) {\n        const val = this.value.eval(context);\n        let rootpath;\n\n        if (!this.isEvald) {\n            // Add the rootpath if the URL requires a rewrite\n            rootpath = this.fileInfo() && this.fileInfo().rootpath;\n            if (typeof rootpath === 'string' &&\n                typeof val.value === 'string' &&\n                context.pathRequiresRewrite(val.value)) {\n                if (!val.quote) {\n                    rootpath = escapePath(rootpath);\n                }\n                val.value = context.rewritePath(val.value, rootpath);\n            } else {\n                val.value = context.normalizePath(val.value);\n            }\n\n            // Add url args if enabled\n            if (context.urlArgs) {\n                if (!val.value.match(/^\\s*data:/)) {\n                    const delimiter = val.value.indexOf('?') === -1 ? '?' : '&';\n                    const urlArgs = delimiter + context.urlArgs;\n                    if (val.value.indexOf('#') !== -1) {\n                        val.value = val.value.replace('#', `${urlArgs}#`);\n                    } else {\n                        val.value += urlArgs;\n                    }\n                }\n            }\n        }\n\n        return new URL(val, this.getIndex(), this.fileInfo(), true);\n    }\n}\n\nURL.prototype.type = 'Url';\n\nfunction escapePath(path) {\n    return path.replace(/[\\(\\)'\"\\s]/g, match => `\\\\${match}`);\n}\n\nexport default URL;\n","import Ruleset from './ruleset';\nimport Value from './value';\nimport Selector from './selector';\nimport Anonymous from './anonymous';\nimport Expression from './expression';\nimport AtRule from './atrule';\nimport * as utils from '../utils';\n\nclass Media extends AtRule {\n    constructor(value, features, index, currentFileInfo, visibilityInfo) {\n        super();\n\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n\n        const selectors = (new Selector([], null, null, this._index, this._fileInfo)).createEmptySelectors();\n\n        this.features = new Value(features);\n        this.rules = [new Ruleset(selectors, value)];\n        this.rules[0].allowImports = true;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.allowRoot = true;\n        this.setParent(selectors, this);\n        this.setParent(this.features, this);\n        this.setParent(this.rules, this);\n    }\n\n    isRulesetLike() {\n        return true;\n    }\n\n    accept(visitor) {\n        if (this.features) {\n            this.features = visitor.visit(this.features);\n        }\n        if (this.rules) {\n            this.rules = visitor.visitArray(this.rules);\n        }\n    }\n\n    genCSS(context, output) {\n        output.add('@media ', this._fileInfo, this._index);\n        this.features.genCSS(context, output);\n        this.outputRuleset(context, output, this.rules);\n    }\n\n    eval(context) {\n        if (!context.mediaBlocks) {\n            context.mediaBlocks = [];\n            context.mediaPath = [];\n        }\n\n        const media = new Media(null, [], this._index, this._fileInfo, this.visibilityInfo());\n        if (this.debugInfo) {\n            this.rules[0].debugInfo = this.debugInfo;\n            media.debugInfo = this.debugInfo;\n        }\n        \n        media.features = this.features.eval(context);\n\n        context.mediaPath.push(media);\n        context.mediaBlocks.push(media);\n\n        this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();\n        context.frames.unshift(this.rules[0]);\n        media.rules = [this.rules[0].eval(context)];\n        context.frames.shift();\n\n        context.mediaPath.pop();\n\n        return context.mediaPath.length === 0 ? media.evalTop(context) :\n            media.evalNested(context);\n    }\n\n    evalTop(context) {\n        let result = this;\n\n        // Render all dependent Media blocks.\n        if (context.mediaBlocks.length > 1) {\n            const selectors = (new Selector([], null, null, this.getIndex(), this.fileInfo())).createEmptySelectors();\n            result = new Ruleset(selectors, context.mediaBlocks);\n            result.multiMedia = true;\n            result.copyVisibilityInfo(this.visibilityInfo());\n            this.setParent(result, this);\n        }\n\n        delete context.mediaBlocks;\n        delete context.mediaPath;\n\n        return result;\n    }\n\n    evalNested(context) {\n        let i;\n        let value;\n        const path = context.mediaPath.concat([this]);\n\n        // Extract the media-query conditions separated with `,` (OR).\n        for (i = 0; i < path.length; i++) {\n            value = path[i].features instanceof Value ?\n                path[i].features.value : path[i].features;\n            path[i] = Array.isArray(value) ? value : [value];\n        }\n\n        // Trace all permutations to generate the resulting media-query.\n        //\n        // (a, b and c) with nested (d, e) ->\n        //    a and d\n        //    a and e\n        //    b and c and d\n        //    b and c and e\n        this.features = new Value(this.permute(path).map(path => {\n            path = path.map(fragment => fragment.toCSS ? fragment : new Anonymous(fragment));\n\n            for (i = path.length - 1; i > 0; i--) {\n                path.splice(i, 0, new Anonymous('and'));\n            }\n\n            return new Expression(path);\n        }));\n        this.setParent(this.features, this);\n\n        // Fake a tree-node that doesn't output anything.\n        return new Ruleset([], []);\n    }\n\n    permute(arr) {\n        if (arr.length === 0) {\n            return [];\n        } else if (arr.length === 1) {\n            return arr[0];\n        } else {\n            const result = [];\n            const rest = this.permute(arr.slice(1));\n            for (let i = 0; i < rest.length; i++) {\n                for (let j = 0; j < arr[0].length; j++) {\n                    result.push([arr[0][j]].concat(rest[i]));\n                }\n            }\n            return result;\n        }\n    }\n\n    bubbleSelectors(selectors) {\n        if (!selectors) {\n            return;\n        }\n        this.rules = [new Ruleset(utils.copyArray(selectors), [this.rules[0]])];\n        this.setParent(this.rules, this);\n    }\n}\n\nMedia.prototype.type = 'Media';\nexport default Media;\n","import Node from './node';\nimport Media from './media';\nimport URL from './url';\nimport Quoted from './quoted';\nimport Ruleset from './ruleset';\nimport Anonymous from './anonymous';\nimport * as utils from '../utils';\nimport LessError from '../less-error';\n\n//\n// CSS @import node\n//\n// The general strategy here is that we don't want to wait\n// for the parsing to be completed, before we start importing\n// the file. That's because in the context of a browser,\n// most of the time will be spent waiting for the server to respond.\n//\n// On creation, we push the import path to our import queue, though\n// `import,push`, we also pass it a callback, which it'll call once\n// the file has been fetched, and parsed.\n//\nclass Import extends Node {\n    constructor(path, features, options, index, currentFileInfo, visibilityInfo) {\n        super();\n\n        this.options = options;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.path = path;\n        this.features = features;\n        this.allowRoot = true;\n\n        if (this.options.less !== undefined || this.options.inline) {\n            this.css = !this.options.less || this.options.inline;\n        } else {\n            const pathValue = this.getPath();\n            if (pathValue && /[#\\.\\&\\?]css([\\?;].*)?$/.test(pathValue)) {\n                this.css = true;\n            }\n        }\n        this.copyVisibilityInfo(visibilityInfo);\n        this.setParent(this.features, this);\n        this.setParent(this.path, this);\n    }\n\n    accept(visitor) {\n        if (this.features) {\n            this.features = visitor.visit(this.features);\n        }\n        this.path = visitor.visit(this.path);\n        if (!this.options.isPlugin && !this.options.inline && this.root) {\n            this.root = visitor.visit(this.root);\n        }\n    }\n\n    genCSS(context, output) {\n        if (this.css && this.path._fileInfo.reference === undefined) {\n            output.add('@import ', this._fileInfo, this._index);\n            this.path.genCSS(context, output);\n            if (this.features) {\n                output.add(' ');\n                this.features.genCSS(context, output);\n            }\n            output.add(';');\n        }\n    }\n\n    getPath() {\n        return (this.path instanceof URL) ?\n            this.path.value.value : this.path.value;\n    }\n\n    isVariableImport() {\n        let path = this.path;\n        if (path instanceof URL) {\n            path = path.value;\n        }\n        if (path instanceof Quoted) {\n            return path.containsVariables();\n        }\n\n        return true;\n    }\n\n    evalForImport(context) {\n        let path = this.path;\n\n        if (path instanceof URL) {\n            path = path.value;\n        }\n\n        return new Import(path.eval(context), this.features, this.options, this._index, this._fileInfo, this.visibilityInfo());\n    }\n\n    evalPath(context) {\n        const path = this.path.eval(context);\n        const fileInfo = this._fileInfo;\n\n        if (!(path instanceof URL)) {\n            // Add the rootpath if the URL requires a rewrite\n            const pathValue = path.value;\n            if (fileInfo &&\n                pathValue &&\n                context.pathRequiresRewrite(pathValue)) {\n                path.value = context.rewritePath(pathValue, fileInfo.rootpath);\n            } else {\n                path.value = context.normalizePath(path.value);\n            }\n        }\n\n        return path;\n    }\n\n    eval(context) {\n        const result = this.doEval(context);\n        if (this.options.reference || this.blocksVisibility()) {\n            if (result.length || result.length === 0) {\n                result.forEach(node => {\n                    node.addVisibilityBlock();\n                }\n                );\n            } else {\n                result.addVisibilityBlock();\n            }\n        }\n        return result;\n    }\n\n    doEval(context) {\n        let ruleset;\n        let registry;\n        const features = this.features && this.features.eval(context);\n\n        if (this.options.isPlugin) {\n            if (this.root && this.root.eval) {\n                try {\n                    this.root.eval(context);\n                }\n                catch (e) {\n                    e.message = 'Plugin error during evaluation';\n                    throw new LessError(e, this.root.imports, this.root.filename);\n                }\n            }\n            registry = context.frames[0] && context.frames[0].functionRegistry;\n            if ( registry && this.root && this.root.functions ) {\n                registry.addMultiple( this.root.functions );\n            }\n\n            return [];\n        }\n\n        if (this.skip) {\n            if (typeof this.skip === 'function') {\n                this.skip = this.skip();\n            }\n            if (this.skip) {\n                return [];\n            }\n        }\n        if (this.options.inline) {\n            const contents = new Anonymous(this.root, 0,\n                {\n                    filename: this.importedFilename,\n                    reference: this.path._fileInfo && this.path._fileInfo.reference\n                }, true, true);\n\n            return this.features ? new Media([contents], this.features.value) : [contents];\n        } else if (this.css) {\n            const newImport = new Import(this.evalPath(context), features, this.options, this._index);\n            if (!newImport.css && this.error) {\n                throw this.error;\n            }\n            return newImport;\n        } else {\n            ruleset = new Ruleset(null, utils.copyArray(this.root.rules));\n            ruleset.evalImports(context);\n\n            return this.features ? new Media(ruleset.rules, this.features.value) : ruleset.rules;\n        }\n    }\n}\n\nImport.prototype.type = 'Import';\nexport default Import;\n","import Node from './node';\nimport Variable from './variable';\n\nclass JsEvalNode extends Node {\n    evaluateJavaScript(expression, context) {\n        let result;\n        const that = this;\n        const evalContext = {};\n\n        if (!context.javascriptEnabled) {\n            throw { message: 'Inline JavaScript is not enabled. Is it set in your options?',\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n\n        expression = expression.replace(/@\\{([\\w-]+)\\}/g, (_, name) => that.jsify(new Variable(`@${name}`, that.getIndex(), that.fileInfo()).eval(context)));\n\n        try {\n            expression = new Function(`return (${expression})`);\n        } catch (e) {\n            throw { message: `JavaScript evaluation error: ${e.message} from \\`${expression}\\`` ,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n\n        const variables = context.frames[0].variables();\n        for (const k in variables) {\n            if (variables.hasOwnProperty(k)) {\n                /* jshint loopfunc:true */\n                evalContext[k.slice(1)] = {\n                    value: variables[k].value,\n                    toJS: function () {\n                        return this.value.eval(context).toCSS();\n                    }\n                };\n            }\n        }\n\n        try {\n            result = expression.call(evalContext);\n        } catch (e) {\n            throw { message: `JavaScript evaluation error: '${e.name}: ${e.message.replace(/[\"]/g, '\\'')}'` ,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n        return result;\n    }\n\n    jsify(obj) {\n        if (Array.isArray(obj.value) && (obj.value.length > 1)) {\n            return `[${obj.value.map(v => v.toCSS()).join(', ')}]`;\n        } else {\n            return obj.toCSS();\n        }\n    }\n}\n\nexport default JsEvalNode;\n","import JsEvalNode from './js-eval-node';\nimport Dimension from './dimension';\nimport Quoted from './quoted';\nimport Anonymous from './anonymous';\n\nclass JavaScript extends JsEvalNode {\n    constructor(string, escaped, index, currentFileInfo) {\n        super();\n\n        this.escaped = escaped;\n        this.expression = string;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n    }\n\n    eval(context) {\n        const result = this.evaluateJavaScript(this.expression, context);\n        const type = typeof result;\n\n        if (type === 'number' && !isNaN(result)) {\n            return new Dimension(result);\n        } else if (type === 'string') {\n            return new Quoted(`\"${result}\"`, result, this.escaped, this._index);\n        } else if (Array.isArray(result)) {\n            return new Anonymous(result.join(', '));\n        } else {\n            return new Anonymous(result);\n        }\n    }\n}\n\nJavaScript.prototype.type = 'JavaScript';\nexport default JavaScript;\n","import Node from './node';\n\nclass Assignment extends Node {\n    constructor(key, val) {\n        super();\n\n        this.key = key;\n        this.value = val;\n    }\n\n    accept(visitor) {\n        this.value = visitor.visit(this.value);\n    }\n\n    eval(context) {\n        if (this.value.eval) {\n            return new Assignment(this.key, this.value.eval(context));\n        }\n        return this;\n    }\n\n    genCSS(context, output) {\n        output.add(`${this.key}=`);\n        if (this.value.genCSS) {\n            this.value.genCSS(context, output);\n        } else {\n            output.add(this.value);\n        }\n    }\n}\n\nAssignment.prototype.type = 'Assignment';\nexport default Assignment;\n","import Node from './node';\n\nclass Condition extends Node {\n    constructor(op, l, r, i, negate) {\n        super();\n\n        this.op = op.trim();\n        this.lvalue = l;\n        this.rvalue = r;\n        this._index = i;\n        this.negate = negate;\n    }\n\n    accept(visitor) {\n        this.lvalue = visitor.visit(this.lvalue);\n        this.rvalue = visitor.visit(this.rvalue);\n    }\n\n    eval(context) {\n        const result = ((op, a, b) => {\n            switch (op) {\n                case 'and': return a && b;\n                case 'or':  return a || b;\n                default:\n                    switch (Node.compare(a, b)) {\n                        case -1:\n                            return op === '<' || op === '=<' || op === '<=';\n                        case 0:\n                            return op === '=' || op === '>=' || op === '=<' || op === '<=';\n                        case 1:\n                            return op === '>' || op === '>=';\n                        default:\n                            return false;\n                    }\n            }\n        })(this.op, this.lvalue.eval(context), this.rvalue.eval(context));\n\n        return this.negate ? !result : result;\n    }\n}\n\nCondition.prototype.type = 'Condition';\nexport default Condition;\n","import Node from './node';\n\nclass UnicodeDescriptor extends Node {\n    constructor(value) {\n        super();\n\n        this.value = value;\n    }\n}\n\nUnicodeDescriptor.prototype.type = 'UnicodeDescriptor';\n\nexport default UnicodeDescriptor;\n","import Node from './node';\nimport Operation from './operation';\nimport Dimension from './dimension';\n\nclass Negative extends Node {\n    constructor(node) {\n        super();\n\n        this.value = node;\n    }\n\n    genCSS(context, output) {\n        output.add('-');\n        this.value.genCSS(context, output);\n    }\n\n    eval(context) {\n        if (context.isMathOn()) {\n            return (new Operation('*', [new Dimension(-1), this.value])).eval(context);\n        }\n        return new Negative(this.value.eval(context));\n    }\n}\n\nNegative.prototype.type = 'Negative';\nexport default Negative;\n","import Node from './node';\nimport Selector from './selector';\n\nclass Extend extends Node {\n    constructor(selector, option, index, currentFileInfo, visibilityInfo) {\n        super();\n\n        this.selector = selector;\n        this.option = option;\n        this.object_id = Extend.next_id++;\n        this.parent_ids = [this.object_id];\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.allowRoot = true;\n\n        switch (option) {\n            case 'all':\n                this.allowBefore = true;\n                this.allowAfter = true;\n                break;\n            default:\n                this.allowBefore = false;\n                this.allowAfter = false;\n                break;\n        }\n        this.setParent(this.selector, this);\n    }\n\n    accept(visitor) {\n        this.selector = visitor.visit(this.selector);\n    }\n\n    eval(context) {\n        return new Extend(this.selector.eval(context), this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n    }\n\n    clone(context) {\n        return new Extend(this.selector, this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n    }\n\n    // it concatenates (joins) all selectors in selector array\n    findSelfSelectors(selectors) {\n        let selfElements = [];\n        let i;\n        let selectorElements;\n\n        for (i = 0; i < selectors.length; i++) {\n            selectorElements = selectors[i].elements;\n            // duplicate the logic in genCSS function inside the selector node.\n            // future TODO - move both logics into the selector joiner visitor\n            if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === '') {\n                selectorElements[0].combinator.value = ' ';\n            }\n            selfElements = selfElements.concat(selectors[i].elements);\n        }\n\n        this.selfSelectors = [new Selector(selfElements)];\n        this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());\n    }\n}\n\nExtend.next_id = 0;\n\nExtend.prototype.type = 'Extend';\nexport default Extend;\n","import Node from './node';\nimport Variable from './variable';\nimport Ruleset from './ruleset';\nimport DetachedRuleset from './detached-ruleset';\nimport LessError from '../less-error';\n\nclass VariableCall extends Node {\n    constructor(variable, index, currentFileInfo) {\n        super();\n\n        this.variable = variable;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.allowRoot = true;\n    }\n\n    eval(context) {\n        let rules;\n        let detachedRuleset = new Variable(this.variable, this.getIndex(), this.fileInfo()).eval(context);\n        const error = new LessError({message: `Could not evaluate variable call ${this.variable}`});\n\n        if (!detachedRuleset.ruleset) {\n            if (detachedRuleset.rules) {\n                rules = detachedRuleset;\n            }\n            else if (Array.isArray(detachedRuleset)) {\n                rules = new Ruleset('', detachedRuleset);\n            }\n            else if (Array.isArray(detachedRuleset.value)) {\n                rules = new Ruleset('', detachedRuleset.value);\n            }\n            else {\n                throw error;\n            }\n            detachedRuleset = new DetachedRuleset(rules);\n        }\n\n        if (detachedRuleset.ruleset) {\n            return detachedRuleset.callEval(context);\n        }\n        throw error;\n    }\n}\n\nVariableCall.prototype.type = 'VariableCall';\nexport default VariableCall;\n","import Node from './node';\nimport Variable from './variable';\nimport Ruleset from './ruleset';\nimport Selector from './selector';\n\nclass NamespaceValue extends Node {\n    constructor(ruleCall, lookups, index, fileInfo) {\n        super();\n\n        this.value = ruleCall;\n        this.lookups = lookups;\n        this._index = index;\n        this._fileInfo = fileInfo;\n    }\n\n    eval(context) {\n        let i;\n        let j;\n        let name;\n        let rules = this.value.eval(context);\n\n        for (i = 0; i < this.lookups.length; i++) {\n            name = this.lookups[i];\n\n            /**\n             * Eval'd DRs return rulesets.\n             * Eval'd mixins return rules, so let's make a ruleset if we need it.\n             * We need to do this because of late parsing of values\n             */\n            if (Array.isArray(rules)) {\n                rules = new Ruleset([new Selector()], rules);\n            }\n\n            if (name === '') {\n                rules = rules.lastDeclaration();\n            }\n            else if (name.charAt(0) === '@') {\n                if (name.charAt(1) === '@') {\n                    name = `@${new Variable(name.substr(1)).eval(context).value}`;\n                }\n                if (rules.variables) {\n                    rules = rules.variable(name);\n                }\n                \n                if (!rules) {\n                    throw { type: 'Name',\n                        message: `variable ${name} not found`,\n                        filename: this.fileInfo().filename,\n                        index: this.getIndex() };\n                }\n            }\n            else {\n                if (name.substring(0, 2) === '$@') {\n                    name = `$${new Variable(name.substr(1)).eval(context).value}`;\n                }\n                else {\n                    name = name.charAt(0) === '$' ? name : `$${name}`;\n                }\n                if (rules.properties) {\n                    rules = rules.property(name);\n                }\n            \n                if (!rules) {\n                    throw { type: 'Name',\n                        message: `property \"${name.substr(1)}\" not found`,\n                        filename: this.fileInfo().filename,\n                        index: this.getIndex() };\n                }\n                // Properties are an array of values, since a ruleset can have multiple props.\n                // We pick the last one (the \"cascaded\" value)\n                rules = rules[rules.length - 1];\n            }\n\n            if (rules.value) {\n                rules = rules.eval(context).value;\n            }\n            if (rules.ruleset) {\n                rules = rules.ruleset.eval(context);\n            }\n        }\n        return rules;\n    }\n}\n\nNamespaceValue.prototype.type = 'NamespaceValue';\nexport default NamespaceValue;\n","import Selector from './selector';\nimport Element from './element';\nimport Ruleset from './ruleset';\nimport Declaration from './declaration';\nimport DetachedRuleset from './detached-ruleset';\nimport Expression from './expression';\nimport contexts from '../contexts';\nimport * as utils from '../utils';\n\nclass Definition extends Ruleset {\n    constructor(name, params, rules, condition, variadic, frames, visibilityInfo) {\n        super();\n\n        this.name = name || 'anonymous mixin';\n        this.selectors = [new Selector([new Element(null, name, false, this._index, this._fileInfo)])];\n        this.params = params;\n        this.condition = condition;\n        this.variadic = variadic;\n        this.arity = params.length;\n        this.rules = rules;\n        this._lookups = {};\n        const optionalParameters = [];\n        this.required = params.reduce((count, p) => {\n            if (!p.name || (p.name && !p.value)) {\n                return count + 1;\n            }\n            else {\n                optionalParameters.push(p.name);\n                return count;\n            }\n        }, 0);\n        this.optionalParameters = optionalParameters;\n        this.frames = frames;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.allowRoot = true;\n    }\n\n    accept(visitor) {\n        if (this.params && this.params.length) {\n            this.params = visitor.visitArray(this.params);\n        }\n        this.rules = visitor.visitArray(this.rules);\n        if (this.condition) {\n            this.condition = visitor.visit(this.condition);\n        }\n    }\n\n    evalParams(context, mixinEnv, args, evaldArguments) {\n        /* jshint boss:true */\n        const frame = new Ruleset(null, null);\n\n        let varargs;\n        let arg;\n        const params = utils.copyArray(this.params);\n        let i;\n        let j;\n        let val;\n        let name;\n        let isNamedFound;\n        let argIndex;\n        let argsLength = 0;\n\n        if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {\n            frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();\n        }\n        mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames));\n\n        if (args) {\n            args = utils.copyArray(args);\n            argsLength = args.length;\n\n            for (i = 0; i < argsLength; i++) {\n                arg = args[i];\n                if (name = (arg && arg.name)) {\n                    isNamedFound = false;\n                    for (j = 0; j < params.length; j++) {\n                        if (!evaldArguments[j] && name === params[j].name) {\n                            evaldArguments[j] = arg.value.eval(context);\n                            frame.prependRule(new Declaration(name, arg.value.eval(context)));\n                            isNamedFound = true;\n                            break;\n                        }\n                    }\n                    if (isNamedFound) {\n                        args.splice(i, 1);\n                        i--;\n                        continue;\n                    } else {\n                        throw { type: 'Runtime', message: `Named argument for ${this.name} ${args[i].name} not found` };\n                    }\n                }\n            }\n        }\n        argIndex = 0;\n        for (i = 0; i < params.length; i++) {\n            if (evaldArguments[i]) { continue; }\n\n            arg = args && args[argIndex];\n\n            if (name = params[i].name) {\n                if (params[i].variadic) {\n                    varargs = [];\n                    for (j = argIndex; j < argsLength; j++) {\n                        varargs.push(args[j].value.eval(context));\n                    }\n                    frame.prependRule(new Declaration(name, new Expression(varargs).eval(context)));\n                } else {\n                    val = arg && arg.value;\n                    if (val) {\n                        // This was a mixin call, pass in a detached ruleset of it's eval'd rules\n                        if (Array.isArray(val)) {\n                            val = new DetachedRuleset(new Ruleset('', val));\n                        }\n                        else {\n                            val = val.eval(context);\n                        }\n                    } else if (params[i].value) {\n                        val = params[i].value.eval(mixinEnv);\n                        frame.resetCache();\n                    } else {\n                        throw { type: 'Runtime', message: `wrong number of arguments for ${this.name} (${argsLength} for ${this.arity})` };\n                    }\n\n                    frame.prependRule(new Declaration(name, val));\n                    evaldArguments[i] = val;\n                }\n            }\n\n            if (params[i].variadic && args) {\n                for (j = argIndex; j < argsLength; j++) {\n                    evaldArguments[j] = args[j].value.eval(context);\n                }\n            }\n            argIndex++;\n        }\n\n        return frame;\n    }\n\n    makeImportant() {\n        const rules = !this.rules ? this.rules : this.rules.map(r => {\n            if (r.makeImportant) {\n                return r.makeImportant(true);\n            } else {\n                return r;\n            }\n        });\n        const result = new Definition(this.name, this.params, rules, this.condition, this.variadic, this.frames);\n        return result;\n    }\n\n    eval(context) {\n        return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || utils.copyArray(context.frames));\n    }\n\n    evalCall(context, args, important) {\n        const _arguments = [];\n        const mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames;\n        const frame = this.evalParams(context, new contexts.Eval(context, mixinFrames), args, _arguments);\n        let rules;\n        let ruleset;\n\n        frame.prependRule(new Declaration('@arguments', new Expression(_arguments).eval(context)));\n\n        rules = utils.copyArray(this.rules);\n\n        ruleset = new Ruleset(null, rules);\n        ruleset.originalRuleset = this;\n        ruleset = ruleset.eval(new contexts.Eval(context, [this, frame].concat(mixinFrames)));\n        if (important) {\n            ruleset = ruleset.makeImportant();\n        }\n        return ruleset;\n    }\n\n    matchCondition(args, context) {\n        if (this.condition && !this.condition.eval(\n            new contexts.Eval(context,\n                [this.evalParams(context, /* the parameter variables */\n                    new contexts.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])]\n                    .concat(this.frames || []) // the parent namespace/mixin frames\n                    .concat(context.frames)))) { // the current environment frames\n            return false;\n        }\n        return true;\n    }\n\n    matchArgs(args, context) {\n        const allArgsCnt = (args && args.length) || 0;\n        let len;\n        const optionalParameters = this.optionalParameters;\n        const requiredArgsCnt = !args ? 0 : args.reduce((count, p) => {\n            if (optionalParameters.indexOf(p.name) < 0) {\n                return count + 1;\n            } else {\n                return count;\n            }\n        }, 0);\n\n        if (!this.variadic) {\n            if (requiredArgsCnt < this.required) {\n                return false;\n            }\n            if (allArgsCnt > this.params.length) {\n                return false;\n            }\n        } else {\n            if (requiredArgsCnt < (this.required - 1)) {\n                return false;\n            }\n        }\n\n        // check patterns\n        len = Math.min(requiredArgsCnt, this.arity);\n\n        for (let i = 0; i < len; i++) {\n            if (!this.params[i].name && !this.params[i].variadic) {\n                if (args[i].value.eval(context).toCSS() != this.params[i].value.eval(context).toCSS()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\nDefinition.prototype.type = 'MixinDefinition';\nDefinition.prototype.evalFirst = true;\nexport default Definition;\n","import Node from './node';\nimport Selector from './selector';\nimport MixinDefinition from './mixin-definition';\nimport defaultFunc from '../functions/default';\n\nclass MixinCall extends Node {\n    constructor(elements, args, index, currentFileInfo, important) {\n        super();\n\n        this.selector = new Selector(elements);\n        this.arguments = args || [];\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.important = important;\n        this.allowRoot = true;\n        this.setParent(this.selector, this);\n    }\n\n    accept(visitor) {\n        if (this.selector) {\n            this.selector = visitor.visit(this.selector);\n        }\n        if (this.arguments.length) {\n            this.arguments = visitor.visitArray(this.arguments);\n        }\n    }\n\n    eval(context) {\n        let mixins;\n        let mixin;\n        let mixinPath;\n        const args = [];\n        let arg;\n        let argValue;\n        const rules = [];\n        let match = false;\n        let i;\n        let m;\n        let f;\n        let isRecursive;\n        let isOneFound;\n        const candidates = [];\n        let candidate;\n        const conditionResult = [];\n        let defaultResult;\n        const defFalseEitherCase = -1;\n        const defNone = 0;\n        const defTrue = 1;\n        const defFalse = 2;\n        let count;\n        let originalRuleset;\n        let noArgumentsFilter;\n\n        this.selector = this.selector.eval(context);\n\n        function calcDefGroup(mixin, mixinPath) {\n            let f;\n            let p;\n            let namespace;\n\n            for (f = 0; f < 2; f++) {\n                conditionResult[f] = true;\n                defaultFunc.value(f);\n                for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {\n                    namespace = mixinPath[p];\n                    if (namespace.matchCondition) {\n                        conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);\n                    }\n                }\n                if (mixin.matchCondition) {\n                    conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);\n                }\n            }\n            if (conditionResult[0] || conditionResult[1]) {\n                if (conditionResult[0] != conditionResult[1]) {\n                    return conditionResult[1] ?\n                        defTrue : defFalse;\n                }\n\n                return defNone;\n            }\n            return defFalseEitherCase;\n        }\n\n        for (i = 0; i < this.arguments.length; i++) {\n            arg = this.arguments[i];\n            argValue = arg.value.eval(context);\n            if (arg.expand && Array.isArray(argValue.value)) {\n                argValue = argValue.value;\n                for (m = 0; m < argValue.length; m++) {\n                    args.push({value: argValue[m]});\n                }\n            } else {\n                args.push({name: arg.name, value: argValue});\n            }\n        }\n\n        noArgumentsFilter = rule => rule.matchArgs(null, context);\n\n        for (i = 0; i < context.frames.length; i++) {\n            if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {\n                isOneFound = true;\n\n                // To make `default()` function independent of definition order we have two \"subpasses\" here.\n                // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),\n                // and build candidate list with corresponding flags. Then, when we know all possible matches,\n                // we make a final decision.\n\n                for (m = 0; m < mixins.length; m++) {\n                    mixin = mixins[m].rule;\n                    mixinPath = mixins[m].path;\n                    isRecursive = false;\n                    for (f = 0; f < context.frames.length; f++) {\n                        if ((!(mixin instanceof MixinDefinition)) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {\n                            isRecursive = true;\n                            break;\n                        }\n                    }\n                    if (isRecursive) {\n                        continue;\n                    }\n\n                    if (mixin.matchArgs(args, context)) {\n                        candidate = {mixin, group: calcDefGroup(mixin, mixinPath)};\n\n                        if (candidate.group !== defFalseEitherCase) {\n                            candidates.push(candidate);\n                        }\n\n                        match = true;\n                    }\n                }\n\n                defaultFunc.reset();\n\n                count = [0, 0, 0];\n                for (m = 0; m < candidates.length; m++) {\n                    count[candidates[m].group]++;\n                }\n\n                if (count[defNone] > 0) {\n                    defaultResult = defFalse;\n                } else {\n                    defaultResult = defTrue;\n                    if ((count[defTrue] + count[defFalse]) > 1) {\n                        throw { type: 'Runtime',\n                            message: `Ambiguous use of \\`default()\\` found when matching for \\`${this.format(args)}\\``,\n                            index: this.getIndex(), filename: this.fileInfo().filename };\n                    }\n                }\n\n                for (m = 0; m < candidates.length; m++) {\n                    candidate = candidates[m].group;\n                    if ((candidate === defNone) || (candidate === defaultResult)) {\n                        try {\n                            mixin = candidates[m].mixin;\n                            if (!(mixin instanceof MixinDefinition)) {\n                                originalRuleset = mixin.originalRuleset || mixin;\n                                mixin = new MixinDefinition('', [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());\n                                mixin.originalRuleset = originalRuleset;\n                            }\n                            const newRules = mixin.evalCall(context, args, this.important).rules;\n                            this._setVisibilityToReplacement(newRules);\n                            Array.prototype.push.apply(rules, newRules);\n                        } catch (e) {\n                            throw { message: e.message, index: this.getIndex(), filename: this.fileInfo().filename, stack: e.stack };\n                        }\n                    }\n                }\n\n                if (match) {\n                    return rules;\n                }\n            }\n        }\n        if (isOneFound) {\n            throw { type:    'Runtime',\n                message: `No matching definition was found for \\`${this.format(args)}\\``,\n                index:   this.getIndex(), filename: this.fileInfo().filename };\n        } else {\n            throw { type:    'Name',\n                message: `${this.selector.toCSS().trim()} is undefined`,\n                index:   this.getIndex(), filename: this.fileInfo().filename };\n        }\n    }\n\n    _setVisibilityToReplacement(replacement) {\n        let i;\n        let rule;\n        if (this.blocksVisibility()) {\n            for (i = 0; i < replacement.length; i++) {\n                rule = replacement[i];\n                rule.addVisibilityBlock();\n            }\n        }\n    }\n\n    format(args) {\n        return `${this.selector.toCSS().trim()}(${args ? args.map(a => {\n            let argValue = '';\n            if (a.name) {\n                argValue += `${a.name}:`;\n            }\n            if (a.value.toCSS) {\n                argValue += a.value.toCSS();\n            } else {\n                argValue += '???';\n            }\n            return argValue;\n        }).join(', ') : ''})`;\n    }\n}\n\nMixinCall.prototype.type = 'MixinCall';\nexport default MixinCall;\n","const tree = Object.create(null);\n\nimport Node from './node';\nimport Color from './color';\nimport AtRule from './atrule';\nimport DetachedRuleset from './detached-ruleset';\nimport Operation from './operation';\nimport Dimension from './dimension';\nimport Unit from './unit';\nimport Keyword from './keyword';\nimport Variable from './variable';\nimport Property from './property';\nimport Ruleset from './ruleset';\nimport Element from './element';\nimport Attribute from './attribute';\nimport Combinator from './combinator';\nimport Selector from './selector';\nimport Quoted from './quoted';\nimport Expression from './expression';\nimport Declaration from './declaration';\nimport Call from './call';\nimport URL from './url';\nimport Import from './import';\nimport Comment from './comment';\nimport Anonymous from './anonymous';\nimport Value from './value';\nimport JavaScript from './javascript';\nimport Assignment from './assignment';\nimport Condition from './condition';\nimport Paren from './paren';\nimport Media from './media';\nimport UnicodeDescriptor from './unicode-descriptor';\nimport Negative from './negative';\nimport Extend from './extend';\nimport VariableCall from './variable-call';\nimport NamespaceValue from './namespace-value';\n\n// mixins\nimport MixinCall from './mixin-call';\nimport MixinDefinition from './mixin-definition';\n\nexport default {\n    Node, Color, AtRule, DetachedRuleset, Operation,\n    Dimension, Unit, Keyword, Variable, Property,\n    Ruleset, Element, Attribute, Combinator, Selector,\n    Quoted, Expression, Declaration, Call, URL, Import,\n    Comment, Anonymous, Value, JavaScript, Assignment,\n    Condition, Paren, Media, UnicodeDescriptor, Negative,\n    Extend, VariableCall, NamespaceValue,\n    mixin: {\n        Call: MixinCall,\n        Definition: MixinDefinition\n    }\n};","export default {\n    error: function(msg) {\n        this._fireEvent('error', msg);\n    },\n    warn: function(msg) {\n        this._fireEvent('warn', msg);\n    },\n    info: function(msg) {\n        this._fireEvent('info', msg);\n    },\n    debug: function(msg) {\n        this._fireEvent('debug', msg);\n    },\n    addListener: function(listener) {\n        this._listeners.push(listener);\n    },\n    removeListener: function(listener) {\n        for (let i = 0; i < this._listeners.length; i++) {\n            if (this._listeners[i] === listener) {\n                this._listeners.splice(i, 1);\n                return;\n            }\n        }\n    },\n    _fireEvent: function(type, msg) {\n        for (let i = 0; i < this._listeners.length; i++) {\n            const logFunction = this._listeners[i][type];\n            if (logFunction) {\n                logFunction(msg);\n            }\n        }\n    },\n    _listeners: []\n};\n","/**\n * @todo Document why this abstraction exists, and the relationship between\n *       environment, file managers, and plugin manager\n */\n\nimport logger from '../logger';\n\nclass environment {\n    constructor(externalEnvironment, fileManagers) {\n        this.fileManagers = fileManagers || [];\n        externalEnvironment = externalEnvironment || {};\n\n        const optionalFunctions = ['encodeBase64', 'mimeLookup', 'charsetLookup', 'getSourceMapGenerator'];\n        const requiredFunctions = [];\n        const functions = requiredFunctions.concat(optionalFunctions);\n\n        for (let i = 0; i < functions.length; i++) {\n            const propName = functions[i];\n            const environmentFunc = externalEnvironment[propName];\n            if (environmentFunc) {\n                this[propName] = environmentFunc.bind(externalEnvironment);\n            } else if (i < requiredFunctions.length) {\n                this.warn(`missing required function in environment - ${propName}`);\n            }\n        }\n    }\n\n    getFileManager(filename, currentDirectory, options, environment, isSync) {\n\n        if (!filename) {\n            logger.warn('getFileManager called with no filename.. Please report this issue. continuing.');\n        }\n        if (currentDirectory == null) {\n            logger.warn('getFileManager called with null directory.. Please report this issue. continuing.');\n        }\n\n        let fileManagers = this.fileManagers;\n        if (options.pluginManager) {\n            fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());\n        }\n        for (let i = fileManagers.length - 1; i >= 0 ; i--) {\n            const fileManager = fileManagers[i];\n            if (fileManager[isSync ? 'supportsSync' : 'supports'](filename, currentDirectory, options, environment)) {\n                return fileManager;\n            }\n        }\n        return null;\n    }\n\n    addFileManager(fileManager) {\n        this.fileManagers.push(fileManager);\n    }\n\n    clearFileManagers() {\n        this.fileManagers = [];\n    }\n}\n\nexport default environment;\n","class AbstractFileManager {\n    getPath(filename) {\n        let j = filename.lastIndexOf('?');\n        if (j > 0) {\n            filename = filename.slice(0, j);\n        }\n        j = filename.lastIndexOf('/');\n        if (j < 0) {\n            j = filename.lastIndexOf('\\\\');\n        }\n        if (j < 0) {\n            return '';\n        }\n        return filename.slice(0, j + 1);\n    }\n\n    tryAppendExtension(path, ext) {\n        return /(\\.[a-z]*$)|([\\?;].*)$/.test(path) ? path : path + ext;\n    }\n\n    tryAppendLessExtension(path) {\n        return this.tryAppendExtension(path, '.less');\n    };\n\n    supportsSync() { return false; }\n\n    alwaysMakePathsAbsolute() { return false; }\n\n    isPathAbsolute(filename) {\n        return (/^(?:[a-z-]+:|\\/|\\\\|#)/i).test(filename);\n    }\n    // TODO: pull out / replace?\n    join(basePath, laterPath) {\n        if (!basePath) {\n            return laterPath;\n        }\n        return basePath + laterPath;\n    };\n\n    pathDiff(url, baseUrl) {\n        // diff between two paths to create a relative path\n        const urlParts = this.extractUrlParts(url);\n        const baseUrlParts = this.extractUrlParts(baseUrl);\n\n        let i;\n        let max;\n        let urlDirectories;\n        let baseUrlDirectories;\n        let diff = '';\n        if (urlParts.hostPart !== baseUrlParts.hostPart) {\n            return '';\n        }\n        max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);\n        for (i = 0; i < max; i++) {\n            if (baseUrlParts.directories[i] !== urlParts.directories[i]) { break; }\n        }\n        baseUrlDirectories = baseUrlParts.directories.slice(i);\n        urlDirectories = urlParts.directories.slice(i);\n        for (i = 0; i < baseUrlDirectories.length - 1; i++) {\n            diff += '../';\n        }\n        for (i = 0; i < urlDirectories.length - 1; i++) {\n            diff += `${urlDirectories[i]}/`;\n        }\n        return diff;\n    };\n    // helper function, not part of API\n    extractUrlParts(url, baseUrl) {\n        // urlParts[1] = protocol://hostname/ OR /\n        // urlParts[2] = / if path relative to host base\n        // urlParts[3] = directories\n        // urlParts[4] = filename\n        // urlParts[5] = parameters\n\n        const urlPartsRegex = /^((?:[a-z-]+:)?\\/{2}(?:[^\\/\\?#]*\\/)|([\\/\\\\]))?((?:[^\\/\\\\\\?#]*[\\/\\\\])*)([^\\/\\\\\\?#]*)([#\\?].*)?$/i;\n\n        const urlParts = url.match(urlPartsRegex);\n        const returner = {};\n        let rawDirectories = [];\n        const directories = [];\n        let i;\n        let baseUrlParts;\n\n        if (!urlParts) {\n            throw new Error(`Could not parse sheet href - '${url}'`);\n        }\n\n        // Stylesheets in IE don't always return the full path\n        if (baseUrl && (!urlParts[1] || urlParts[2])) {\n            baseUrlParts = baseUrl.match(urlPartsRegex);\n            if (!baseUrlParts) {\n                throw new Error(`Could not parse page url - '${baseUrl}'`);\n            }\n            urlParts[1] = urlParts[1] || baseUrlParts[1] || '';\n            if (!urlParts[2]) {\n                urlParts[3] = baseUrlParts[3] + urlParts[3];\n            }\n        }\n\n        if (urlParts[3]) {\n            rawDirectories = urlParts[3].replace(/\\\\/g, '/').split('/');\n\n            // collapse '..' and skip '.'\n            for (i = 0; i < rawDirectories.length; i++) {\n\n                if (rawDirectories[i] === '..') {\n                    directories.pop();\n                }\n                else if (rawDirectories[i] !== '.') {\n                    directories.push(rawDirectories[i]);\n                }\n            \n            }\n        }\n\n        returner.hostPart = urlParts[1];\n        returner.directories = directories;\n        returner.rawPath = (urlParts[1] || '') + rawDirectories.join('/');\n        returner.path = (urlParts[1] || '') + directories.join('/');\n        returner.filename = urlParts[4];\n        returner.fileUrl = returner.path + (urlParts[4] || '');\n        returner.url = returner.fileUrl + (urlParts[5] || '');\n        return returner;\n    };\n}\n\nexport default AbstractFileManager;\n","import functionRegistry from '../functions/function-registry';\nimport LessError from '../less-error';\n\nclass AbstractPluginLoader {\n    constructor() {\n        // Implemented by Node.js plugin loader\n        this.require = () => null\n    }\n\n    evalPlugin(contents, context, imports, pluginOptions, fileInfo) {\n        let loader;\n        let registry;\n        let pluginObj;\n        let localModule;\n        let pluginManager;\n        let filename;\n        let result;\n\n        pluginManager = context.pluginManager;\n\n        if (fileInfo) {\n            if (typeof fileInfo === 'string') {\n                filename = fileInfo;\n            }\n            else {\n                filename = fileInfo.filename;\n            }\n        }\n        const shortname = (new this.less.FileManager()).extractUrlParts(filename).filename;\n\n        if (filename) {\n            pluginObj = pluginManager.get(filename);\n\n            if (pluginObj) {\n                result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n                if (result) {\n                    return result;\n                }\n                try {\n                    if (pluginObj.use) {\n                        pluginObj.use.call(this.context, pluginObj);\n                    }\n                }\n                catch (e) {\n                    e.message = e.message || 'Error during @plugin call';\n                    return new LessError(e, imports, filename);\n                }\n                return pluginObj;\n            }\n        }\n        localModule = {\n            exports: {},\n            pluginManager,\n            fileInfo\n        };\n        registry = functionRegistry.create();\n\n        const registerPlugin = obj => {\n            pluginObj = obj;\n        };\n\n        try {\n            loader = new Function('module', 'require', 'registerPlugin', 'functions', 'tree', 'less', 'fileInfo', contents);\n            loader(localModule, this.require(filename), registerPlugin, registry, this.less.tree, this.less, fileInfo);\n        }\n        catch (e) {\n            return new LessError(e, imports, filename);\n        }\n\n        if (!pluginObj) {\n            pluginObj = localModule.exports;\n        }\n        pluginObj = this.validatePlugin(pluginObj, filename, shortname);\n\n        if (pluginObj instanceof LessError) {\n            return pluginObj;\n        }\n\n        if (pluginObj) {\n            pluginObj.imports = imports;\n            pluginObj.filename = filename;\n\n            // For < 3.x (or unspecified minVersion) - setOptions() before install()\n            if (!pluginObj.minVersion || this.compareVersion('3.0.0', pluginObj.minVersion) < 0) {\n                result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n\n                if (result) {\n                    return result;\n                }\n            }\n\n            // Run on first load\n            pluginManager.addPlugin(pluginObj, fileInfo.filename, registry);\n            pluginObj.functions = registry.getLocalFunctions();\n\n            // Need to call setOptions again because the pluginObj might have functions\n            result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n            if (result) {\n                return result;\n            }\n\n            // Run every @plugin call\n            try {\n                if (pluginObj.use) {\n                    pluginObj.use.call(this.context, pluginObj);\n                }\n            }\n            catch (e) {\n                e.message = e.message || 'Error during @plugin call';\n                return new LessError(e, imports, filename);\n            }\n\n        }\n        else {\n            return new LessError({ message: 'Not a valid plugin' }, imports, filename);\n        }\n\n        return pluginObj;\n    }\n\n    trySetOptions(plugin, filename, name, options) {\n        if (options && !plugin.setOptions) {\n            return new LessError({\n                message: `Options have been provided but the plugin ${name} does not support any options.`\n            });\n        }\n        try {\n            plugin.setOptions && plugin.setOptions(options);\n        }\n        catch (e) {\n            return new LessError(e);\n        }\n    }\n\n    validatePlugin(plugin, filename, name) {\n        if (plugin) {\n            // support plugins being a function\n            // so that the plugin can be more usable programmatically\n            if (typeof plugin === 'function') {\n                plugin = new plugin();\n            }\n\n            if (plugin.minVersion) {\n                if (this.compareVersion(plugin.minVersion, this.less.version) < 0) {\n                    return new LessError({\n                        message: `Plugin ${name} requires version ${this.versionToString(plugin.minVersion)}`\n                    });\n                }\n            }\n            return plugin;\n        }\n        return null;\n    }\n\n    compareVersion(aVersion, bVersion) {\n        if (typeof aVersion === 'string') {\n            aVersion = aVersion.match(/^(\\d+)\\.?(\\d+)?\\.?(\\d+)?/);\n            aVersion.shift();\n        }\n        for (let i = 0; i < aVersion.length; i++) {\n            if (aVersion[i] !== bVersion[i]) {\n                return parseInt(aVersion[i]) > parseInt(bVersion[i]) ? -1 : 1;\n            }\n        }\n        return 0;\n    }\n\n    versionToString(version) {\n        let versionString = '';\n        for (let i = 0; i < version.length; i++) {\n            versionString += (versionString ? '.' : '') + version[i];\n        }\n        return versionString;\n    }\n\n    printUsage(plugins) {\n        for (let i = 0; i < plugins.length; i++) {\n            const plugin = plugins[i];\n            if (plugin.printUsage) {\n                plugin.printUsage();\n            }\n        }\n    }\n}\n\nexport default AbstractPluginLoader;\n\n","import tree from '../tree';\nconst _visitArgs = { visitDeeper: true };\nlet _hasIndexed = false;\n\nfunction _noop(node) {\n    return node;\n}\n\nfunction indexNodeTypes(parent, ticker) {\n    // add .typeIndex to tree node types for lookup table\n    let key;\n\n    let child;\n    for (key in parent) { \n        /* eslint guard-for-in: 0 */\n        child = parent[key];\n        switch (typeof child) {\n            case 'function':\n                // ignore bound functions directly on tree which do not have a prototype\n                // or aren't nodes\n                if (child.prototype && child.prototype.type) {\n                    child.prototype.typeIndex = ticker++;\n                }\n                break;\n            case 'object':\n                ticker = indexNodeTypes(child, ticker);\n                break;\n        \n        }\n    }\n    return ticker;\n}\n\nclass Visitor {\n    constructor(implementation) {\n        this._implementation = implementation;\n        this._visitInCache = {};\n        this._visitOutCache = {};\n\n        if (!_hasIndexed) {\n            indexNodeTypes(tree, 1);\n            _hasIndexed = true;\n        }\n    }\n\n    visit(node) {\n        if (!node) {\n            return node;\n        }\n\n        const nodeTypeIndex = node.typeIndex;\n        if (!nodeTypeIndex) {\n            // MixinCall args aren't a node type?\n            if (node.value && node.value.typeIndex) {\n                this.visit(node.value);\n            }\n            return node;\n        }\n\n        const impl = this._implementation;\n        let func = this._visitInCache[nodeTypeIndex];\n        let funcOut = this._visitOutCache[nodeTypeIndex];\n        const visitArgs = _visitArgs;\n        let fnName;\n\n        visitArgs.visitDeeper = true;\n\n        if (!func) {\n            fnName = `visit${node.type}`;\n            func = impl[fnName] || _noop;\n            funcOut = impl[`${fnName}Out`] || _noop;\n            this._visitInCache[nodeTypeIndex] = func;\n            this._visitOutCache[nodeTypeIndex] = funcOut;\n        }\n\n        if (func !== _noop) {\n            const newNode = func.call(impl, node, visitArgs);\n            if (node && impl.isReplacing) {\n                node = newNode;\n            }\n        }\n\n        if (visitArgs.visitDeeper && node && node.accept) {\n            node.accept(this);\n        }\n\n        if (funcOut != _noop) {\n            funcOut.call(impl, node);\n        }\n\n        return node;\n    }\n\n    visitArray(nodes, nonReplacing) {\n        if (!nodes) {\n            return nodes;\n        }\n\n        const cnt = nodes.length;\n        let i;\n\n        // Non-replacing\n        if (nonReplacing || !this._implementation.isReplacing) {\n            for (i = 0; i < cnt; i++) {\n                this.visit(nodes[i]);\n            }\n            return nodes;\n        }\n\n        // Replacing\n        const out = [];\n        for (i = 0; i < cnt; i++) {\n            const evald = this.visit(nodes[i]);\n            if (evald === undefined) { continue; }\n            if (!evald.splice) {\n                out.push(evald);\n            } else if (evald.length) {\n                this.flatten(evald, out);\n            }\n        }\n        return out;\n    }\n\n    flatten(arr, out) {\n        if (!out) {\n            out = [];\n        }\n\n        let cnt;\n        let i;\n        let item;\n        let nestedCnt;\n        let j;\n        let nestedItem;\n\n        for (i = 0, cnt = arr.length; i < cnt; i++) {\n            item = arr[i];\n            if (item === undefined) {\n                continue;\n            }\n            if (!item.splice) {\n                out.push(item);\n                continue;\n            }\n\n            for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {\n                nestedItem = item[j];\n                if (nestedItem === undefined) {\n                    continue;\n                }\n                if (!nestedItem.splice) {\n                    out.push(nestedItem);\n                } else if (nestedItem.length) {\n                    this.flatten(nestedItem, out);\n                }\n            }\n        }\n\n        return out;\n    }\n}\n\nexport default Visitor;\n","class ImportSequencer {\n    constructor(onSequencerEmpty) {\n        this.imports = [];\n        this.variableImports = [];\n        this._onSequencerEmpty = onSequencerEmpty;\n        this._currentDepth = 0;\n    }\n\n    addImport(callback) {\n        const importSequencer = this;\n\n        const importItem = {\n            callback,\n            args: null,\n            isReady: false\n        };\n\n        this.imports.push(importItem);\n        return function(...args) {\n            importItem.args = Array.prototype.slice.call(args, 0);\n            importItem.isReady = true;\n            importSequencer.tryRun();\n        };\n    }\n\n    addVariableImport(callback) {\n        this.variableImports.push(callback);\n    }\n\n    tryRun() {\n        this._currentDepth++;\n        try {\n            while (true) {\n                while (this.imports.length > 0) {\n                    const importItem = this.imports[0];\n                    if (!importItem.isReady) {\n                        return;\n                    }\n                    this.imports = this.imports.slice(1);\n                    importItem.callback.apply(null, importItem.args);\n                }\n                if (this.variableImports.length === 0) {\n                    break;\n                }\n                const variableImport = this.variableImports[0];\n                this.variableImports = this.variableImports.slice(1);\n                variableImport();\n            }\n        } finally {\n            this._currentDepth--;\n        }\n        if (this._currentDepth === 0 && this._onSequencerEmpty) {\n            this._onSequencerEmpty();\n        }\n    }\n}\n\nexport default ImportSequencer;\n","import contexts from '../contexts';\nimport Visitor from './visitor';\nimport ImportSequencer from './import-sequencer';\nimport * as utils from '../utils';\n\nconst ImportVisitor = function(importer, finish) {\n\n    this._visitor = new Visitor(this);\n    this._importer = importer;\n    this._finish = finish;\n    this.context = new contexts.Eval();\n    this.importCount = 0;\n    this.onceFileDetectionMap = {};\n    this.recursionDetector = {};\n    this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this));\n};\n\nImportVisitor.prototype = {\n    isReplacing: false,\n    run: function (root) {\n        try {\n            // process the contents\n            this._visitor.visit(root);\n        }\n        catch (e) {\n            this.error = e;\n        }\n\n        this.isFinished = true;\n        this._sequencer.tryRun();\n    },\n    _onSequencerEmpty: function() {\n        if (!this.isFinished) {\n            return;\n        }\n        this._finish(this.error);\n    },\n    visitImport: function (importNode, visitArgs) {\n        const inlineCSS = importNode.options.inline;\n\n        if (!importNode.css || inlineCSS) {\n\n            const context = new contexts.Eval(this.context, utils.copyArray(this.context.frames));\n            const importParent = context.frames[0];\n\n            this.importCount++;\n            if (importNode.isVariableImport()) {\n                this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));\n            } else {\n                this.processImportNode(importNode, context, importParent);\n            }\n        }\n        visitArgs.visitDeeper = false;\n    },\n    processImportNode: function(importNode, context, importParent) {\n        let evaldImportNode;\n        const inlineCSS = importNode.options.inline;\n\n        try {\n            evaldImportNode = importNode.evalForImport(context);\n        } catch (e) {\n            if (!e.filename) { e.index = importNode.getIndex(); e.filename = importNode.fileInfo().filename; }\n            // attempt to eval properly and treat as css\n            importNode.css = true;\n            // if that fails, this error will be thrown\n            importNode.error = e;\n        }\n\n        if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {\n            if (evaldImportNode.options.multiple) {\n                context.importMultiple = true;\n            }\n\n            // try appending if we haven't determined if it is css or not\n            const tryAppendLessExtension = evaldImportNode.css === undefined;\n\n            for (let i = 0; i < importParent.rules.length; i++) {\n                if (importParent.rules[i] === importNode) {\n                    importParent.rules[i] = evaldImportNode;\n                    break;\n                }\n            }\n\n            const onImported = this.onImported.bind(this, evaldImportNode, context);\n            const sequencedOnImported = this._sequencer.addImport(onImported);\n\n            this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.fileInfo(),\n                evaldImportNode.options, sequencedOnImported);\n        } else {\n            this.importCount--;\n            if (this.isFinished) {\n                this._sequencer.tryRun();\n            }\n        }\n    },\n    onImported: function (importNode, context, e, root, importedAtRoot, fullPath) {\n        if (e) {\n            if (!e.filename) {\n                e.index = importNode.getIndex(); e.filename = importNode.fileInfo().filename;\n            }\n            this.error = e;\n        }\n\n        const importVisitor = this;\n        const inlineCSS = importNode.options.inline;\n        const isPlugin = importNode.options.isPlugin;\n        const isOptional = importNode.options.optional;\n        const duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;\n\n        if (!context.importMultiple) {\n            if (duplicateImport) {\n                importNode.skip = true;\n            } else {\n                importNode.skip = () => {\n                    if (fullPath in importVisitor.onceFileDetectionMap) {\n                        return true;\n                    }\n                    importVisitor.onceFileDetectionMap[fullPath] = true;\n                    return false;\n                };\n            }\n        }\n\n        if (!fullPath && isOptional) {\n            importNode.skip = true;\n        }\n\n        if (root) {\n            importNode.root = root;\n            importNode.importedFilename = fullPath;\n\n            if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {\n                importVisitor.recursionDetector[fullPath] = true;\n\n                const oldContext = this.context;\n                this.context = context;\n                try {\n                    this._visitor.visit(root);\n                } catch (e) {\n                    this.error = e;\n                }\n                this.context = oldContext;\n            }\n        }\n\n        importVisitor.importCount--;\n\n        if (importVisitor.isFinished) {\n            importVisitor._sequencer.tryRun();\n        }\n    },\n    visitDeclaration: function (declNode, visitArgs) {\n        if (declNode.value.type === 'DetachedRuleset') {\n            this.context.frames.unshift(declNode);\n        } else {\n            visitArgs.visitDeeper = false;\n        }\n    },\n    visitDeclarationOut: function(declNode) {\n        if (declNode.value.type === 'DetachedRuleset') {\n            this.context.frames.shift();\n        }\n    },\n    visitAtRule: function (atRuleNode, visitArgs) {\n        this.context.frames.unshift(atRuleNode);\n    },\n    visitAtRuleOut: function (atRuleNode) {\n        this.context.frames.shift();\n    },\n    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n        this.context.frames.unshift(mixinDefinitionNode);\n    },\n    visitMixinDefinitionOut: function (mixinDefinitionNode) {\n        this.context.frames.shift();\n    },\n    visitRuleset: function (rulesetNode, visitArgs) {\n        this.context.frames.unshift(rulesetNode);\n    },\n    visitRulesetOut: function (rulesetNode) {\n        this.context.frames.shift();\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        this.context.frames.unshift(mediaNode.rules[0]);\n    },\n    visitMediaOut: function (mediaNode) {\n        this.context.frames.shift();\n    }\n};\nexport default ImportVisitor;\n","class SetTreeVisibilityVisitor {\n    constructor(visible) {\n        this.visible = visible;\n    }\n\n    run(root) {\n        this.visit(root);\n    }\n\n    visitArray(nodes) {\n        if (!nodes) {\n            return nodes;\n        }\n\n        const cnt = nodes.length;\n        let i;\n        for (i = 0; i < cnt; i++) {\n            this.visit(nodes[i]);\n        }\n        return nodes;\n    }\n\n    visit(node) {\n        if (!node) {\n            return node;\n        }\n        if (node.constructor === Array) {\n            return this.visitArray(node);\n        }\n\n        if (!node.blocksVisibility || node.blocksVisibility()) {\n            return node;\n        }\n        if (this.visible) {\n            node.ensureVisibility();\n        } else {\n            node.ensureInvisibility();\n        }\n\n        node.accept(this);\n        return node;\n    }\n}\n\nexport default SetTreeVisibilityVisitor;","import tree from '../tree';\nimport Visitor from './visitor';\nimport logger from '../logger';\nimport * as utils from '../utils';\n\n/* jshint loopfunc:true */\n\nclass ExtendFinderVisitor {\n    constructor() {\n        this._visitor = new Visitor(this);\n        this.contexts = [];\n        this.allExtendsStack = [[]];\n    }\n\n    run(root) {\n        root = this._visitor.visit(root);\n        root.allExtends = this.allExtendsStack[0];\n        return root;\n    }\n\n    visitDeclaration(declNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    }\n\n    visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    }\n\n    visitRuleset(rulesetNode, visitArgs) {\n        if (rulesetNode.root) {\n            return;\n        }\n\n        let i;\n        let j;\n        let extend;\n        const allSelectorsExtendList = [];\n        let extendList;\n\n        // get &:extend(.a); rules which apply to all selectors in this ruleset\n        const rules = rulesetNode.rules;\n\n        const ruleCnt = rules ? rules.length : 0;\n        for (i = 0; i < ruleCnt; i++) {\n            if (rulesetNode.rules[i] instanceof tree.Extend) {\n                allSelectorsExtendList.push(rules[i]);\n                rulesetNode.extendOnEveryPath = true;\n            }\n        }\n\n        // now find every selector and apply the extends that apply to all extends\n        // and the ones which apply to an individual extend\n        const paths = rulesetNode.paths;\n        for (i = 0; i < paths.length; i++) {\n            const selectorPath = paths[i];\n            const selector = selectorPath[selectorPath.length - 1];\n            const selExtendList = selector.extendList;\n\n            extendList = selExtendList ? utils.copyArray(selExtendList).concat(allSelectorsExtendList)\n                : allSelectorsExtendList;\n\n            if (extendList) {\n                extendList = extendList.map(allSelectorsExtend => allSelectorsExtend.clone());\n            }\n\n            for (j = 0; j < extendList.length; j++) {\n                this.foundExtends = true;\n                extend = extendList[j];\n                extend.findSelfSelectors(selectorPath);\n                extend.ruleset = rulesetNode;\n                if (j === 0) { extend.firstExtendOnThisSelectorPath = true; }\n                this.allExtendsStack[this.allExtendsStack.length - 1].push(extend);\n            }\n        }\n\n        this.contexts.push(rulesetNode.selectors);\n    }\n\n    visitRulesetOut(rulesetNode) {\n        if (!rulesetNode.root) {\n            this.contexts.length = this.contexts.length - 1;\n        }\n    }\n\n    visitMedia(mediaNode, visitArgs) {\n        mediaNode.allExtends = [];\n        this.allExtendsStack.push(mediaNode.allExtends);\n    }\n\n    visitMediaOut(mediaNode) {\n        this.allExtendsStack.length = this.allExtendsStack.length - 1;\n    }\n\n    visitAtRule(atRuleNode, visitArgs) {\n        atRuleNode.allExtends = [];\n        this.allExtendsStack.push(atRuleNode.allExtends);\n    }\n\n    visitAtRuleOut(atRuleNode) {\n        this.allExtendsStack.length = this.allExtendsStack.length - 1;\n    }\n}\n\nclass ProcessExtendsVisitor {\n    constructor() {\n        this._visitor = new Visitor(this);\n    }\n\n    run(root) {\n        const extendFinder = new ExtendFinderVisitor();\n        this.extendIndices = {};\n        extendFinder.run(root);\n        if (!extendFinder.foundExtends) { return root; }\n        root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));\n        this.allExtendsStack = [root.allExtends];\n        const newRoot = this._visitor.visit(root);\n        this.checkExtendsForNonMatched(root.allExtends);\n        return newRoot;\n    }\n\n    checkExtendsForNonMatched(extendList) {\n        const indices = this.extendIndices;\n        extendList.filter(extend => !extend.hasFoundMatches && extend.parent_ids.length == 1).forEach(extend => {\n            let selector = '_unknown_';\n            try {\n                selector = extend.selector.toCSS({});\n            }\n            catch (_) {}\n\n            if (!indices[`${extend.index} ${selector}`]) {\n                indices[`${extend.index} ${selector}`] = true;\n                logger.warn(`extend '${selector}' has no matches`);\n            }\n        });\n    }\n\n    doExtendChaining(extendsList, extendsListTarget, iterationCount) {\n        //\n        // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering\n        // and pasting the selector we would do normally, but we are also adding an extend with the same target selector\n        // this means this new extend can then go and alter other extends\n        //\n        // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors\n        // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already\n        // processed if we look at each selector at a time, as is done in visitRuleset\n\n        let extendIndex;\n\n        let targetExtendIndex;\n        let matches;\n        const extendsToAdd = [];\n        let newSelector;\n        const extendVisitor = this;\n        let selectorPath;\n        let extend;\n        let targetExtend;\n        let newExtend;\n\n        iterationCount = iterationCount || 0;\n\n        // loop through comparing every extend with every target extend.\n        // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place\n        // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one\n        // and the second is the target.\n        // the separation into two lists allows us to process a subset of chains with a bigger set, as is the\n        // case when processing media queries\n        for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {\n            for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {\n\n                extend = extendsList[extendIndex];\n                targetExtend = extendsListTarget[targetExtendIndex];\n\n                // look for circular references\n                if ( extend.parent_ids.indexOf( targetExtend.object_id ) >= 0 ) { continue; }\n\n                // find a match in the target extends self selector (the bit before :extend)\n                selectorPath = [targetExtend.selfSelectors[0]];\n                matches = extendVisitor.findMatch(extend, selectorPath);\n\n                if (matches.length) {\n                    extend.hasFoundMatches = true;\n\n                    // we found a match, so for each self selector..\n                    extend.selfSelectors.forEach(selfSelector => {\n                        const info = targetExtend.visibilityInfo();\n\n                        // process the extend as usual\n                        newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend.isVisible());\n\n                        // but now we create a new extend from it\n                        newExtend = new(tree.Extend)(targetExtend.selector, targetExtend.option, 0, targetExtend.fileInfo(), info);\n                        newExtend.selfSelectors = newSelector;\n\n                        // add the extend onto the list of extends for that selector\n                        newSelector[newSelector.length - 1].extendList = [newExtend];\n\n                        // record that we need to add it.\n                        extendsToAdd.push(newExtend);\n                        newExtend.ruleset = targetExtend.ruleset;\n\n                        // remember its parents for circular references\n                        newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend.parent_ids);\n\n                        // only process the selector once.. if we have :extend(.a,.b) then multiple\n                        // extends will look at the same selector path, so when extending\n                        // we know that any others will be duplicates in terms of what is added to the css\n                        if (targetExtend.firstExtendOnThisSelectorPath) {\n                            newExtend.firstExtendOnThisSelectorPath = true;\n                            targetExtend.ruleset.paths.push(newSelector);\n                        }\n                    });\n                }\n            }\n        }\n\n        if (extendsToAdd.length) {\n            // try to detect circular references to stop a stack overflow.\n            // may no longer be needed.\n            this.extendChainCount++;\n            if (iterationCount > 100) {\n                let selectorOne = '{unable to calculate}';\n                let selectorTwo = '{unable to calculate}';\n                try {\n                    selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();\n                    selectorTwo = extendsToAdd[0].selector.toCSS();\n                }\n                catch (e) {}\n                throw { message: `extend circular reference detected. One of the circular extends is currently:${selectorOne}:extend(${selectorTwo})`};\n            }\n\n            // now process the new extends on the existing rules so that we can handle a extending b extending c extending\n            // d extending e...\n            return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));\n        } else {\n            return extendsToAdd;\n        }\n    }\n\n    visitDeclaration(ruleNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    }\n\n    visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    }\n\n    visitSelector(selectorNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    }\n\n    visitRuleset(rulesetNode, visitArgs) {\n        if (rulesetNode.root) {\n            return;\n        }\n        let matches;\n        let pathIndex;\n        let extendIndex;\n        const allExtends = this.allExtendsStack[this.allExtendsStack.length - 1];\n        const selectorsToAdd = [];\n        const extendVisitor = this;\n        let selectorPath;\n\n        // look at each selector path in the ruleset, find any extend matches and then copy, find and replace\n\n        for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {\n            for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {\n                selectorPath = rulesetNode.paths[pathIndex];\n\n                // extending extends happens initially, before the main pass\n                if (rulesetNode.extendOnEveryPath) { continue; }\n                const extendList = selectorPath[selectorPath.length - 1].extendList;\n                if (extendList && extendList.length) { continue; }\n\n                matches = this.findMatch(allExtends[extendIndex], selectorPath);\n\n                if (matches.length) {\n                    allExtends[extendIndex].hasFoundMatches = true;\n\n                    allExtends[extendIndex].selfSelectors.forEach(selfSelector => {\n                        let extendedSelectors;\n                        extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());\n                        selectorsToAdd.push(extendedSelectors);\n                    });\n                }\n            }\n        }\n        rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);\n    }\n\n    findMatch(extend, haystackSelectorPath) {\n        //\n        // look through the haystack selector path to try and find the needle - extend.selector\n        // returns an array of selector matches that can then be replaced\n        //\n        let haystackSelectorIndex;\n\n        let hackstackSelector;\n        let hackstackElementIndex;\n        let haystackElement;\n        let targetCombinator;\n        let i;\n        const extendVisitor = this;\n        const needleElements = extend.selector.elements;\n        const potentialMatches = [];\n        let potentialMatch;\n        const matches = [];\n\n        // loop through the haystack elements\n        for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {\n            hackstackSelector = haystackSelectorPath[haystackSelectorIndex];\n\n            for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {\n\n                haystackElement = hackstackSelector.elements[hackstackElementIndex];\n\n                // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.\n                if (extend.allowBefore || (haystackSelectorIndex === 0 && hackstackElementIndex === 0)) {\n                    potentialMatches.push({pathIndex: haystackSelectorIndex, index: hackstackElementIndex, matched: 0,\n                        initialCombinator: haystackElement.combinator});\n                }\n\n                for (i = 0; i < potentialMatches.length; i++) {\n                    potentialMatch = potentialMatches[i];\n\n                    // selectors add \" \" onto the first element. When we use & it joins the selectors together, but if we don't\n                    // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to\n                    // work out what the resulting combinator will be\n                    targetCombinator = haystackElement.combinator.value;\n                    if (targetCombinator === '' && hackstackElementIndex === 0) {\n                        targetCombinator = ' ';\n                    }\n\n                    // if we don't match, null our match to indicate failure\n                    if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) ||\n                        (potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator)) {\n                        potentialMatch = null;\n                    } else {\n                        potentialMatch.matched++;\n                    }\n\n                    // if we are still valid and have finished, test whether we have elements after and whether these are allowed\n                    if (potentialMatch) {\n                        potentialMatch.finished = potentialMatch.matched === needleElements.length;\n                        if (potentialMatch.finished &&\n                            (!extend.allowAfter &&\n                                (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length))) {\n                            potentialMatch = null;\n                        }\n                    }\n                    // if null we remove, if not, we are still valid, so either push as a valid match or continue\n                    if (potentialMatch) {\n                        if (potentialMatch.finished) {\n                            potentialMatch.length = needleElements.length;\n                            potentialMatch.endPathIndex = haystackSelectorIndex;\n                            potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match\n                            potentialMatches.length = 0; // we don't allow matches to overlap, so start matching again\n                            matches.push(potentialMatch);\n                        }\n                    } else {\n                        potentialMatches.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n\n    isElementValuesEqual(elementValue1, elementValue2) {\n        if (typeof elementValue1 === 'string' || typeof elementValue2 === 'string') {\n            return elementValue1 === elementValue2;\n        }\n        if (elementValue1 instanceof tree.Attribute) {\n            if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {\n                return false;\n            }\n            if (!elementValue1.value || !elementValue2.value) {\n                if (elementValue1.value || elementValue2.value) {\n                    return false;\n                }\n                return true;\n            }\n            elementValue1 = elementValue1.value.value || elementValue1.value;\n            elementValue2 = elementValue2.value.value || elementValue2.value;\n            return elementValue1 === elementValue2;\n        }\n        elementValue1 = elementValue1.value;\n        elementValue2 = elementValue2.value;\n        if (elementValue1 instanceof tree.Selector) {\n            if (!(elementValue2 instanceof tree.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {\n                return false;\n            }\n            for (let i = 0; i  < elementValue1.elements.length; i++) {\n                if (elementValue1.elements[i].combinator.value !== elementValue2.elements[i].combinator.value) {\n                    if (i !== 0 || (elementValue1.elements[i].combinator.value || ' ') !== (elementValue2.elements[i].combinator.value || ' ')) {\n                        return false;\n                    }\n                }\n                if (!this.isElementValuesEqual(elementValue1.elements[i].value, elementValue2.elements[i].value)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    extendSelector(matches, selectorPath, replacementSelector, isVisible) {\n        // for a set of matches, replace each match with the replacement selector\n\n        let currentSelectorPathIndex = 0;\n\n        let currentSelectorPathElementIndex = 0;\n        let path = [];\n        let matchIndex;\n        let selector;\n        let firstElement;\n        let match;\n        let newElements;\n\n        for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {\n            match = matches[matchIndex];\n            selector = selectorPath[match.pathIndex];\n            firstElement = new tree.Element(\n                match.initialCombinator,\n                replacementSelector.elements[0].value,\n                replacementSelector.elements[0].isVariable,\n                replacementSelector.elements[0].getIndex(),\n                replacementSelector.elements[0].fileInfo()\n            );\n\n            if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {\n                path[path.length - 1].elements = path[path.length - 1]\n                    .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));\n                currentSelectorPathElementIndex = 0;\n                currentSelectorPathIndex++;\n            }\n\n            newElements = selector.elements\n                .slice(currentSelectorPathElementIndex, match.index)\n                .concat([firstElement])\n                .concat(replacementSelector.elements.slice(1));\n\n            if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {\n                path[path.length - 1].elements =\n                    path[path.length - 1].elements.concat(newElements);\n            } else {\n                path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));\n\n                path.push(new tree.Selector(\n                    newElements\n                ));\n            }\n            currentSelectorPathIndex = match.endPathIndex;\n            currentSelectorPathElementIndex = match.endPathElementIndex;\n            if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {\n                currentSelectorPathElementIndex = 0;\n                currentSelectorPathIndex++;\n            }\n        }\n\n        if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {\n            path[path.length - 1].elements = path[path.length - 1]\n                .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));\n            currentSelectorPathIndex++;\n        }\n\n        path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));\n        path = path.map(currentValue => {\n            // we can re-use elements here, because the visibility property matters only for selectors\n            const derived = currentValue.createDerived(currentValue.elements);\n            if (isVisible) {\n                derived.ensureVisibility();\n            } else {\n                derived.ensureInvisibility();\n            }\n            return derived;\n        });\n        return path;\n    }\n\n    visitMedia(mediaNode, visitArgs) {\n        let newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);\n        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));\n        this.allExtendsStack.push(newAllExtends);\n    }\n\n    visitMediaOut(mediaNode) {\n        const lastIndex = this.allExtendsStack.length - 1;\n        this.allExtendsStack.length = lastIndex;\n    }\n\n    visitAtRule(atRuleNode, visitArgs) {\n        let newAllExtends = atRuleNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);\n        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, atRuleNode.allExtends));\n        this.allExtendsStack.push(newAllExtends);\n    }\n\n    visitAtRuleOut(atRuleNode) {\n        const lastIndex = this.allExtendsStack.length - 1;\n        this.allExtendsStack.length = lastIndex;\n    }\n}\n\nexport default ProcessExtendsVisitor;\n","import Visitor from './visitor';\n\nclass JoinSelectorVisitor {\n    constructor() {\n        this.contexts = [[]];\n        this._visitor = new Visitor(this);\n    }\n\n    run(root) {\n        return this._visitor.visit(root);\n    }\n\n    visitDeclaration(declNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    }\n\n    visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    }\n\n    visitRuleset(rulesetNode, visitArgs) {\n        const context = this.contexts[this.contexts.length - 1];\n        const paths = [];\n        let selectors;\n\n        this.contexts.push(paths);\n\n        if (!rulesetNode.root) {\n            selectors = rulesetNode.selectors;\n            if (selectors) {\n                selectors = selectors.filter(selector => selector.getIsOutput());\n                rulesetNode.selectors = selectors.length ? selectors : (selectors = null);\n                if (selectors) { rulesetNode.joinSelectors(paths, context, selectors); }\n            }\n            if (!selectors) { rulesetNode.rules = null; }\n            rulesetNode.paths = paths;\n        }\n    }\n\n    visitRulesetOut(rulesetNode) {\n        this.contexts.length = this.contexts.length - 1;\n    }\n\n    visitMedia(mediaNode, visitArgs) {\n        const context = this.contexts[this.contexts.length - 1];\n        mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);\n    }\n\n    visitAtRule(atRuleNode, visitArgs) {\n        const context = this.contexts[this.contexts.length - 1];\n        if (atRuleNode.rules && atRuleNode.rules.length) {\n            atRuleNode.rules[0].root = (atRuleNode.isRooted || context.length === 0 || null);\n        }\n    }\n}\n\nexport default JoinSelectorVisitor;\n","import tree from '../tree';\nimport Visitor from './visitor';\n\nclass CSSVisitorUtils {\n    constructor(context) {\n        this._visitor = new Visitor(this);\n        this._context = context;\n    }\n\n    containsSilentNonBlockedChild(bodyRules) {\n        let rule;\n        if (!bodyRules) {\n            return false;\n        }\n        for (let r = 0; r < bodyRules.length; r++) {\n            rule = bodyRules[r];\n            if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {\n                // the atrule contains something that was referenced (likely by extend)\n                // therefore it needs to be shown in output too\n                return true;\n            }\n        }\n        return false;\n    }\n\n    keepOnlyVisibleChilds(owner) {\n        if (owner && owner.rules) {\n            owner.rules = owner.rules.filter(thing => thing.isVisible());\n        }\n    }\n\n    isEmpty(owner) {\n        return (owner && owner.rules) \n            ? (owner.rules.length === 0) : true;\n    }\n\n    hasVisibleSelector(rulesetNode) {\n        return (rulesetNode && rulesetNode.paths)\n            ? (rulesetNode.paths.length > 0) : false;\n    }\n\n    resolveVisibility(node, originalRules) {\n        if (!node.blocksVisibility()) {\n            if (this.isEmpty(node) && !this.containsSilentNonBlockedChild(originalRules)) {\n                return ;\n            }\n\n            return node;\n        }\n\n        const compiledRulesBody = node.rules[0];\n        this.keepOnlyVisibleChilds(compiledRulesBody);\n\n        if (this.isEmpty(compiledRulesBody)) {\n            return ;\n        }\n\n        node.ensureVisibility();\n        node.removeVisibilityBlock();\n\n        return node;\n    }\n\n    isVisibleRuleset(rulesetNode) {\n        if (rulesetNode.firstRoot) {\n            return true;\n        }\n\n        if (this.isEmpty(rulesetNode)) {\n            return false;\n        }\n\n        if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\nconst ToCSSVisitor = function(context) {\n    this._visitor = new Visitor(this);\n    this._context = context;\n    this.utils = new CSSVisitorUtils(context);\n};\n\nToCSSVisitor.prototype = {\n    isReplacing: true,\n    run: function (root) {\n        return this._visitor.visit(root);\n    },\n\n    visitDeclaration: function (declNode, visitArgs) {\n        if (declNode.blocksVisibility() || declNode.variable) {\n            return;\n        }\n        return declNode;\n    },\n\n    visitMixinDefinition: function (mixinNode, visitArgs) {\n        // mixin definitions do not get eval'd - this means they keep state\n        // so we have to clear that state here so it isn't used if toCSS is called twice\n        mixinNode.frames = [];\n    },\n\n    visitExtend: function (extendNode, visitArgs) {\n    },\n\n    visitComment: function (commentNode, visitArgs) {\n        if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {\n            return;\n        }\n        return commentNode;\n    },\n\n    visitMedia: function(mediaNode, visitArgs) {\n        const originalRules = mediaNode.rules[0].rules;\n        mediaNode.accept(this._visitor);\n        visitArgs.visitDeeper = false;\n\n        return this.utils.resolveVisibility(mediaNode, originalRules);\n    },\n\n    visitImport: function (importNode, visitArgs) {\n        if (importNode.blocksVisibility()) {\n            return ;\n        }\n        return importNode;\n    },\n\n    visitAtRule: function(atRuleNode, visitArgs) {\n        if (atRuleNode.rules && atRuleNode.rules.length) {\n            return this.visitAtRuleWithBody(atRuleNode, visitArgs);\n        } else {\n            return this.visitAtRuleWithoutBody(atRuleNode, visitArgs);\n        }\n    },\n\n    visitAnonymous: function(anonymousNode, visitArgs) {\n        if (!anonymousNode.blocksVisibility()) {\n            anonymousNode.accept(this._visitor);\n            return anonymousNode;\n        }\n    },\n\n    visitAtRuleWithBody: function(atRuleNode, visitArgs) {\n        // if there is only one nested ruleset and that one has no path, then it is\n        // just fake ruleset\n        function hasFakeRuleset(atRuleNode) {\n            const bodyRules = atRuleNode.rules;\n            return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);\n        }\n        function getBodyRules(atRuleNode) {\n            const nodeRules = atRuleNode.rules;\n            if (hasFakeRuleset(atRuleNode)) {\n                return nodeRules[0].rules;\n            }\n\n            return nodeRules;\n        }\n        // it is still true that it is only one ruleset in array\n        // this is last such moment\n        // process childs\n        const originalRules = getBodyRules(atRuleNode);\n        atRuleNode.accept(this._visitor);\n        visitArgs.visitDeeper = false;\n\n        if (!this.utils.isEmpty(atRuleNode)) {\n            this._mergeRules(atRuleNode.rules[0].rules);\n        }\n\n        return this.utils.resolveVisibility(atRuleNode, originalRules);\n    },\n\n    visitAtRuleWithoutBody: function(atRuleNode, visitArgs) {\n        if (atRuleNode.blocksVisibility()) {\n            return;\n        }\n\n        if (atRuleNode.name === '@charset') {\n            // Only output the debug info together with subsequent @charset definitions\n            // a comment (or @media statement) before the actual @charset atrule would\n            // be considered illegal css as it has to be on the first line\n            if (this.charset) {\n                if (atRuleNode.debugInfo) {\n                    const comment = new tree.Comment(`/* ${atRuleNode.toCSS(this._context).replace(/\\n/g, '')} */\\n`);\n                    comment.debugInfo = atRuleNode.debugInfo;\n                    return this._visitor.visit(comment);\n                }\n                return;\n            }\n            this.charset = true;\n        }\n\n        return atRuleNode;\n    },\n\n    checkValidNodes: function(rules, isRoot) {\n        if (!rules) {\n            return;\n        }\n\n        for (let i = 0; i < rules.length; i++) {\n            const ruleNode = rules[i];\n            if (isRoot && ruleNode instanceof tree.Declaration && !ruleNode.variable) {\n                throw { message: 'Properties must be inside selector blocks. They cannot be in the root',\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename};\n            }\n            if (ruleNode instanceof tree.Call) {\n                throw { message: `Function '${ruleNode.name}' is undefined`,\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename};\n            }\n            if (ruleNode.type && !ruleNode.allowRoot) {\n                throw { message: `${ruleNode.type} node returned by a function is not valid here`,\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename};\n            }\n        }\n    },\n\n    visitRuleset: function (rulesetNode, visitArgs) {\n        // at this point rulesets are nested into each other\n        let rule;\n\n        const rulesets = [];\n\n        this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);\n\n        if (!rulesetNode.root) {\n            // remove invisible paths\n            this._compileRulesetPaths(rulesetNode);\n\n            // remove rulesets from this ruleset body and compile them separately\n            const nodeRules = rulesetNode.rules;\n\n            let nodeRuleCnt = nodeRules ? nodeRules.length : 0;\n            for (let i = 0; i < nodeRuleCnt; ) {\n                rule = nodeRules[i];\n                if (rule && rule.rules) {\n                    // visit because we are moving them out from being a child\n                    rulesets.push(this._visitor.visit(rule));\n                    nodeRules.splice(i, 1);\n                    nodeRuleCnt--;\n                    continue;\n                }\n                i++;\n            }\n            // accept the visitor to remove rules and refactor itself\n            // then we can decide nogw whether we want it or not\n            // compile body\n            if (nodeRuleCnt > 0) {\n                rulesetNode.accept(this._visitor);\n            } else {\n                rulesetNode.rules = null;\n            }\n            visitArgs.visitDeeper = false;\n        } else { // if (! rulesetNode.root) {\n            rulesetNode.accept(this._visitor);\n            visitArgs.visitDeeper = false;\n        }\n\n        if (rulesetNode.rules) {\n            this._mergeRules(rulesetNode.rules);\n            this._removeDuplicateRules(rulesetNode.rules);\n        }\n\n        // now decide whether we keep the ruleset\n        if (this.utils.isVisibleRuleset(rulesetNode)) {\n            rulesetNode.ensureVisibility();\n            rulesets.splice(0, 0, rulesetNode);\n        }\n\n        if (rulesets.length === 1) {\n            return rulesets[0];\n        }\n        return rulesets;\n    },\n\n    _compileRulesetPaths: function(rulesetNode) {\n        if (rulesetNode.paths) {\n            rulesetNode.paths = rulesetNode.paths\n                .filter(p => {\n                    let i;\n                    if (p[0].elements[0].combinator.value === ' ') {\n                        p[0].elements[0].combinator = new(tree.Combinator)('');\n                    }\n                    for (i = 0; i < p.length; i++) {\n                        if (p[i].isVisible() && p[i].getIsOutput()) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n        }\n    },\n\n    _removeDuplicateRules: function(rules) {\n        if (!rules) { return; }\n\n        // remove duplicates\n        const ruleCache = {};\n\n        let ruleList;\n        let rule;\n        let i;\n\n        for (i = rules.length - 1; i >= 0 ; i--) {\n            rule = rules[i];\n            if (rule instanceof tree.Declaration) {\n                if (!ruleCache[rule.name]) {\n                    ruleCache[rule.name] = rule;\n                } else {\n                    ruleList = ruleCache[rule.name];\n                    if (ruleList instanceof tree.Declaration) {\n                        ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];\n                    }\n                    const ruleCSS = rule.toCSS(this._context);\n                    if (ruleList.indexOf(ruleCSS) !== -1) {\n                        rules.splice(i, 1);\n                    } else {\n                        ruleList.push(ruleCSS);\n                    }\n                }\n            }\n        }\n    },\n\n    _mergeRules: function(rules) {\n        if (!rules) {\n            return; \n        }\n\n        const groups    = {};\n        const groupsArr = [];\n\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i];\n            if (rule.merge) {\n                const key = rule.name;\n                groups[key] ? rules.splice(i--, 1) : \n                    groupsArr.push(groups[key] = []);\n                groups[key].push(rule);\n            }\n        }\n\n        groupsArr.forEach(group => {\n            if (group.length > 0) {\n                const result = group[0];\n                let space  = [];\n                const comma  = [new tree.Expression(space)];\n                group.forEach(rule => {\n                    if ((rule.merge === '+') && (space.length > 0)) {\n                        comma.push(new tree.Expression(space = []));\n                    }\n                    space.push(rule.value);\n                    result.important = result.important || rule.important;\n                });\n                result.value = new tree.Value(comma);\n            }\n        });\n    }\n};\n\nexport default ToCSSVisitor;\n","import Visitor from './visitor';\nimport ImportVisitor from './import-visitor';\nimport MarkVisibleSelectorsVisitor from './set-tree-visibility-visitor';\nimport ExtendVisitor from './extend-visitor';\nimport JoinSelectorVisitor from './join-selector-visitor';\nimport ToCSSVisitor from './to-css-visitor';\n\nexport default {\n    Visitor,\n    ImportVisitor,\n    MarkVisibleSelectorsVisitor,\n    ExtendVisitor,\n    JoinSelectorVisitor,\n    ToCSSVisitor\n};\n","import chunker from './chunker';\n\nexport default () => {\n    let // Less input string\n        input;\n\n    let // current chunk\n        j;\n\n    const // holds state for backtracking\n        saveStack = [];\n\n    let // furthest index the parser has gone to\n        furthest;\n\n    let // if this is furthest we got to, this is the probably cause\n        furthestPossibleErrorMessage;\n\n    let // chunkified input\n        chunks;\n\n    let // current chunk\n        current;\n\n    let // index of current chunk, in `input`\n        currentPos;\n\n    const parserInput = {};\n    const CHARCODE_SPACE = 32;\n    const CHARCODE_TAB = 9;\n    const CHARCODE_LF = 10;\n    const CHARCODE_CR = 13;\n    const CHARCODE_PLUS = 43;\n    const CHARCODE_COMMA = 44;\n    const CHARCODE_FORWARD_SLASH = 47;\n    const CHARCODE_9 = 57;\n\n    function skipWhitespace(length) {\n        const oldi = parserInput.i;\n        const oldj = j;\n        const curr = parserInput.i - currentPos;\n        const endIndex = parserInput.i + current.length - curr;\n        const mem = (parserInput.i += length);\n        const inp = input;\n        let c;\n        let nextChar;\n        let comment;\n\n        for (; parserInput.i < endIndex; parserInput.i++) {\n            c = inp.charCodeAt(parserInput.i);\n\n            if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {\n                nextChar = inp.charAt(parserInput.i + 1);\n                if (nextChar === '/') {\n                    comment = {index: parserInput.i, isLineComment: true};\n                    let nextNewLine = inp.indexOf('\\n', parserInput.i + 2);\n                    if (nextNewLine < 0) {\n                        nextNewLine = endIndex;\n                    }\n                    parserInput.i = nextNewLine;\n                    comment.text = inp.substr(comment.index, parserInput.i - comment.index);\n                    parserInput.commentStore.push(comment);\n                    continue;\n                } else if (nextChar === '*') {\n                    const nextStarSlash = inp.indexOf('*/', parserInput.i + 2);\n                    if (nextStarSlash >= 0) {\n                        comment = {\n                            index: parserInput.i,\n                            text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),\n                            isLineComment: false\n                        };\n                        parserInput.i += comment.text.length - 1;\n                        parserInput.commentStore.push(comment);\n                        continue;\n                    }\n                }\n                break;\n            }\n\n            if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {\n                break;\n            }\n        }\n\n        current = current.slice(length + parserInput.i - mem + curr);\n        currentPos = parserInput.i;\n\n        if (!current.length) {\n            if (j < chunks.length - 1) {\n                current = chunks[++j];\n                skipWhitespace(0); // skip space at the beginning of a chunk\n                return true; // things changed\n            }\n            parserInput.finished = true;\n        }\n\n        return oldi !== parserInput.i || oldj !== j;\n    }\n\n    parserInput.save = () => {\n        currentPos = parserInput.i;\n        saveStack.push( { current, i: parserInput.i, j });\n    };\n    parserInput.restore = possibleErrorMessage => {\n\n        if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {\n            furthest = parserInput.i;\n            furthestPossibleErrorMessage = possibleErrorMessage;\n        }\n        const state = saveStack.pop();\n        current = state.current;\n        currentPos = parserInput.i = state.i;\n        j = state.j;\n    };\n    parserInput.forget = () => {\n        saveStack.pop();\n    };\n    parserInput.isWhitespace = offset => {\n        const pos = parserInput.i + (offset || 0);\n        const code = input.charCodeAt(pos);\n        return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);\n    };\n\n    // Specialization of $(tok)\n    parserInput.$re = tok => {\n        if (parserInput.i > currentPos) {\n            current = current.slice(parserInput.i - currentPos);\n            currentPos = parserInput.i;\n        }\n\n        const m = tok.exec(current);\n        if (!m) {\n            return null;\n        }\n\n        skipWhitespace(m[0].length);\n        if (typeof m === 'string') {\n            return m;\n        }\n\n        return m.length === 1 ? m[0] : m;\n    };\n\n    parserInput.$char = tok => {\n        if (input.charAt(parserInput.i) !== tok) {\n            return null;\n        }\n        skipWhitespace(1);\n        return tok;\n    };\n\n    parserInput.$str = tok => {\n        const tokLength = tok.length;\n\n        // https://jsperf.com/string-startswith/21\n        for (let i = 0; i < tokLength; i++) {\n            if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                return null;\n            }\n        }\n\n        skipWhitespace(tokLength);\n        return tok;\n    };\n\n    parserInput.$quoted = loc => {\n        const pos = loc || parserInput.i;\n        const startChar = input.charAt(pos);\n\n        if (startChar !== '\\'' && startChar !== '\"') {\n            return;\n        }\n        const length = input.length;\n        const currentPosition = pos;\n\n        for (let i = 1; i + currentPosition < length; i++) {\n            const nextChar = input.charAt(i + currentPosition);\n            switch (nextChar) {\n                case '\\\\':\n                    i++;\n                    continue;\n                case '\\r':\n                case '\\n':\n                    break;\n                case startChar:\n                    const str = input.substr(currentPosition, i + 1);\n                    if (!loc && loc !== 0) {\n                        skipWhitespace(i + 1);\n                        return str\n                    }\n                    return [startChar, str];\n                default:\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Permissive parsing. Ignores everything except matching {} [] () and quotes\n     * until matching token (outside of blocks)\n     */\n    parserInput.$parseUntil = tok => {\n        let quote = '';\n        let returnVal = null;\n        let inComment = false;\n        let blockDepth = 0;\n        const blockStack = [];\n        const parseGroups = [];\n        const length = input.length;\n        const startPos = parserInput.i;\n        let lastPos = parserInput.i;\n        let i = parserInput.i;\n        let loop = true;\n        let testChar;\n\n        if (typeof tok === 'string') {\n            testChar = char => char === tok\n        } else {\n            testChar = char => tok.test(char)\n        }\n\n        do {\n            let prevChar;\n            let nextChar = input.charAt(i);\n            if (blockDepth === 0 && testChar(nextChar)) {\n                returnVal = input.substr(lastPos, i - lastPos);\n                if (returnVal) {\n                    parseGroups.push(returnVal);\n                }\n                else {\n                    parseGroups.push(' ');\n                }\n                returnVal = parseGroups;\n                skipWhitespace(i - startPos);\n                loop = false\n            } else {\n                if (inComment) {\n                    if (nextChar === '*' && \n                        input.charAt(i + 1) === '/') {\n                        i++;\n                        blockDepth--;\n                        inComment = false;\n                    }\n                    i++;\n                    continue;\n                }\n                switch (nextChar) {\n                    case '\\\\':\n                        i++;\n                        nextChar = input.charAt(i);\n                        parseGroups.push(input.substr(lastPos, i - lastPos + 1));\n                        lastPos = i + 1;\n                        break;\n                    case '/':\n                        if (input.charAt(i + 1) === '*') {\n                            i++;\n                            inComment = true;\n                            blockDepth++;\n                        }\n                        break;\n                    case '\\'':\n                    case '\"':\n                        quote = parserInput.$quoted(i);\n                        if (quote) {\n                            parseGroups.push(input.substr(lastPos, i - lastPos), quote);\n                            i += quote[1].length - 1;\n                            lastPos = i + 1;\n                        }\n                        else {\n                            skipWhitespace(i - startPos);\n                            returnVal = nextChar;\n                            loop = false;\n                        }\n                        break;\n                    case '{':\n                        blockStack.push('}');\n                        blockDepth++;\n                        break;\n                    case '(':\n                        blockStack.push(')');\n                        blockDepth++;\n                        break;\n                    case '[':\n                        blockStack.push(']');\n                        blockDepth++;\n                        break;\n                    case '}':\n                    case ')':\n                    case ']':\n                        const expected = blockStack.pop();\n                        if (nextChar === expected) {\n                            blockDepth--;\n                        } else {\n                            // move the parser to the error and return expected\n                            skipWhitespace(i - startPos);\n                            returnVal = expected;\n                            loop = false;\n                        }\n                }\n                i++;\n                if (i > length) {\n                    loop = false;\n                }\n            }\n            prevChar = nextChar;\n        } while (loop);\n\n        return returnVal ? returnVal : null;\n    }\n\n    parserInput.autoCommentAbsorb = true;\n    parserInput.commentStore = [];\n    parserInput.finished = false;\n\n    // Same as $(), but don't change the state of the parser,\n    // just return the match.\n    parserInput.peek = tok => {\n        if (typeof tok === 'string') {\n            // https://jsperf.com/string-startswith/21\n            for (let i = 0; i < tok.length; i++) {\n                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return tok.test(current);\n        }\n    };\n\n    // Specialization of peek()\n    // TODO remove or change some currentChar calls to peekChar\n    parserInput.peekChar = tok => input.charAt(parserInput.i) === tok;\n\n    parserInput.currentChar = () => input.charAt(parserInput.i);\n\n    parserInput.prevChar = () => input.charAt(parserInput.i - 1);\n\n    parserInput.getInput = () => input;\n\n    parserInput.peekNotNumeric = () => {\n        const c = input.charCodeAt(parserInput.i);\n        // Is the first char of the dimension 0-9, '.', '+' or '-'\n        return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;\n    };\n\n    parserInput.start = (str, chunkInput, failFunction) => {\n        input = str;\n        parserInput.i = j = currentPos = furthest = 0;\n\n        // chunking apparently makes things quicker (but my tests indicate\n        // it might actually make things slower in node at least)\n        // and it is a non-perfect parse - it can't recognise\n        // unquoted urls, meaning it can't distinguish comments\n        // meaning comments with quotes or {}() in them get 'counted'\n        // and then lead to parse errors.\n        // In addition if the chunking chunks in the wrong place we might\n        // not be able to parse a parser statement in one go\n        // this is officially deprecated but can be switched on via an option\n        // in the case it causes too much performance issues.\n        if (chunkInput) {\n            chunks = chunker(str, failFunction);\n        } else {\n            chunks = [str];\n        }\n\n        current = chunks[0];\n\n        skipWhitespace(0);\n    };\n\n    parserInput.end = () => {\n        let message;\n        const isFinished = parserInput.i >= input.length;\n\n        if (parserInput.i < furthest) {\n            message = furthestPossibleErrorMessage;\n            parserInput.i = furthest;\n        }\n        return {\n            isFinished,\n            furthest: parserInput.i,\n            furthestPossibleErrorMessage: message,\n            furthestReachedEnd: parserInput.i >= input.length - 1,\n            furthestChar: input[parserInput.i]\n        };\n    };\n\n    return parserInput;\n};\n","// Split the input into chunks.\nexport default (input, fail) => {\n    const len = input.length;\n    let level = 0;\n    let parenLevel = 0;\n    let lastOpening;\n    let lastOpeningParen;\n    let lastMultiComment;\n    let lastMultiCommentEndBrace;\n    const chunks = [];\n    let emitFrom = 0;\n    let chunkerCurrentIndex;\n    let currentChunkStartIndex;\n    let cc;\n    let cc2;\n    let matched;\n\n    function emitChunk(force) {\n        const len = chunkerCurrentIndex - emitFrom;\n        if (((len < 512) && !force) || !len) {\n            return;\n        }\n        chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));\n        emitFrom = chunkerCurrentIndex + 1;\n    }\n\n    for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n        cc = input.charCodeAt(chunkerCurrentIndex);\n        if (((cc >= 97) && (cc <= 122)) || (cc < 34)) {\n            // a-z or whitespace\n            continue;\n        }\n\n        switch (cc) {\n            case 40:                        // (\n                parenLevel++;\n                lastOpeningParen = chunkerCurrentIndex;\n                continue;\n            case 41:                        // )\n                if (--parenLevel < 0) {\n                    return fail('missing opening `(`', chunkerCurrentIndex);\n                }\n                continue;\n            case 59:                        // ;\n                if (!parenLevel) { emitChunk(); }\n                continue;\n            case 123:                       // {\n                level++;\n                lastOpening = chunkerCurrentIndex;\n                continue;\n            case 125:                       // }\n                if (--level < 0) {\n                    return fail('missing opening `{`', chunkerCurrentIndex);\n                }\n                if (!level && !parenLevel) { emitChunk(); }\n                continue;\n            case 92:                        // \\\n                if (chunkerCurrentIndex < len - 1) { chunkerCurrentIndex++; continue; }\n                return fail('unescaped `\\\\`', chunkerCurrentIndex);\n            case 34:\n            case 39:\n            case 96:                        // \", ' and `\n                matched = 0;\n                currentChunkStartIndex = chunkerCurrentIndex;\n                for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n                    cc2 = input.charCodeAt(chunkerCurrentIndex);\n                    if (cc2 > 96) { continue; }\n                    if (cc2 == cc) { matched = 1; break; }\n                    if (cc2 == 92) {        // \\\n                        if (chunkerCurrentIndex == len - 1) {\n                            return fail('unescaped `\\\\`', chunkerCurrentIndex);\n                        }\n                        chunkerCurrentIndex++;\n                    }\n                }\n                if (matched) { continue; }\n                return fail(`unmatched \\`${String.fromCharCode(cc)}\\``, currentChunkStartIndex);\n            case 47:                        // /, check for comment\n                if (parenLevel || (chunkerCurrentIndex == len - 1)) { continue; }\n                cc2 = input.charCodeAt(chunkerCurrentIndex + 1);\n                if (cc2 == 47) {\n                    // //, find lnfeed\n                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n                        cc2 = input.charCodeAt(chunkerCurrentIndex);\n                        if ((cc2 <= 13) && ((cc2 == 10) || (cc2 == 13))) { break; }\n                    }\n                } else if (cc2 == 42) {\n                    // /*, find */\n                    lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;\n                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {\n                        cc2 = input.charCodeAt(chunkerCurrentIndex);\n                        if (cc2 == 125) { lastMultiCommentEndBrace = chunkerCurrentIndex; }\n                        if (cc2 != 42) { continue; }\n                        if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) { break; }\n                    }\n                    if (chunkerCurrentIndex == len - 1) {\n                        return fail('missing closing `*/`', currentChunkStartIndex);\n                    }\n                    chunkerCurrentIndex++;\n                }\n                continue;\n            case 42:                       // *, check for unmatched */\n                if ((chunkerCurrentIndex < len - 1) && (input.charCodeAt(chunkerCurrentIndex + 1) == 47)) {\n                    return fail('unmatched `/*`', chunkerCurrentIndex);\n                }\n                continue;\n        }\n    }\n\n    if (level !== 0) {\n        if ((lastMultiComment > lastOpening) && (lastMultiCommentEndBrace > lastMultiComment)) {\n            return fail('missing closing `}` or `*/`', lastOpening);\n        } else {\n            return fail('missing closing `}`', lastOpening);\n        }\n    } else if (parenLevel !== 0) {\n        return fail('missing closing `)`', lastOpeningParen);\n    }\n\n    emitChunk(true);\n    return chunks;\n};\n","import LessError from '../less-error';\nimport tree from '../tree';\nimport visitors from '../visitors';\nimport getParserInput from './parser-input';\nimport * as utils from '../utils';\nimport functionRegistry from '../functions/function-registry';\n\n//\n// less.js - parser\n//\n//    A relatively straight-forward predictive parser.\n//    There is no tokenization/lexing stage, the input is parsed\n//    in one sweep.\n//\n//    To make the parser fast enough to run in the browser, several\n//    optimization had to be made:\n//\n//    - Matching and slicing on a huge input is often cause of slowdowns.\n//      The solution is to chunkify the input into smaller strings.\n//      The chunks are stored in the `chunks` var,\n//      `j` holds the current chunk index, and `currentPos` holds\n//      the index of the current chunk in relation to `input`.\n//      This gives us an almost 4x speed-up.\n//\n//    - In many cases, we don't need to match individual tokens;\n//      for example, if a value doesn't hold any variables, operations\n//      or dynamic references, the parser can effectively 'skip' it,\n//      treating it as a literal.\n//      An example would be '1px solid #000' - which evaluates to itself,\n//      we don't need to know what the individual components are.\n//      The drawback, of course is that you don't get the benefits of\n//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,\n//      and a smaller speed-up in the code-gen.\n//\n//\n//    Token matching is done with the `$` function, which either takes\n//    a terminal string or regexp, or a non-terminal function to call.\n//    It also takes care of moving all the indices forwards.\n//\n\nconst Parser = function Parser(context, imports, fileInfo) {\n    let parsers;\n    const parserInput = getParserInput();\n\n    function error(msg, type) {\n        throw new LessError(\n            {\n                index: parserInput.i,\n                filename: fileInfo.filename,\n                type: type || 'Syntax',\n                message: msg\n            },\n            imports\n        );\n    }\n\n    function expect(arg, msg) {\n        // some older browsers return typeof 'function' for RegExp\n        const result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);\n        if (result) {\n            return result;\n        }\n        \n        error(msg || (typeof arg === 'string'\n            ? `expected '${arg}' got '${parserInput.currentChar()}'`\n            : 'unexpected token'));\n    }\n\n    // Specialization of expect()\n    function expectChar(arg, msg) {\n        if (parserInput.$char(arg)) {\n            return arg;\n        }\n        error(msg || `expected '${arg}' got '${parserInput.currentChar()}'`);\n    }\n\n    function getDebugInfo(index) {\n        const filename = fileInfo.filename;\n\n        return {\n            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,\n            fileName: filename\n        };\n    }\n\n    /**\n     *  Used after initial parsing to create nodes on the fly\n     * \n     *  @param {String} str          - string to parse \n     *  @param {Array}  parseList    - array of parsers to run input through e.g. [\"value\", \"important\"]\n     *  @param {Number} currentIndex - start number to begin indexing\n     *  @param {Object} fileInfo     - fileInfo to attach to created nodes\n     */\n    function parseNode(str, parseList, currentIndex, fileInfo, callback) {\n        let result;\n        const returnNodes = [];\n        const parser = parserInput;\n\n        try {\n            parser.start(str, false, function fail(msg, index) {\n                callback({\n                    message: msg,\n                    index: index + currentIndex\n                });\n            });\n            for (let x = 0, p, i; (p = parseList[x]); x++) {\n                i = parser.i;\n                result = parsers[p]();\n                if (result) {\n                    try {\n                        result._index = i + currentIndex;\n                        result._fileInfo = fileInfo;\n                    } catch (e) {}\n                    returnNodes.push(result);\n                }\n                else {\n                    returnNodes.push(null);\n                }\n            }\n\n            const endInfo = parser.end();\n            if (endInfo.isFinished) {\n                callback(null, returnNodes);\n            }\n            else {\n                callback(true, null);\n            }\n        } catch (e) {\n            throw new LessError({\n                index: e.index + currentIndex,\n                message: e.message\n            }, imports, fileInfo.filename);\n        }\n    }\n\n    //\n    // The Parser\n    //\n    return {\n        parserInput,\n        imports,\n        fileInfo,\n        parseNode,\n        //\n        // Parse an input string into an abstract syntax tree,\n        // @param str A string containing 'less' markup\n        // @param callback call `callback` when done.\n        // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply\n        //\n        parse: function (str, callback, additionalData) {\n            let root;\n            let error = null;\n            let globalVars;\n            let modifyVars;\n            let ignored;\n            let preText = '';\n\n            globalVars = (additionalData && additionalData.globalVars) ? `${Parser.serializeVars(additionalData.globalVars)}\\n` : '';\n            modifyVars = (additionalData && additionalData.modifyVars) ? `\\n${Parser.serializeVars(additionalData.modifyVars)}` : '';\n\n            if (context.pluginManager) {\n                const preProcessors = context.pluginManager.getPreProcessors();\n                for (let i = 0; i < preProcessors.length; i++) {\n                    str = preProcessors[i].process(str, { context, imports, fileInfo });\n                }\n            }\n\n            if (globalVars || (additionalData && additionalData.banner)) {\n                preText = ((additionalData && additionalData.banner) ? additionalData.banner : '') + globalVars;\n                ignored = imports.contentsIgnoredChars;\n                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;\n                ignored[fileInfo.filename] += preText.length;\n            }\n\n            str = str.replace(/\\r\\n?/g, '\\n');\n            // Remove potential UTF Byte Order Mark\n            str = preText + str.replace(/^\\uFEFF/, '') + modifyVars;\n            imports.contents[fileInfo.filename] = str;\n\n            // Start with the primary rule.\n            // The whole syntax tree is held under a Ruleset node,\n            // with the `root` property set to true, so no `{}` are\n            // output. The callback is called when the input is parsed.\n            try {\n                parserInput.start(str, context.chunkInput, function fail(msg, index) {\n                    throw new LessError({\n                        index,\n                        type: 'Parse',\n                        message: msg,\n                        filename: fileInfo.filename\n                    }, imports);\n                });\n\n                tree.Node.prototype.parse = this;\n                root = new tree.Ruleset(null, this.parsers.primary());\n                tree.Node.prototype.rootNode = root;\n                root.root = true;\n                root.firstRoot = true;\n                root.functionRegistry = functionRegistry.inherit();\n                \n            } catch (e) {\n                return callback(new LessError(e, imports, fileInfo.filename));\n            }\n\n            // If `i` is smaller than the `input.length - 1`,\n            // it means the parser wasn't able to parse the whole\n            // string, so we've got a parsing error.\n            //\n            // We try to extract a \\n delimited string,\n            // showing the line where the parse error occurred.\n            // We split it up into two parts (the part which parsed,\n            // and the part which didn't), so we can color them differently.\n            const endInfo = parserInput.end();\n            if (!endInfo.isFinished) {\n\n                let message = endInfo.furthestPossibleErrorMessage;\n\n                if (!message) {\n                    message = 'Unrecognised input';\n                    if (endInfo.furthestChar === '}') {\n                        message += '. Possibly missing opening \\'{\\'';\n                    } else if (endInfo.furthestChar === ')') {\n                        message += '. Possibly missing opening \\'(\\'';\n                    } else if (endInfo.furthestReachedEnd) {\n                        message += '. Possibly missing something';\n                    }\n                }\n\n                error = new LessError({\n                    type: 'Parse',\n                    message,\n                    index: endInfo.furthest,\n                    filename: fileInfo.filename\n                }, imports);\n            }\n\n            const finish = e => {\n                e = error || e || imports.error;\n\n                if (e) {\n                    if (!(e instanceof LessError)) {\n                        e = new LessError(e, imports, fileInfo.filename);\n                    }\n\n                    return callback(e);\n                }\n                else {\n                    return callback(null, root);\n                }\n            };\n\n            if (context.processImports !== false) {\n                new visitors.ImportVisitor(imports, finish)\n                    .run(root);\n            } else {\n                return finish();\n            }\n        },\n\n        //\n        // Here in, the parsing rules/functions\n        //\n        // The basic structure of the syntax tree generated is as follows:\n        //\n        //   Ruleset ->  Declaration -> Value -> Expression -> Entity\n        //\n        // Here's some Less code:\n        //\n        //    .class {\n        //      color: #fff;\n        //      border: 1px solid #000;\n        //      width: @w + 4px;\n        //      > .child {...}\n        //    }\n        //\n        // And here's what the parse tree might look like:\n        //\n        //     Ruleset (Selector '.class', [\n        //         Declaration (\"color\",  Value ([Expression [Color #fff]]))\n        //         Declaration (\"border\", Value ([Expression [Dimension 1px][Keyword \"solid\"][Color #000]]))\n        //         Declaration (\"width\",  Value ([Expression [Operation \" + \" [Variable \"@w\"][Dimension 4px]]]))\n        //         Ruleset (Selector [Element '>', '.child'], [...])\n        //     ])\n        //\n        //  In general, most rules will try to parse a token with the `$re()` function, and if the return\n        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\n        //  first, before parsing, that's when we use `peek()`.\n        //\n        parsers: parsers = {\n            //\n            // The `primary` rule is the *entry* and *exit* point of the parser.\n            // The rules here can appear at any level of the parse tree.\n            //\n            // The recursive nature of the grammar is an interplay between the `block`\n            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\n            // as represented by this simplified grammar:\n            //\n            //     primary  →  (ruleset | declaration)+\n            //     ruleset  →  selector+ block\n            //     block    →  '{' primary '}'\n            //\n            // Only at one point is the primary rule not called from the\n            // block rule: at the root level.\n            //\n            primary: function () {\n                const mixin = this.mixin;\n                let root = [];\n                let node;\n\n                while (true) {\n                    while (true) {\n                        node = this.comment();\n                        if (!node) { break; }\n                        root.push(node);\n                    }\n                    // always process comments before deciding if finished\n                    if (parserInput.finished) {\n                        break;\n                    }\n                    if (parserInput.peek('}')) {\n                        break;\n                    }\n\n                    node = this.extendRule();\n                    if (node) {\n                        root = root.concat(node);\n                        continue;\n                    }\n\n                    node = mixin.definition() || this.declaration() || mixin.call(false, false) || \n                        this.ruleset() || this.variableCall() || this.entities.call() || this.atrule();\n                    if (node) {\n                        root.push(node);\n                    } else {\n                        let foundSemiColon = false;\n                        while (parserInput.$char(';')) {\n                            foundSemiColon = true;\n                        }\n                        if (!foundSemiColon) {\n                            break;\n                        }\n                    }\n                }\n\n                return root;\n            },\n\n            // comments are collected by the main parsing mechanism and then assigned to nodes\n            // where the current structure allows it\n            comment: function () {\n                if (parserInput.commentStore.length) {\n                    const comment = parserInput.commentStore.shift();\n                    return new(tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);\n                }\n            },\n\n            //\n            // Entities are tokens which can be found inside an Expression\n            //\n            entities: {\n                mixinLookup: function() {\n                    return parsers.mixin.call(true, true);\n                },\n                //\n                // A string, which supports escaping \" and '\n                //\n                //     \"milky way\" 'he\\'s the one!'\n                //\n                quoted: function (forceEscaped) {\n                    let str;\n                    const index = parserInput.i;\n                    let isEscaped = false;\n\n                    parserInput.save();\n                    if (parserInput.$char('~')) {\n                        isEscaped = true;\n                    } else if (forceEscaped) {\n                        parserInput.restore();\n                        return;\n                    }\n\n                    str = parserInput.$quoted();\n                    if (!str) {\n                        parserInput.restore();\n                        return;\n                    }\n                    parserInput.forget();\n\n                    return new(tree.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);\n                },\n\n                //\n                // A catch-all word, such as:\n                //\n                //     black border-collapse\n                //\n                keyword: function () {\n                    const k = parserInput.$char('%') || parserInput.$re(/^\\[?(?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\\]?/);\n                    if (k) {\n                        return tree.Color.fromKeyword(k) || new(tree.Keyword)(k);\n                    }\n                },\n\n                //\n                // A function call\n                //\n                //     rgb(255, 0, 255)\n                //\n                // The arguments are parsed with the `entities.arguments` parser.\n                //\n                call: function () {\n                    let name;\n                    let args;\n                    let func;\n                    const index = parserInput.i;\n\n                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                    if (parserInput.peek(/^url\\(/i)) {\n                        return;\n                    }\n\n                    parserInput.save();\n\n                    name = parserInput.$re(/^([\\w-]+|%|progid:[\\w\\.]+)\\(/);\n                    if (!name) {\n                        parserInput.forget(); \n                        return;\n                    }\n\n                    name = name[1];\n                    func = this.customFuncCall(name);\n                    if (func) {\n                        args = func.parse();\n                        if (args && func.stop) {\n                            parserInput.forget();\n                            return args;\n                        }\n                    }\n\n                    args = this.arguments(args);\n\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore('Could not parse call arguments or missing \\')\\'');\n                        return;\n                    }\n\n                    parserInput.forget();\n\n                    return new(tree.Call)(name, args, index, fileInfo);\n                },\n                \n                //\n                // Parsing rules for functions with non-standard args, e.g.:\n                //\n                //     boolean(not(2 > 1))\n                //\n                //     This is a quick prototype, to be modified/improved when\n                //     more custom-parsed funcs come (e.g. `selector(...)`)\n                //\n\n                customFuncCall: function (name) {\n                    /* Ideally the table is to be moved out of here for faster perf.,\n                       but it's quite tricky since it relies on all these `parsers`\n                       and `expect` available only here */\n                    return {\n                        alpha:   f(parsers.ieAlpha, true),\n                        boolean: f(condition),\n                        'if':    f(condition)\n                    }[name.toLowerCase()];\n\n                    function f(parse, stop) {\n                        return {\n                            parse, // parsing function\n                            stop   // when true - stop after parse() and return its result, \n                            // otherwise continue for plain args\n                        };\n                    }\n                \n                    function condition() {\n                        return [expect(parsers.condition, 'expected condition')];\n                    }\n                },\n\n                arguments: function (prevArgs) {\n                    let argsComma = prevArgs || [];\n                    const argsSemiColon = [];\n                    let isSemiColonSeparated;\n                    let value;\n\n                    parserInput.save();\n\n                    while (true) {\n                        if (prevArgs) {\n                            prevArgs = false;\n                        } else {\n                            value = parsers.detachedRuleset() || this.assignment() || parsers.expression();\n                            if (!value) {\n                                break;\n                            }\n\n                            if (value.value && value.value.length == 1) {\n                                value = value.value[0];\n                            }\n\n                            argsComma.push(value);\n                        }\n\n                        if (parserInput.$char(',')) {\n                            continue;\n                        }\n\n                        if (parserInput.$char(';') || isSemiColonSeparated) {\n                            isSemiColonSeparated = true;\n                            value = (argsComma.length < 1) ? argsComma[0]\n                                : new tree.Value(argsComma);\n                            argsSemiColon.push(value);\n                            argsComma = [];\n                        }\n                    }\n\n                    parserInput.forget();\n                    return isSemiColonSeparated ? argsSemiColon : argsComma;\n                },\n                literal: function () {\n                    return this.dimension() ||\n                           this.color() ||\n                           this.quoted() ||\n                           this.unicodeDescriptor();\n                },\n\n                // Assignments are argument entities for calls.\n                // They are present in ie filter properties as shown below.\n                //\n                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )\n                //\n\n                assignment: function () {\n                    let key;\n                    let value;\n                    parserInput.save();\n                    key = parserInput.$re(/^\\w+(?=\\s?=)/i);\n                    if (!key) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (!parserInput.$char('=')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    value = parsers.entity();\n                    if (value) {\n                        parserInput.forget();\n                        return new(tree.Assignment)(key, value);\n                    } else {\n                        parserInput.restore();\n                    }\n                },\n\n                //\n                // Parse url() tokens\n                //\n                // We use a specific rule for urls, because they don't really behave like\n                // standard function calls. The difference is that the argument doesn't have\n                // to be enclosed within a string, so it can't be parsed as an Expression.\n                //\n                url: function () {\n                    let value;\n                    const index = parserInput.i;\n\n                    parserInput.autoCommentAbsorb = false;\n\n                    if (!parserInput.$str('url(')) {\n                        parserInput.autoCommentAbsorb = true;\n                        return;\n                    }\n\n                    value = this.quoted() || this.variable() || this.property() ||\n                            parserInput.$re(/^(?:(?:\\\\[\\(\\)'\"])|[^\\(\\)'\"])+/) || '';\n\n                    parserInput.autoCommentAbsorb = true;\n\n                    expectChar(')');\n\n                    return new(tree.URL)((value.value != null || \n                        value instanceof tree.Variable || \n                        value instanceof tree.Property) ?\n                        value : new(tree.Anonymous)(value, index), index, fileInfo);\n                },\n\n                //\n                // A Variable entity, such as `@fink`, in\n                //\n                //     width: @fink + 2px\n                //\n                // We use a different parser for variable definitions,\n                // see `parsers.variable`.\n                //\n                variable: function () {\n                    let ch;\n                    let name;\n                    const index = parserInput.i;\n\n                    parserInput.save();\n                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\\w-]+/))) {\n                        ch = parserInput.currentChar();\n                        if (ch === '(' || ch === '[' && !parserInput.prevChar().match(/^\\s/)) {\n                            // this may be a VariableCall lookup\n                            const result = parsers.variableCall(name);\n                            if (result) {\n                                parserInput.forget();\n                                return result;\n                            }\n                        }\n                        parserInput.forget();\n                        return new(tree.Variable)(name, index, fileInfo);\n                    }\n                    parserInput.restore();\n                },\n\n                // A variable entity using the protective {} e.g. @{var}\n                variableCurly: function () {\n                    let curly;\n                    const index = parserInput.i;\n\n                    if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\\{([\\w-]+)\\}/))) {\n                        return new(tree.Variable)(`@${curly[1]}`, index, fileInfo);\n                    }\n                },\n                //\n                // A Property accessor, such as `$color`, in\n                //\n                //     background-color: $color\n                //\n                property: function () {\n                    let name;\n                    const index = parserInput.i;\n\n                    if (parserInput.currentChar() === '$' && (name = parserInput.$re(/^\\$[\\w-]+/))) {\n                        return new(tree.Property)(name, index, fileInfo);\n                    }\n                },\n\n                // A property entity useing the protective {} e.g. ${prop}\n                propertyCurly: function () {\n                    let curly;\n                    const index = parserInput.i;\n\n                    if (parserInput.currentChar() === '$' && (curly = parserInput.$re(/^\\$\\{([\\w-]+)\\}/))) {\n                        return new(tree.Property)(`$${curly[1]}`, index, fileInfo);\n                    }\n                },\n                //\n                // A Hexadecimal color\n                //\n                //     #4F3C2F\n                //\n                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.\n                //\n                color: function () {\n                    let rgb;\n                    parserInput.save();\n\n                    if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})([\\w.#\\[])?/))) {\n                        if (!rgb[2]) {\n                            parserInput.forget();\n                            return new(tree.Color)(rgb[1], undefined, rgb[0]);\n                        } \n                    }\n                    parserInput.restore();\n                },\n\n                colorKeyword: function () {\n                    parserInput.save();\n                    const autoCommentAbsorb = parserInput.autoCommentAbsorb;\n                    parserInput.autoCommentAbsorb = false;\n                    const k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);\n                    parserInput.autoCommentAbsorb = autoCommentAbsorb;\n                    if (!k) {\n                        parserInput.forget();\n                        return;\n                    }\n                    parserInput.restore();\n                    const color = tree.Color.fromKeyword(k);\n                    if (color) {\n                        parserInput.$str(k);\n                        return color;\n                    }\n                },\n\n                //\n                // A Dimension, that is, a number and a unit\n                //\n                //     0.5em 95%\n                //\n                dimension: function () {\n                    if (parserInput.peekNotNumeric()) {\n                        return;\n                    }\n\n                    const value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i);\n                    if (value) {\n                        return new(tree.Dimension)(value[1], value[2]);\n                    }\n                },\n\n                //\n                // A unicode descriptor, as is used in unicode-range\n                //\n                // U+0??  or U+00A1-00A9\n                //\n                unicodeDescriptor: function () {\n                    let ud;\n\n                    ud = parserInput.$re(/^U\\+[0-9a-fA-F?]+(\\-[0-9a-fA-F?]+)?/);\n                    if (ud) {\n                        return new(tree.UnicodeDescriptor)(ud[0]);\n                    }\n                },\n\n                //\n                // JavaScript code to be evaluated\n                //\n                //     `window.location.href`\n                //\n                javascript: function () {\n                    let js;\n                    const index = parserInput.i;\n\n                    parserInput.save();\n\n                    const escape = parserInput.$char('~');\n                    const jsQuote = parserInput.$char('`');\n\n                    if (!jsQuote) {\n                        parserInput.restore();\n                        return;\n                    }\n\n                    js = parserInput.$re(/^[^`]*`/);\n                    if (js) {\n                        parserInput.forget();\n                        return new(tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);\n                    }\n                    parserInput.restore('invalid javascript definition');\n                }\n            },\n\n            //\n            // The variable part of a variable definition. Used in the `rule` parser\n            //\n            //     @fink:\n            //\n            variable: function () {\n                let name;\n\n                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)\\s*:/))) { return name[1]; }\n            },\n\n            //\n            // Call a variable value to retrieve a detached ruleset\n            // or a value from a detached ruleset's rules.\n            //\n            //     @fink();\n            //     @fink;\n            //     color: @fink[@color];\n            //\n            variableCall: function (parsedName) {\n                let lookups;\n                const i = parserInput.i;\n                const inValue = !!parsedName;\n                let name = parsedName;\n\n                parserInput.save();\n\n                if (name || (parserInput.currentChar() === '@'\n                    && (name = parserInput.$re(/^(@[\\w-]+)(\\(\\s*\\))?/)))) {\n\n                    lookups = this.mixin.ruleLookups();\n\n                    if (!lookups && ((inValue && parserInput.$str('()') !== '()') || (name[2] !== '()'))) {\n                        parserInput.restore('Missing \\'[...]\\' lookup in variable call');\n                        return;\n                    }\n\n                    if (!inValue) {\n                        name = name[1];\n                    }\n\n                    const call = new tree.VariableCall(name, i, fileInfo);\n                    if (!inValue && parsers.end()) {\n                        parserInput.forget();\n                        return call;\n                    }\n                    else {\n                        parserInput.forget();\n                        return new tree.NamespaceValue(call, lookups, i, fileInfo);\n                    }\n                }\n\n                parserInput.restore();\n            },\n\n            //\n            // extend syntax - used to extend selectors\n            //\n            extend: function(isRule) {\n                let elements;\n                let e;\n                const index = parserInput.i;\n                let option;\n                let extendList;\n                let extend;\n\n                if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {\n                    return;\n                }\n\n                do {\n                    option = null;\n                    elements = null;\n                    while (!(option = parserInput.$re(/^(all)(?=\\s*(\\)|,))/))) {\n                        e = this.element();\n                        if (!e) {\n                            break;\n                        }\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [ e ];\n                        }\n                    }\n\n                    option = option && option[1];\n                    if (!elements) {\n                        error('Missing target selector for :extend().');\n                    }\n                    extend = new(tree.Extend)(new(tree.Selector)(elements), option, index, fileInfo);\n                    if (extendList) {\n                        extendList.push(extend);\n                    } else {\n                        extendList = [ extend ];\n                    }\n                } while (parserInput.$char(','));\n\n                expect(/^\\)/);\n\n                if (isRule) {\n                    expect(/^;/);\n                }\n\n                return extendList;\n            },\n\n            //\n            // extendRule - used in a rule to extend all the parent selectors\n            //\n            extendRule: function() {\n                return this.extend(true);\n            },\n\n            //\n            // Mixins\n            //\n            mixin: {\n                //\n                // A Mixin call, with an optional argument list\n                //\n                //     #mixins > .square(#fff);\n                //     #mixins.square(#fff);\n                //     .rounded(4px, black);\n                //     .button;\n                //\n                // We can lookup / return a value using the lookup syntax:\n                //\n                //     color: #mixin.square(#fff)[@color];\n                //\n                // The `while` loop is there because mixins can be\n                // namespaced, but we only support the child and descendant\n                // selector for now.\n                //\n                call: function (inValue, getLookup) {\n                    const s = parserInput.currentChar();\n                    let important = false;\n                    let lookups;\n                    const index = parserInput.i;\n                    let elements;\n                    let args;\n                    let hasParens;\n\n                    if (s !== '.' && s !== '#') { return; }\n\n                    parserInput.save(); // stop us absorbing part of an invalid selector\n\n                    elements = this.elements();\n\n                    if (elements) {\n                        if (parserInput.$char('(')) {\n                            args = this.args(true).args;\n                            expectChar(')');\n                            hasParens = true;\n                        }\n\n                        if (getLookup !== false) {\n                            lookups = this.ruleLookups();\n                        }\n                        if (getLookup === true && !lookups) {\n                            parserInput.restore();\n                            return;\n                        }\n\n                        if (inValue && !lookups && !hasParens) {\n                            // This isn't a valid in-value mixin call\n                            parserInput.restore();\n                            return;\n                        }\n\n                        if (!inValue && parsers.important()) {\n                            important = true;\n                        }\n\n                        if (inValue || parsers.end()) {\n                            parserInput.forget();\n                            const mixin = new(tree.mixin.Call)(elements, args, index, fileInfo, !lookups && important);\n                            if (lookups) {\n                                return new tree.NamespaceValue(mixin, lookups);\n                            }\n                            else {\n                                return mixin;\n                            }\n                        }\n                    }\n\n                    parserInput.restore();\n                },\n                /**\n                 * Matching elements for mixins\n                 * (Start with . or # and can have > )\n                 */\n                elements: function() {\n                    let elements;\n                    let e;\n                    let c;\n                    let elem;\n                    let elemIndex;\n                    const re = /^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;\n                    while (true) {\n                        elemIndex = parserInput.i;\n                        e = parserInput.$re(re);\n                        \n                        if (!e) {\n                            break;\n                        }\n                        elem = new(tree.Element)(c, e, false, elemIndex, fileInfo);\n                        if (elements) {\n                            elements.push(elem);\n                        } else {\n                            elements = [ elem ];\n                        }\n                        c = parserInput.$char('>');\n                    }\n                    return elements;\n                },\n                args: function (isCall) {\n                    const entities = parsers.entities;\n                    const returner = { args:null, variadic: false };\n                    let expressions = [];\n                    const argsSemiColon = [];\n                    const argsComma = [];\n                    let isSemiColonSeparated;\n                    let expressionContainsNamed;\n                    let name;\n                    let nameLoop;\n                    let value;\n                    let arg;\n                    let expand;\n                    let hasSep = true;\n\n                    parserInput.save();\n\n                    while (true) {\n                        if (isCall) {\n                            arg = parsers.detachedRuleset() || parsers.expression();\n                        } else {\n                            parserInput.commentStore.length = 0;\n                            if (parserInput.$str('...')) {\n                                returner.variadic = true;\n                                if (parserInput.$char(';') && !isSemiColonSeparated) {\n                                    isSemiColonSeparated = true;\n                                }\n                                (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                    .push({ variadic: true });\n                                break;\n                            }\n                            arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);\n                        }\n\n                        if (!arg || !hasSep) {\n                            break;\n                        }\n\n                        nameLoop = null;\n                        if (arg.throwAwayComments) {\n                            arg.throwAwayComments();\n                        }\n                        value = arg;\n                        let val = null;\n\n                        if (isCall) {\n                            // Variable\n                            if (arg.value && arg.value.length == 1) {\n                                val = arg.value[0];\n                            }\n                        } else {\n                            val = arg;\n                        }\n\n                        if (val && (val instanceof tree.Variable || val instanceof tree.Property)) {\n                            if (parserInput.$char(':')) {\n                                if (expressions.length > 0) {\n                                    if (isSemiColonSeparated) {\n                                        error('Cannot mix ; and , as delimiter types');\n                                    }\n                                    expressionContainsNamed = true;\n                                }\n\n                                value = parsers.detachedRuleset() || parsers.expression();\n\n                                if (!value) {\n                                    if (isCall) {\n                                        error('could not understand value for named argument');\n                                    } else {\n                                        parserInput.restore();\n                                        returner.args = [];\n                                        return returner;\n                                    }\n                                }\n                                nameLoop = (name = val.name);\n                            } else if (parserInput.$str('...')) {\n                                if (!isCall) {\n                                    returner.variadic = true;\n                                    if (parserInput.$char(';') && !isSemiColonSeparated) {\n                                        isSemiColonSeparated = true;\n                                    }\n                                    (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                        .push({ name: arg.name, variadic: true });\n                                    break;\n                                } else {\n                                    expand = true;\n                                }\n                            } else if (!isCall) {\n                                name = nameLoop = val.name;\n                                value = null;\n                            }\n                        }\n\n                        if (value) {\n                            expressions.push(value);\n                        }\n\n                        argsComma.push({ name:nameLoop, value, expand });\n\n                        if (parserInput.$char(',')) {\n                            hasSep = true;\n                            continue;\n                        }\n                        hasSep = parserInput.$char(';') === ';';\n\n                        if (hasSep || isSemiColonSeparated) {\n\n                            if (expressionContainsNamed) {\n                                error('Cannot mix ; and , as delimiter types');\n                            }\n\n                            isSemiColonSeparated = true;\n\n                            if (expressions.length > 1) {\n                                value = new(tree.Value)(expressions);\n                            }\n                            argsSemiColon.push({ name, value, expand });\n\n                            name = null;\n                            expressions = [];\n                            expressionContainsNamed = false;\n                        }\n                    }\n\n                    parserInput.forget();\n                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;\n                    return returner;\n                },\n                //\n                // A Mixin definition, with a list of parameters\n                //\n                //     .rounded (@radius: 2px, @color) {\n                //        ...\n                //     }\n                //\n                // Until we have a finer grained state-machine, we have to\n                // do a look-ahead, to make sure we don't have a mixin call.\n                // See the `rule` function for more information.\n                //\n                // We start by matching `.rounded (`, and then proceed on to\n                // the argument list, which has optional default values.\n                // We store the parameters in `params`, with a `value` key,\n                // if there is a value, such as in the case of `@radius`.\n                //\n                // Once we've got our params list, and a closing `)`, we parse\n                // the `{...}` block.\n                //\n                definition: function () {\n                    let name;\n                    let params = [];\n                    let match;\n                    let ruleset;\n                    let cond;\n                    let variadic = false;\n                    if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||\n                        parserInput.peek(/^[^{]*\\}/)) {\n                        return;\n                    }\n\n                    parserInput.save();\n\n                    match = parserInput.$re(/^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/);\n                    if (match) {\n                        name = match[1];\n\n                        const argInfo = this.args(false);\n                        params = argInfo.args;\n                        variadic = argInfo.variadic;\n\n                        // .mixincall(\"@{a}\");\n                        // looks a bit like a mixin definition..\n                        // also\n                        // .mixincall(@a: {rule: set;});\n                        // so we have to be nice and restore\n                        if (!parserInput.$char(')')) {\n                            parserInput.restore('Missing closing \\')\\'');\n                            return;\n                        }\n\n                        parserInput.commentStore.length = 0;\n\n                        if (parserInput.$str('when')) { // Guard\n                            cond = expect(parsers.conditions, 'expected condition');\n                        }\n\n                        ruleset = parsers.block();\n\n                        if (ruleset) {\n                            parserInput.forget();\n                            return new(tree.mixin.Definition)(name, params, ruleset, cond, variadic);\n                        } else {\n                            parserInput.restore();\n                        }\n                    } else {\n                        parserInput.restore();\n                    }\n                },\n            \n                ruleLookups: function() {\n                    let rule;\n                    let args;\n                    const lookups = [];\n\n                    if (parserInput.currentChar() !== '[') { \n                        return;\n                    }\n\n                    while (true) {\n                        parserInput.save();\n                        args = null;\n                        rule = this.lookupValue();\n                        if (!rule && rule !== '') {\n                            parserInput.restore();\n                            break;\n                        }\n                        lookups.push(rule);\n                        parserInput.forget();\n                    }\n                    if (lookups.length > 0) {\n                        return lookups;\n                    }\n                },\n    \n                lookupValue: function() {\n                    parserInput.save();\n    \n                    if (!parserInput.$char('[')) { \n                        parserInput.restore();\n                        return;\n                    }\n    \n                    const name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);\n    \n                    if (!parserInput.$char(']')) {\n                        parserInput.restore();\n                        return;\n                    } \n\n                    if (name || name === '') {\n                        parserInput.forget();\n                        return name;\n                    }\n    \n                    parserInput.restore();\n                }\n            },\n            //\n            // Entities are the smallest recognized token,\n            // and can be found inside a rule's value.\n            //\n            entity: function () {\n                const entities = this.entities;\n\n                return this.comment() || entities.literal() || entities.variable() || entities.url() ||\n                    entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) ||\n                    entities.javascript();\n            },\n\n            //\n            // A Declaration terminator. Note that we use `peek()` to check for '}',\n            // because the `block` rule will be expecting it, but we still need to make sure\n            // it's there, if ';' was omitted.\n            //\n            end: function () {\n                return parserInput.$char(';') || parserInput.peek('}');\n            },\n\n            //\n            // IE's alpha function\n            //\n            //     alpha(opacity=88)\n            //\n            ieAlpha: function () {\n                let value;\n\n                // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                if (!parserInput.$re(/^opacity=/i)) { return; }\n                value = parserInput.$re(/^\\d+/);\n                if (!value) {\n                    value = expect(parsers.entities.variable, 'Could not parse alpha');\n                    value = `@{${value.name.slice(1)}}`;\n                }\n                expectChar(')');\n                return new tree.Quoted('', `alpha(opacity=${value})`);\n            },\n\n            //\n            // A Selector Element\n            //\n            //     div\n            //     + h1\n            //     #socks\n            //     input[type=\"text\"]\n            //\n            // Elements are the building blocks for Selectors,\n            // they are made out of a `Combinator` (see combinator rule),\n            // and an element name, such as a tag a class, or `*`.\n            //\n            element: function () {\n                let e;\n                let c;\n                let v;\n                const index = parserInput.i;\n\n                c = this.combinator();\n\n                e = parserInput.$re(/^(?:\\d+\\.\\d+|\\d+)%/) ||\n                    parserInput.$re(/^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||\n                    parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||\n                    parserInput.$re(/^\\([^&()@]+\\)/) ||  parserInput.$re(/^[\\.#:](?=@)/) ||\n                    this.entities.variableCurly();\n\n                if (!e) {\n                    parserInput.save();\n                    if (parserInput.$char('(')) {\n                        if ((v = this.selector(false)) && parserInput.$char(')')) {\n                            e = new(tree.Paren)(v);\n                            parserInput.forget();\n                        } else {\n                            parserInput.restore('Missing closing \\')\\'');\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                }\n\n                if (e) { return new(tree.Element)(c, e, e instanceof tree.Variable, index, fileInfo); }\n            },\n\n            //\n            // Combinators combine elements together, in a Selector.\n            //\n            // Because our parser isn't white-space sensitive, special care\n            // has to be taken, when parsing the descendant combinator, ` `,\n            // as it's an empty space. We have to check the previous character\n            // in the input, to see if it's a ` ` character. More info on how\n            // we deal with this in *combinator.js*.\n            //\n            combinator: function () {\n                let c = parserInput.currentChar();\n\n                if (c === '/') {\n                    parserInput.save();\n                    const slashedCombinator = parserInput.$re(/^\\/[a-z]+\\//i);\n                    if (slashedCombinator) {\n                        parserInput.forget();\n                        return new(tree.Combinator)(slashedCombinator);\n                    }\n                    parserInput.restore();\n                }\n\n                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {\n                    parserInput.i++;\n                    if (c === '^' && parserInput.currentChar() === '^') {\n                        c = '^^';\n                        parserInput.i++;\n                    }\n                    while (parserInput.isWhitespace()) { parserInput.i++; }\n                    return new(tree.Combinator)(c);\n                } else if (parserInput.isWhitespace(-1)) {\n                    return new(tree.Combinator)(' ');\n                } else {\n                    return new(tree.Combinator)(null);\n                }\n            },\n            //\n            // A CSS Selector\n            // with less extensions e.g. the ability to extend and guard\n            //\n            //     .class > div + h1\n            //     li a:hover\n            //\n            // Selectors are made out of one or more Elements, see above.\n            //\n            selector: function (isLess) {\n                const index = parserInput.i;\n                let elements;\n                let extendList;\n                let c;\n                let e;\n                let allExtends;\n                let when;\n                let condition;\n                isLess = isLess !== false;\n                while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str('when'))) || (e = this.element())) {\n                    if (when) {\n                        condition = expect(this.conditions, 'expected condition');\n                    } else if (condition) {\n                        error('CSS guard can only be used at the end of selector');\n                    } else if (extendList) {\n                        if (allExtends) {\n                            allExtends = allExtends.concat(extendList);\n                        } else {\n                            allExtends = extendList;\n                        }\n                    } else {\n                        if (allExtends) { error('Extend can only be used at the end of selector'); }\n                        c = parserInput.currentChar();\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [ e ];\n                        }\n                        e = null;\n                    }\n                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {\n                        break;\n                    }\n                }\n\n                if (elements) { return new(tree.Selector)(elements, allExtends, condition, index, fileInfo); }\n                if (allExtends) { error('Extend must be used to extend a selector, it cannot be used on its own'); }\n            },\n            selectors: function () {\n                let s;\n                let selectors;\n                while (true) {\n                    s = this.selector();\n                    if (!s) {\n                        break;\n                    }\n                    if (selectors) {\n                        selectors.push(s);\n                    } else {\n                        selectors = [ s ];\n                    }\n                    parserInput.commentStore.length = 0;\n                    if (s.condition && selectors.length > 1) {\n                        error(\"Guards are only currently allowed on a single selector.\");\n                    }\n                    if (!parserInput.$char(',')) { break; }\n                    if (s.condition) {\n                        error(\"Guards are only currently allowed on a single selector.\");\n                    }\n                    parserInput.commentStore.length = 0;\n                }\n                return selectors;\n            },\n            attribute: function () {\n                if (!parserInput.$char('[')) { return; }\n\n                const entities = this.entities;\n                let key;\n                let val;\n                let op;\n\n                if (!(key = entities.variableCurly())) {\n                    key = expect(/^(?:[_A-Za-z0-9-\\*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/);\n                }\n\n                op = parserInput.$re(/^[|~*$^]?=/);\n                if (op) {\n                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\\w-]+/) || entities.variableCurly();\n                }\n\n                expectChar(']');\n\n                return new(tree.Attribute)(key, op, val);\n            },\n\n            //\n            // The `block` rule is used by `ruleset` and `mixin.definition`.\n            // It's a wrapper around the `primary` rule, with added `{}`.\n            //\n            block: function () {\n                let content;\n                if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {\n                    return content;\n                }\n            },\n\n            blockRuleset: function() {\n                let block = this.block();\n\n                if (block) {\n                    block = new tree.Ruleset(null, block);\n                }\n                return block;\n            },\n\n            detachedRuleset: function() {\n                let argInfo;\n                let params;\n                let variadic;\n\n                parserInput.save();\n                if (parserInput.$re(/^[.#]\\(/)) {\n                    /**\n                     * DR args currently only implemented for each() function, and not \n                     * yet settable as `@dr: #(@arg) {}`\n                     * This should be done when DRs are merged with mixins.\n                     * See: https://github.com/less/less-meta/issues/16\n                     */\n                    argInfo = this.mixin.args(false);\n                    params = argInfo.args;\n                    variadic = argInfo.variadic;\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return;\n                    }\n                }\n                const blockRuleset = this.blockRuleset();\n                if (blockRuleset) {\n                    parserInput.forget();\n                    if (params) {\n                        return new tree.mixin.Definition(null, params, blockRuleset, null, variadic);\n                    }\n                    return new tree.DetachedRuleset(blockRuleset);\n                }\n                parserInput.restore();\n            },\n\n            //\n            // div, .class, body > p {...}\n            //\n            ruleset: function () {\n                let selectors;\n                let rules;\n                let debugInfo;\n\n                parserInput.save();\n\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(parserInput.i);\n                }\n\n                selectors = this.selectors();\n\n                if (selectors && (rules = this.block())) {\n                    parserInput.forget();\n                    const ruleset = new(tree.Ruleset)(selectors, rules, context.strictImports);\n                    if (context.dumpLineNumbers) {\n                        ruleset.debugInfo = debugInfo;\n                    }\n                    return ruleset;\n                } else {\n                    parserInput.restore();\n                }\n            },\n            declaration: function () {\n                let name;\n                let value;\n                const index = parserInput.i;\n                let hasDR;\n                const c = parserInput.currentChar();\n                let important;\n                let merge;\n                let isVariable;\n\n                if (c === '.' || c === '#' || c === '&' || c === ':') { return; }\n\n                parserInput.save();\n\n                name = this.variable() || this.ruleProperty();\n                if (name) {\n                    isVariable = typeof name === 'string';\n\n                    if (isVariable) {\n                        value = this.detachedRuleset();\n                        if (value) {\n                            hasDR = true;\n                        }\n                    }\n\n                    parserInput.commentStore.length = 0;\n                    if (!value) {\n                        // a name returned by this.ruleProperty() is always an array of the form:\n                        // [string-1, ..., string-n, \"\"] or [string-1, ..., string-n, \"+\"]\n                        // where each item is a tree.Keyword or tree.Variable\n                        merge = !isVariable && name.length > 1 && name.pop().value;\n\n                        // Custom property values get permissive parsing\n                        if (name[0].value && name[0].value.slice(0, 2) === '--') {\n                            value = this.permissiveValue();\n                        }\n                        // Try to store values as anonymous\n                        // If we need the value later we'll re-parse it in ruleset.parseValue\n                        else {\n                            value = this.anonymousValue();\n                        }\n                        if (value) {\n                            parserInput.forget();\n                            // anonymous values absorb the end ';' which is required for them to work\n                            return new(tree.Declaration)(name, value, false, merge, index, fileInfo);\n                        }\n\n                        if (!value) {\n                            value = this.value();\n                        }\n\n                        if (value) {\n                            important = this.important();\n                        } else if (isVariable) {\n                            // As a last resort, try permissiveValue\n                            value = this.permissiveValue();\n                        }\n                    }\n\n                    if (value && (this.end() || hasDR)) {\n                        parserInput.forget();\n                        return new(tree.Declaration)(name, value, important, merge, index, fileInfo);\n                    }\n                    else {\n                        parserInput.restore();\n                    }\n                } else {\n                    parserInput.restore();\n                }\n            },\n            anonymousValue: function () {\n                const index = parserInput.i;\n                const match = parserInput.$re(/^([^.#@\\$+\\/'\"*`(;{}-]*);/);\n                if (match) {\n                    return new(tree.Anonymous)(match[1], index);\n                }\n            },\n            /**\n             * Used for custom properties, at-rules, and variables (as fallback)\n             * Parses almost anything inside of {} [] () \"\" blocks\n             * until it reaches outer-most tokens.\n             * \n             * First, it will try to parse comments and entities to reach\n             * the end. This is mostly like the Expression parser except no\n             * math is allowed.\n             */\n            permissiveValue: function (untilTokens) {\n                let i;\n                let e;\n                let done;\n                let value;\n                const tok = untilTokens || ';';\n                const index = parserInput.i;\n                const result = [];\n\n                function testCurrentChar() {\n                    const char = parserInput.currentChar();\n                    if (typeof tok === 'string') {\n                        return char === tok;\n                    } else {\n                        return tok.test(char);\n                    }\n                }\n                if (testCurrentChar()) {\n                    return;\n                }\n                value = [];\n                do {\n                    e = this.comment();\n                    if (e) {\n                        value.push(e);\n                        continue;\n                    }\n                    e = this.entity();\n                    if (e) {\n                        value.push(e);\n                    }\n                } while (e);\n\n                done = testCurrentChar();\n\n                if (value.length > 0) {\n                    value = new(tree.Expression)(value);\n                    if (done) {\n                        return value;\n                    }\n                    else {\n                        result.push(value);\n                    }\n                    // Preserve space before $parseUntil as it will not\n                    if (parserInput.prevChar() === ' ') {\n                        result.push(new tree.Anonymous(' ', index));\n                    }\n                }\n                parserInput.save();\n\n                value = parserInput.$parseUntil(tok);\n\n                if (value) {\n                    if (typeof value === 'string') {\n                        error(`Expected '${value}'`, 'Parse');\n                    }\n                    if (value.length === 1 && value[0] === ' ') {\n                        parserInput.forget();\n                        return new tree.Anonymous('', index);\n                    }\n                    let item;\n                    for (i = 0; i < value.length; i++) {\n                        item = value[i];\n                        if (Array.isArray(item)) {\n                            // Treat actual quotes as normal quoted values\n                            result.push(new tree.Quoted(item[0], item[1], true, index, fileInfo));\n                        }\n                        else {\n                            if (i === value.length - 1) {\n                                item = item.trim();\n                            }\n                            // Treat like quoted values, but replace vars like unquoted expressions\n                            const quote = new tree.Quoted('\\'', item, true, index, fileInfo);\n                            quote.variableRegex = /@([\\w-]+)/g;\n                            quote.propRegex = /\\$([\\w-]+)/g;\n                            result.push(quote);\n                        }\n                    }\n                    parserInput.forget();\n                    return new tree.Expression(result, true);\n                }\n                parserInput.restore();\n            },\n\n            //\n            // An @import atrule\n            //\n            //     @import \"lib\";\n            //\n            // Depending on our environment, importing is done differently:\n            // In the browser, it's an XHR request, in Node, it would be a\n            // file-system operation. The function used for importing is\n            // stored in `import`, which we pass to the Import constructor.\n            //\n            'import': function () {\n                let path;\n                let features;\n                const index = parserInput.i;\n\n                const dir = parserInput.$re(/^@import?\\s+/);\n\n                if (dir) {\n                    const options = (dir ? this.importOptions() : null) || {};\n\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n                        features = this.mediaFeatures();\n\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error('missing semi-colon or unrecognised media features on import');\n                        }\n                        features = features && new(tree.Value)(features);\n                        return new(tree.Import)(path, features, options, index, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error('malformed import statement');\n                    }\n                }\n            },\n\n            importOptions: function() {\n                let o;\n                const options = {};\n                let optionName;\n                let value;\n\n                // list of options, surrounded by parens\n                if (!parserInput.$char('(')) { return null; }\n                do {\n                    o = this.importOption();\n                    if (o) {\n                        optionName = o;\n                        value = true;\n                        switch (optionName) {\n                            case 'css':\n                                optionName = 'less';\n                                value = false;\n                                break;\n                            case 'once':\n                                optionName = 'multiple';\n                                value = false;\n                                break;\n                        }\n                        options[optionName] = value;\n                        if (!parserInput.$char(',')) { break; }\n                    }\n                } while (o);\n                expectChar(')');\n                return options;\n            },\n\n            importOption: function() {\n                const opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);\n                if (opt) {\n                    return opt[1];\n                }\n            },\n\n            mediaFeature: function () {\n                const entities = this.entities;\n                const nodes = [];\n                let e;\n                let p;\n                parserInput.save();\n                do {\n                    e = entities.keyword() || entities.variable() || entities.mixinLookup();\n                    if (e) {\n                        nodes.push(e);\n                    } else if (parserInput.$char('(')) {\n                        p = this.property();\n                        e = this.value();\n                        if (parserInput.$char(')')) {\n                            if (p && e) {\n                                nodes.push(new(tree.Paren)(new(tree.Declaration)(p, e, null, null, parserInput.i, fileInfo, true)));\n                            } else if (e) {\n                                nodes.push(new(tree.Paren)(e));\n                            } else {\n                                error('badly formed media feature definition');\n                            }\n                        } else {\n                            error('Missing closing \\')\\'', 'Parse');\n                        }\n                    }\n                } while (e);\n\n                parserInput.forget();\n                if (nodes.length > 0) {\n                    return new(tree.Expression)(nodes);\n                }\n            },\n\n            mediaFeatures: function () {\n                const entities = this.entities;\n                const features = [];\n                let e;\n                do {\n                    e = this.mediaFeature();\n                    if (e) {\n                        features.push(e);\n                        if (!parserInput.$char(',')) { break; }\n                    } else {\n                        e = entities.variable() || entities.mixinLookup();\n                        if (e) {\n                            features.push(e);\n                            if (!parserInput.$char(',')) { break; }\n                        }\n                    }\n                } while (e);\n\n                return features.length > 0 ? features : null;\n            },\n\n            media: function () {\n                let features;\n                let rules;\n                let media;\n                let debugInfo;\n                const index = parserInput.i;\n\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(index);\n                }\n\n                parserInput.save();\n\n                if (parserInput.$str('@media')) {\n                    features = this.mediaFeatures();\n\n                    rules = this.block();\n\n                    if (!rules) {\n                        error('media definitions require block statements after any features');\n                    }\n\n                    parserInput.forget();\n\n                    media = new(tree.Media)(rules, features, index, fileInfo);\n                    if (context.dumpLineNumbers) {\n                        media.debugInfo = debugInfo;\n                    }\n\n                    return media;\n                }\n\n                parserInput.restore();\n            },\n\n            //\n\n            // A @plugin directive, used to import plugins dynamically.\n            //\n            //     @plugin (args) \"lib\";\n            //\n            plugin: function () {\n                let path;\n                let args;\n                let options;\n                const index = parserInput.i;\n                const dir   = parserInput.$re(/^@plugin?\\s+/);\n\n                if (dir) {\n                    args = this.pluginArgs();\n\n                    if (args) {\n                        options = {\n                            pluginArgs: args,\n                            isPlugin: true\n                        };\n                    }\n                    else {\n                        options = { isPlugin: true };\n                    }\n\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error('missing semi-colon on @plugin');\n                        }\n                        return new(tree.Import)(path, null, options, index, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error('malformed @plugin statement');\n                    }\n                }\n            },\n\n            pluginArgs: function() {\n                // list of options, surrounded by parens\n                parserInput.save();\n                if (!parserInput.$char('(')) {\n                    parserInput.restore();\n                    return null;\n                }\n                const args = parserInput.$re(/^\\s*([^\\);]+)\\)\\s*/);\n                if (args[1]) {\n                    parserInput.forget();\n                    return args[1].trim();\n                }\n                else { \n                    parserInput.restore();\n                    return null;\n                }\n            },\n\n            //\n            // A CSS AtRule\n            //\n            //     @charset \"utf-8\";\n            //\n            atrule: function () {\n                const index = parserInput.i;\n                let name;\n                let value;\n                let rules;\n                let nonVendorSpecificName;\n                let hasIdentifier;\n                let hasExpression;\n                let hasUnknown;\n                let hasBlock = true;\n                let isRooted = true;\n\n                if (parserInput.currentChar() !== '@') { return; }\n\n                value = this['import']() || this.plugin() || this.media();\n                if (value) {\n                    return value;\n                }\n\n                parserInput.save();\n\n                name = parserInput.$re(/^@[a-z-]+/);\n\n                if (!name) { return; }\n\n                nonVendorSpecificName = name;\n                if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {\n                    nonVendorSpecificName = `@${name.slice(name.indexOf('-', 2) + 1)}`;\n                }\n\n                switch (nonVendorSpecificName) {\n                    case '@charset':\n                        hasIdentifier = true;\n                        hasBlock = false;\n                        break;\n                    case '@namespace':\n                        hasExpression = true;\n                        hasBlock = false;\n                        break;\n                    case '@keyframes':\n                    case '@counter-style':\n                        hasIdentifier = true;\n                        break;\n                    case '@document':\n                    case '@supports':\n                        hasUnknown = true;\n                        isRooted = false;\n                        break;\n                    default:\n                        hasUnknown = true;\n                        break;\n                }\n\n                parserInput.commentStore.length = 0;\n\n                if (hasIdentifier) {\n                    value = this.entity();\n                    if (!value) {\n                        error(`expected ${name} identifier`);\n                    }\n                } else if (hasExpression) {\n                    value = this.expression();\n                    if (!value) {\n                        error(`expected ${name} expression`);\n                    }\n                } else if (hasUnknown) {\n                    value = this.permissiveValue(/^[{;]/);\n                    hasBlock = (parserInput.currentChar() === '{');\n                    if (!value) {\n                        if (!hasBlock && parserInput.currentChar() !== ';') {\n                            error(`${name} rule is missing block or ending semi-colon`);\n                        }\n                    }\n                    else if (!value.value) {\n                        value = null;\n                    }\n                }\n\n                if (hasBlock) {\n                    rules = this.blockRuleset();\n                }\n\n                if (rules || (!hasBlock && value && parserInput.$char(';'))) {\n                    parserInput.forget();\n                    return new(tree.AtRule)(name, value, rules, index, fileInfo,\n                        context.dumpLineNumbers ? getDebugInfo(index) : null,\n                        isRooted\n                    );\n                }\n\n                parserInput.restore('at-rule options not recognised');\n            },\n\n            //\n            // A Value is a comma-delimited list of Expressions\n            //\n            //     font-family: Baskerville, Georgia, serif;\n            //\n            // In a Rule, a Value represents everything after the `:`,\n            // and before the `;`.\n            //\n            value: function () {\n                let e;\n                const expressions = [];\n                const index = parserInput.i;\n\n                do {\n                    e = this.expression();\n                    if (e) {\n                        expressions.push(e);\n                        if (!parserInput.$char(',')) { break; }\n                    }\n                } while (e);\n\n                if (expressions.length > 0) {\n                    return new(tree.Value)(expressions, index);\n                }\n            },\n            important: function () {\n                if (parserInput.currentChar() === '!') {\n                    return parserInput.$re(/^! *important/);\n                }\n            },\n            sub: function () {\n                let a;\n                let e;\n\n                parserInput.save();\n                if (parserInput.$char('(')) {\n                    a = this.addition();\n                    if (a && parserInput.$char(')')) {\n                        parserInput.forget();\n                        e = new(tree.Expression)([a]);\n                        e.parens = true;\n                        return e;\n                    }\n                    parserInput.restore('Expected \\')\\'');\n                    return;\n                }\n                parserInput.restore();\n            },\n            multiplication: function () {\n                let m;\n                let a;\n                let op;\n                let operation;\n                let isSpaced;\n                m = this.operand();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        if (parserInput.peek(/^\\/[*\\/]/)) {\n                            break;\n                        }\n\n                        parserInput.save();\n\n                        op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');\n\n                        if (!op) { parserInput.forget(); break; }\n\n                        a = this.operand();\n\n                        if (!a) { parserInput.restore(); break; }\n                        parserInput.forget();\n\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            addition: function () {\n                let m;\n                let a;\n                let op;\n                let operation;\n                let isSpaced;\n                m = this.multiplication();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        op = parserInput.$re(/^[-+]\\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));\n                        if (!op) {\n                            break;\n                        }\n                        a = this.multiplication();\n                        if (!a) {\n                            break;\n                        }\n\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            conditions: function () {\n                let a;\n                let b;\n                const index = parserInput.i;\n                let condition;\n\n                a = this.condition(true);\n                if (a) {\n                    while (true) {\n                        if (!parserInput.peek(/^,\\s*(not\\s*)?\\(/) || !parserInput.$char(',')) {\n                            break;\n                        }\n                        b = this.condition(true);\n                        if (!b) {\n                            break;\n                        }\n                        condition = new(tree.Condition)('or', condition || a, b, index);\n                    }\n                    return condition || a;\n                }\n            },\n            condition: function (needsParens) {\n                let result;\n                let logical;\n                let next;\n                function or() {\n                    return parserInput.$str('or');\n                }\n\n                result = this.conditionAnd(needsParens);\n                if (!result) {\n                    return ;\n                }\n                logical = or();\n                if (logical) {\n                    next = this.condition(needsParens);\n                    if (next) {\n                        result = new(tree.Condition)(logical, result, next);\n                    } else {\n                        return ;\n                    }\n                }\n                return result;\n            },\n            conditionAnd: function (needsParens) {\n                let result;\n                let logical;\n                let next;\n                const self = this;\n                function insideCondition() {\n                    const cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);\n                    if (!cond && !needsParens) {\n                        return self.atomicCondition(needsParens);\n                    }\n                    return cond;\n                }\n                function and() {\n                    return parserInput.$str('and');\n                }\n\n                result = insideCondition();\n                if (!result) {\n                    return ;\n                }\n                logical = and();\n                if (logical) {\n                    next = this.conditionAnd(needsParens);\n                    if (next) {\n                        result = new(tree.Condition)(logical, result, next);\n                    } else {\n                        return ;\n                    }\n                }\n                return result;\n            },\n            negatedCondition: function (needsParens) {\n                if (parserInput.$str('not')) {\n                    const result = this.parenthesisCondition(needsParens);\n                    if (result) {\n                        result.negate = !result.negate;\n                    }\n                    return result;\n                }\n            },\n            parenthesisCondition: function (needsParens) {\n                function tryConditionFollowedByParenthesis(me) {\n                    let body;\n                    parserInput.save();\n                    body = me.condition(needsParens);\n                    if (!body) {\n                        parserInput.restore();\n                        return ;\n                    }\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return ;\n                    }\n                    parserInput.forget();\n                    return body;\n                }\n\n                let body;\n                parserInput.save();\n                if (!parserInput.$str('(')) {\n                    parserInput.restore();\n                    return ;\n                }\n                body = tryConditionFollowedByParenthesis(this);\n                if (body) {\n                    parserInput.forget();\n                    return body;\n                }\n\n                body = this.atomicCondition(needsParens);\n                if (!body) {\n                    parserInput.restore();\n                    return ;\n                }\n                if (!parserInput.$char(')')) {\n                    parserInput.restore(`expected ')' got '${parserInput.currentChar()}'`);\n                    return ;\n                }\n                parserInput.forget();\n                return body;\n            },\n            atomicCondition: function (needsParens) {\n                const entities = this.entities;\n                const index = parserInput.i;\n                let a;\n                let b;\n                let c;\n                let op;\n\n                function cond() {\n                    return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();\n                }\n                cond = cond.bind(this);\n\n                a = cond();\n                if (a) {\n                    if (parserInput.$char('>')) {\n                        if (parserInput.$char('=')) {\n                            op = '>=';\n                        } else {\n                            op = '>';\n                        }\n                    } else\n                    if (parserInput.$char('<')) {\n                        if (parserInput.$char('=')) {\n                            op = '<=';\n                        } else {\n                            op = '<';\n                        }\n                    } else\n                    if (parserInput.$char('=')) {\n                        if (parserInput.$char('>')) {\n                            op = '=>';\n                        } else if (parserInput.$char('<')) {\n                            op = '=<';\n                        } else {\n                            op = '=';\n                        }\n                    }\n                    if (op) {\n                        b = cond();\n                        if (b) {\n                            c = new(tree.Condition)(op, a, b, index, false);\n                        } else {\n                            error('expected expression');\n                        }\n                    } else {\n                        c = new(tree.Condition)('=', a, new(tree.Keyword)('true'), index, false);\n                    }\n                    return c;\n                }\n            },\n\n            //\n            // An operand is anything that can be part of an operation,\n            // such as a Color, or a Variable\n            //\n            operand: function () {\n                const entities = this.entities;\n                let negate;\n\n                if (parserInput.peek(/^-[@\\$\\(]/)) {\n                    negate = parserInput.$char('-');\n                }\n\n                let o = this.sub() || entities.dimension() ||\n                        entities.color() || entities.variable() ||\n                        entities.property() || entities.call() ||\n                        entities.quoted(true) || entities.colorKeyword() ||\n                        entities.mixinLookup();\n\n                if (negate) {\n                    o.parensInOp = true;\n                    o = new(tree.Negative)(o);\n                }\n\n                return o;\n            },\n\n            //\n            // Expressions either represent mathematical operations,\n            // or white-space delimited Entities.\n            //\n            //     1px solid black\n            //     @var * 2\n            //\n            expression: function () {\n                const entities = [];\n                let e;\n                let delim;\n                const index = parserInput.i;\n\n                do {\n                    e = this.comment();\n                    if (e) {\n                        entities.push(e);\n                        continue;\n                    }\n                    e = this.addition() || this.entity();\n                    if (e) {\n                        entities.push(e);\n                        // operations do not allow keyword \"/\" dimension (e.g. small/20px) so we support that here\n                        if (!parserInput.peek(/^\\/[\\/*]/)) {\n                            delim = parserInput.$char('/');\n                            if (delim) {\n                                entities.push(new(tree.Anonymous)(delim, index));\n                            }\n                        }\n                    }\n                } while (e);\n                if (entities.length > 0) {\n                    return new(tree.Expression)(entities);\n                }\n            },\n            property: function () {\n                const name = parserInput.$re(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/);\n                if (name) {\n                    return name[1];\n                }\n            },\n            ruleProperty: function () {\n                let name = [];\n                const index = [];\n                let s;\n                let k;\n\n                parserInput.save();\n\n                const simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\\s*:/);\n                if (simpleProperty) {\n                    name = [new(tree.Keyword)(simpleProperty[1])];\n                    parserInput.forget();\n                    return name;\n                }\n\n                function match(re) {\n                    const i = parserInput.i;\n                    const chunk = parserInput.$re(re);\n                    if (chunk) {\n                        index.push(i);\n                        return name.push(chunk[1]);\n                    }\n                }\n\n                match(/^(\\*?)/);\n                while (true) {\n                    if (!match(/^((?:[\\w-]+)|(?:[@\\$]\\{[\\w-]+\\}))/)) {\n                        break;\n                    }\n                }\n\n                if ((name.length > 1) && match(/^((?:\\+_|\\+)?)\\s*:/)) {\n                    parserInput.forget();\n\n                    // at last, we have the complete match now. move forward,\n                    // convert name particles to tree objects and return:\n                    if (name[0] === '') {\n                        name.shift();\n                        index.shift();\n                    }\n                    for (k = 0; k < name.length; k++) {\n                        s = name[k];\n                        name[k] = (s.charAt(0) !== '@' && s.charAt(0) !== '$') ?\n                            new(tree.Keyword)(s) :\n                            (s.charAt(0) === '@' ?\n                                new(tree.Variable)(`@${s.slice(2, -1)}`, index[k], fileInfo) :\n                                new(tree.Property)(`$${s.slice(2, -1)}`, index[k], fileInfo));\n                    }\n                    return name;\n                }\n                parserInput.restore();\n            }\n        }\n    };\n};\nParser.serializeVars = vars => {\n    let s = '';\n\n    for (const name in vars) {\n        if (Object.hasOwnProperty.call(vars, name)) {\n            const value = vars[name];\n            s += `${((name[0] === '@') ? '' : '@') + name}: ${value}${(String(value).slice(-1) === ';') ? '' : ';'}`;\n        }\n    }\n\n    return s;\n};\n\nexport default Parser;\n","import Dimension from '../tree/dimension';\nimport Color from '../tree/color';\nimport Quoted from '../tree/quoted';\nimport Anonymous from '../tree/anonymous';\nlet colorFunctions;\n\nfunction clamp(val) {\n    return Math.min(1, Math.max(0, val));\n}\nfunction hsla(origColor, hsl) {\n    const color = colorFunctions.hsla(hsl.h, hsl.s, hsl.l, hsl.a);\n    if (color) {\n        if (origColor.value && \n            /^(rgb|hsl)/.test(origColor.value)) {\n            color.value = origColor.value;\n        } else {\n            color.value = 'rgb';\n        }\n        return color;\n    }\n}\nfunction toHSL(color) {\n    if (color.toHSL) {\n        return color.toHSL();\n    } else {\n        throw new Error('Argument cannot be evaluated to a color');\n    }\n}\n\nfunction toHSV(color) {\n    if (color.toHSV) {\n        return color.toHSV();\n    } else {\n        throw new Error('Argument cannot be evaluated to a color');\n    }\n}\n\nfunction number(n) {\n    if (n instanceof Dimension) {\n        return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);\n    } else if (typeof n === 'number') {\n        return n;\n    } else {\n        throw {\n            type: 'Argument',\n            message: 'color functions take numbers as parameters'\n        };\n    }\n}\nfunction scaled(n, size) {\n    if (n instanceof Dimension && n.unit.is('%')) {\n        return parseFloat(n.value * size / 100);\n    } else {\n        return number(n);\n    }\n}\ncolorFunctions = {\n    rgb: function (r, g, b) {\n        const color = colorFunctions.rgba(r, g, b, 1.0);\n        if (color) {\n            color.value = 'rgb';\n            return color;\n        }\n    },\n    rgba: function (r, g, b, a) {\n        try {\n            if (r instanceof Color) {\n                if (g) {\n                    a = number(g);\n                } else {\n                    a = r.alpha;\n                }\n                return new Color(r.rgb, a, 'rgba');\n            }\n            const rgb = [r, g, b].map(c => scaled(c, 255));\n            a = number(a);\n            return new Color(rgb, a, 'rgba');\n        }\n        catch (e) {}\n    },\n    hsl: function (h, s, l) {\n        const color = colorFunctions.hsla(h, s, l, 1.0);\n        if (color) {\n            color.value = 'hsl';\n            return color;\n        }\n    },\n    hsla: function (h, s, l, a) {\n        try {\n            if (h instanceof Color) {\n                if (s) {\n                    a = number(s);\n                } else {\n                    a = h.alpha;\n                }\n                return new Color(h.rgb, a, 'hsla');\n            }\n\n            let m1;\n            let m2;\n\n            function hue(h) {\n                h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);\n                if (h * 6 < 1) {\n                    return m1 + (m2 - m1) * h * 6;\n                }\n                else if (h * 2 < 1) {\n                    return m2;\n                }\n                else if (h * 3 < 2) {\n                    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n                }\n                else {\n                    return m1;\n                }\n            }\n\n            h = (number(h) % 360) / 360;\n            s = clamp(number(s));l = clamp(number(l));a = clamp(number(a));\n\n            m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n            m1 = l * 2 - m2;\n\n            const rgb = [\n                hue(h + 1 / 3) * 255,\n                hue(h)       * 255,\n                hue(h - 1 / 3) * 255\n            ];\n            a = number(a);\n            return new Color(rgb, a, 'hsla');\n        }\n        catch (e) {}\n    },\n\n    hsv: function(h, s, v) {\n        return colorFunctions.hsva(h, s, v, 1.0);\n    },\n\n    hsva: function(h, s, v, a) {\n        h = ((number(h) % 360) / 360) * 360;\n        s = number(s);v = number(v);a = number(a);\n\n        let i;\n        let f;\n        i = Math.floor((h / 60) % 6);\n        f = (h / 60) - i;\n\n        const vs = [v,\n            v * (1 - s),\n            v * (1 - f * s),\n            v * (1 - (1 - f) * s)];\n        const perm = [[0, 3, 1],\n            [2, 0, 1],\n            [1, 0, 3],\n            [1, 2, 0],\n            [3, 1, 0],\n            [0, 1, 2]];\n\n        return colorFunctions.rgba(vs[perm[i][0]] * 255,\n            vs[perm[i][1]] * 255,\n            vs[perm[i][2]] * 255,\n            a);\n    },\n\n    hue: function (color) {\n        return new Dimension(toHSL(color).h);\n    },\n    saturation: function (color) {\n        return new Dimension(toHSL(color).s * 100, '%');\n    },\n    lightness: function (color) {\n        return new Dimension(toHSL(color).l * 100, '%');\n    },\n    hsvhue: function(color) {\n        return new Dimension(toHSV(color).h);\n    },\n    hsvsaturation: function (color) {\n        return new Dimension(toHSV(color).s * 100, '%');\n    },\n    hsvvalue: function (color) {\n        return new Dimension(toHSV(color).v * 100, '%');\n    },\n    red: function (color) {\n        return new Dimension(color.rgb[0]);\n    },\n    green: function (color) {\n        return new Dimension(color.rgb[1]);\n    },\n    blue: function (color) {\n        return new Dimension(color.rgb[2]);\n    },\n    alpha: function (color) {\n        return new Dimension(toHSL(color).a);\n    },\n    luma: function (color) {\n        return new Dimension(color.luma() * color.alpha * 100, '%');\n    },\n    luminance: function (color) {\n        const luminance =\n            (0.2126 * color.rgb[0] / 255) +\n                (0.7152 * color.rgb[1] / 255) +\n                (0.0722 * color.rgb[2] / 255);\n\n        return new Dimension(luminance * color.alpha * 100, '%');\n    },\n    saturate: function (color, amount, method) {\n        // filter: saturate(3.2);\n        // should be kept as is, so check for color\n        if (!color.rgb) {\n            return null;\n        }\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.s +=  hsl.s * amount.value / 100;\n        }\n        else {\n            hsl.s += amount.value / 100;\n        }\n        hsl.s = clamp(hsl.s);\n        return hsla(color, hsl);\n    },\n    desaturate: function (color, amount, method) {\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.s -=  hsl.s * amount.value / 100;\n        }\n        else {\n            hsl.s -= amount.value / 100;\n        }\n        hsl.s = clamp(hsl.s);\n        return hsla(color, hsl);\n    },\n    lighten: function (color, amount, method) {\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.l +=  hsl.l * amount.value / 100;\n        }\n        else {\n            hsl.l += amount.value / 100;\n        }\n        hsl.l = clamp(hsl.l);\n        return hsla(color, hsl);\n    },\n    darken: function (color, amount, method) {\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.l -=  hsl.l * amount.value / 100;\n        }\n        else {\n            hsl.l -= amount.value / 100;\n        }\n        hsl.l = clamp(hsl.l);\n        return hsla(color, hsl);\n    },\n    fadein: function (color, amount, method) {\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.a +=  hsl.a * amount.value / 100;\n        }\n        else {\n            hsl.a += amount.value / 100;\n        }\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    fadeout: function (color, amount, method) {\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.a -=  hsl.a * amount.value / 100;\n        }\n        else {\n            hsl.a -= amount.value / 100;\n        }\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    fade: function (color, amount) {\n        const hsl = toHSL(color);\n\n        hsl.a = amount.value / 100;\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    spin: function (color, amount) {\n        const hsl = toHSL(color);\n        const hue = (hsl.h + amount.value) % 360;\n\n        hsl.h = hue < 0 ? 360 + hue : hue;\n\n        return hsla(color, hsl);\n    },\n    //\n    // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein\n    // http://sass-lang.com\n    //\n    mix: function (color1, color2, weight) {\n        if (!weight) {\n            weight = new Dimension(50);\n        }\n        const p = weight.value / 100.0;\n        const w = p * 2 - 1;\n        const a = toHSL(color1).a - toHSL(color2).a;\n\n        const w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        const w2 = 1 - w1;\n\n        const rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2];\n\n        const alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    },\n    greyscale: function (color) {\n        return colorFunctions.desaturate(color, new Dimension(100));\n    },\n    contrast: function (color, dark, light, threshold) {\n        // filter: contrast(3.2);\n        // should be kept as is, so check for color\n        if (!color.rgb) {\n            return null;\n        }\n        if (typeof light === 'undefined') {\n            light = colorFunctions.rgba(255, 255, 255, 1.0);\n        }\n        if (typeof dark === 'undefined') {\n            dark = colorFunctions.rgba(0, 0, 0, 1.0);\n        }\n        // Figure out which is actually light and dark:\n        if (dark.luma() > light.luma()) {\n            const t = light;\n            light = dark;\n            dark = t;\n        }\n        if (typeof threshold === 'undefined') {\n            threshold = 0.43;\n        } else {\n            threshold = number(threshold);\n        }\n        if (color.luma() < threshold) {\n            return light;\n        } else {\n            return dark;\n        }\n    },\n    // Changes made in 2.7.0 - Reverted in 3.0.0\n    // contrast: function (color, color1, color2, threshold) {\n    //     // Return which of `color1` and `color2` has the greatest contrast with `color`\n    //     // according to the standard WCAG contrast ratio calculation.\n    //     // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n    //     // The threshold param is no longer used, in line with SASS.\n    //     // filter: contrast(3.2);\n    //     // should be kept as is, so check for color\n    //     if (!color.rgb) {\n    //         return null;\n    //     }\n    //     if (typeof color1 === 'undefined') {\n    //         color1 = colorFunctions.rgba(0, 0, 0, 1.0);\n    //     }\n    //     if (typeof color2 === 'undefined') {\n    //         color2 = colorFunctions.rgba(255, 255, 255, 1.0);\n    //     }\n    //     var contrast1, contrast2;\n    //     var luma = color.luma();\n    //     var luma1 = color1.luma();\n    //     var luma2 = color2.luma();\n    //     // Calculate contrast ratios for each color\n    //     if (luma > luma1) {\n    //         contrast1 = (luma + 0.05) / (luma1 + 0.05);\n    //     } else {\n    //         contrast1 = (luma1 + 0.05) / (luma + 0.05);\n    //     }\n    //     if (luma > luma2) {\n    //         contrast2 = (luma + 0.05) / (luma2 + 0.05);\n    //     } else {\n    //         contrast2 = (luma2 + 0.05) / (luma + 0.05);\n    //     }\n    //     if (contrast1 > contrast2) {\n    //         return color1;\n    //     } else {\n    //         return color2;\n    //     }\n    // },\n    argb: function (color) {\n        return new Anonymous(color.toARGB());\n    },\n    color: function(c) {\n        if ((c instanceof Quoted) &&\n            (/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})$/i.test(c.value))) {\n            const val = c.value.slice(1);\n            return new Color(val, undefined, `#${val}`);\n        }\n        if ((c instanceof Color) || (c = Color.fromKeyword(c.value))) {\n            c.value = undefined;\n            return c;\n        }\n        throw {\n            type:    'Argument',\n            message: 'argument must be a color keyword or 3|4|6|8 digit hex e.g. #FFF'\n        };\n    },\n    tint: function(color, amount) {\n        return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);\n    },\n    shade: function(color, amount) {\n        return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);\n    }\n};\n\nexport default colorFunctions;\n","import Anonymous from '../tree/anonymous';\nimport Keyword from '../tree/keyword';\n\nfunction boolean(condition) {\n    return condition ? Keyword.True : Keyword.False;\n}\n\nfunction If(condition, trueValue, falseValue) {\n    return condition ? trueValue\n        : (falseValue || new Anonymous);\n}\n\nexport default { boolean, 'if': If };\n","import Color from '../tree/color';\n\n// Color Blending\n// ref: http://www.w3.org/TR/compositing-1\n\nfunction colorBlend(mode, color1, color2) {\n    const ab = color1.alpha;        // result\n\n    let // backdrop\n        cb;\n\n    const as = color2.alpha;\n\n    let // source\n        cs;\n\n    let ar;\n    let cr;\n    const r = [];\n\n    ar = as + ab * (1 - as);\n    for (let i = 0; i < 3; i++) {\n        cb = color1.rgb[i] / 255;\n        cs = color2.rgb[i] / 255;\n        cr = mode(cb, cs);\n        if (ar) {\n            cr = (as * cs + ab * (cb -\n                  as * (cb + cs - cr))) / ar;\n        }\n        r[i] = cr * 255;\n    }\n\n    return new Color(r, ar);\n}\n\nconst colorBlendModeFunctions = {\n    multiply: function(cb, cs) {\n        return cb * cs;\n    },\n    screen: function(cb, cs) {\n        return cb + cs - cb * cs;\n    },\n    overlay: function(cb, cs) {\n        cb *= 2;\n        return (cb <= 1) ?\n            colorBlendModeFunctions.multiply(cb, cs) :\n            colorBlendModeFunctions.screen(cb - 1, cs);\n    },\n    softlight: function(cb, cs) {\n        let d = 1;\n        let e = cb;\n        if (cs > 0.5) {\n            e = 1;\n            d = (cb > 0.25) ? Math.sqrt(cb)\n                : ((16 * cb - 12) * cb + 4) * cb;\n        }\n        return cb - (1 - 2 * cs) * e * (d - cb);\n    },\n    hardlight: function(cb, cs) {\n        return colorBlendModeFunctions.overlay(cs, cb);\n    },\n    difference: function(cb, cs) {\n        return Math.abs(cb - cs);\n    },\n    exclusion: function(cb, cs) {\n        return cb + cs - 2 * cb * cs;\n    },\n\n    // non-w3c functions:\n    average: function(cb, cs) {\n        return (cb + cs) / 2;\n    },\n    negation: function(cb, cs) {\n        return 1 - Math.abs(cb + cs - 1);\n    }\n};\n\nfor (const f in colorBlendModeFunctions) {\n    if (colorBlendModeFunctions.hasOwnProperty(f)) {\n        colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);\n    }\n}\n\nexport default colorBlend;\n","import Comment from '../tree/comment';\nimport Dimension from '../tree/dimension';\nimport Declaration from '../tree/declaration';\nimport Expression from '../tree/expression';\nimport Ruleset from '../tree/ruleset';\nimport Selector from '../tree/selector';\nimport Element from '../tree/element';\nimport Quote from '../tree/quoted';\n\nconst getItemsFromNode = node => {\n    // handle non-array values as an array of length 1\n    // return 'undefined' if index is invalid\n    const items = Array.isArray(node.value) ?\n        node.value : Array(node);\n\n    return items;\n};\n\nexport default {\n    _SELF: function(n) {\n        return n;\n    },\n    extract: function(values, index) {\n        // (1-based index)\n        index = index.value - 1;\n\n        return getItemsFromNode(values)[index];\n    },\n    length: function(values) {\n        return new Dimension(getItemsFromNode(values).length);\n    },\n    /**\n     * Creates a Less list of incremental values.\n     * Modeled after Lodash's range function, also exists natively in PHP\n     * \n     * @param {Dimension} [start=1]\n     * @param {Dimension} end  - e.g. 10 or 10px - unit is added to output\n     * @param {Dimension} [step=1] \n     */\n    range: function(start, end, step) {\n        let from;\n        let to;\n        let stepValue = 1;\n        const list = [];\n        if (end) {\n            to = end;\n            from = start.value;\n            if (step) {\n                stepValue = step.value;\n            }\n        }\n        else {\n            from = 1;\n            to = start;\n        }\n\n        for (let i = from; i <= to.value; i += stepValue) {\n            list.push(new Dimension(i, to.unit));\n        }\n\n        return new Expression(list);\n    },\n    each: function(list, rs) {\n        const rules = [];\n        let newRules;\n        let iterator;\n\n        if (list.value && !(list instanceof Quote)) {\n            if (Array.isArray(list.value)) {\n                iterator = list.value;\n            } else {\n                iterator = [list.value];\n            }\n        } else if (list.ruleset) {\n            iterator = list.ruleset.rules;\n        } else if (list.rules) {\n            iterator = list.rules;\n        } else if (Array.isArray(list)) {\n            iterator = list;\n        } else {\n            iterator = [list];\n        }\n\n        let valueName = '@value';\n        let keyName = '@key';\n        let indexName = '@index';\n\n        if (rs.params) {\n            valueName = rs.params[0] && rs.params[0].name;\n            keyName = rs.params[1] && rs.params[1].name;\n            indexName = rs.params[2] && rs.params[2].name;\n            rs = rs.rules;\n        } else {\n            rs = rs.ruleset;\n        }\n\n        for (let i = 0; i < iterator.length; i++) {\n            let key;\n            let value;\n            const item = iterator[i];\n            if (item instanceof Declaration) {\n                key = typeof item.name === 'string' ? item.name : item.name[0].value;\n                value = item.value;\n            } else {\n                key = new Dimension(i + 1);\n                value = item;\n            }\n\n            if (item instanceof Comment) {\n                continue;\n            }\n\n            newRules = rs.rules.slice(0);\n            if (valueName) {\n                newRules.push(new Declaration(valueName,\n                    value,\n                    false, false, this.index, this.currentFileInfo));\n            }\n            if (indexName) {\n                newRules.push(new Declaration(indexName,\n                    new Dimension(i + 1),\n                    false, false, this.index, this.currentFileInfo));\n            }\n            if (keyName) {\n                newRules.push(new Declaration(keyName,\n                    key,\n                    false, false, this.index, this.currentFileInfo));\n            }\n\n            rules.push(new Ruleset([ new(Selector)([ new Element(\"\", '&') ]) ],\n                newRules,\n                rs.strictImports,\n                rs.visibilityInfo()\n            ));\n        }\n\n        return new Ruleset([ new(Selector)([ new Element(\"\", '&') ]) ],\n            rules,\n            rs.strictImports,\n            rs.visibilityInfo()\n        ).eval(this.context);\n    }\n};\n","import Dimension from '../tree/dimension';\n\nconst MathHelper = (fn, unit, n) => {\n    if (!(n instanceof Dimension)) {\n        throw { type: 'Argument', message: 'argument must be a number' };\n    }\n    if (unit == null) {\n        unit = n.unit;\n    } else {\n        n = n.unify();\n    }\n    return new Dimension(fn(parseFloat(n.value)), unit);\n};\n\nexport default MathHelper;","import mathHelper from './math-helper.js';\n\nconst mathFunctions = {\n    // name,  unit\n    ceil:  null,\n    floor: null,\n    sqrt:  null,\n    abs:   null,\n    tan:   '',\n    sin:   '',\n    cos:   '',\n    atan:  'rad',\n    asin:  'rad',\n    acos:  'rad'\n};\n\nfor (const f in mathFunctions) {\n    if (mathFunctions.hasOwnProperty(f)) {\n        mathFunctions[f] = mathHelper.bind(null, Math[f], mathFunctions[f]);\n    }\n}\n\nmathFunctions.round = (n, f) => {\n    const fraction = typeof f === 'undefined' ? 0 : f.value;\n    return mathHelper(num => num.toFixed(fraction), null, n);\n};\n\nexport default mathFunctions;\n","import Dimension from '../tree/dimension';\nimport Anonymous from '../tree/anonymous';\nimport mathHelper from './math-helper.js';\n\nconst minMax = function (isMin, args) {\n    args = Array.prototype.slice.call(args);\n    switch (args.length) {\n        case 0: throw { type: 'Argument', message: 'one or more arguments required' };\n    }\n    let i; // key is the unit.toString() for unified Dimension values,\n    let j;\n    let current;\n    let currentUnified;\n    let referenceUnified;\n    let unit;\n    let unitStatic;\n    let unitClone;\n\n    const // elems only contains original argument values.\n        order  = [];\n\n    const values = {};\n    // value is the index into the order array.\n    for (i = 0; i < args.length; i++) {\n        current = args[i];\n        if (!(current instanceof Dimension)) {\n            if (Array.isArray(args[i].value)) {\n                Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));\n            }\n            continue;\n        }\n        currentUnified = current.unit.toString() === '' && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();\n        unit = currentUnified.unit.toString() === '' && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();\n        unitStatic = unit !== '' && unitStatic === undefined || unit !== '' && order[0].unify().unit.toString() === '' ? unit : unitStatic;\n        unitClone = unit !== '' && unitClone === undefined ? current.unit.toString() : unitClone;\n        j = values[''] !== undefined && unit !== '' && unit === unitStatic ? values[''] : values[unit];\n        if (j === undefined) {\n            if (unitStatic !== undefined && unit !== unitStatic) {\n                throw { type: 'Argument', message: 'incompatible types' };\n            }\n            values[unit] = order.length;\n            order.push(current);\n            continue;\n        }\n        referenceUnified = order[j].unit.toString() === '' && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();\n        if ( isMin && currentUnified.value < referenceUnified.value ||\n            !isMin && currentUnified.value > referenceUnified.value) {\n            order[j] = current;\n        }\n    }\n    if (order.length == 1) {\n        return order[0];\n    }\n    args = order.map(function (a) { return a.toCSS(this.context); }).join(this.context.compress ? ',' : ', ');\n    return new Anonymous(`${isMin ? 'min' : 'max'}(${args})`);\n};\n\nexport default {\n    min: function(...args) {\n        return minMax(true, args);\n    },\n    max: function(...args) {\n        return minMax(false, args);\n    },\n    convert: function (val, unit) {\n        return val.convertTo(unit.value);\n    },\n    pi: function () {\n        return new Dimension(Math.PI);\n    },\n    mod: function(a, b) {\n        return new Dimension(a.value % b.value, a.unit);\n    },\n    pow: function(x, y) {\n        if (typeof x === 'number' && typeof y === 'number') {\n            x = new Dimension(x);\n            y = new Dimension(y);\n        } else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {\n            throw { type: 'Argument', message: 'arguments must be numbers' };\n        }\n\n        return new Dimension(Math.pow(x.value, y.value), x.unit);\n    },\n    percentage: function (n) {\n        const result = mathHelper(num => num * 100, '%', n);\n\n        return result;\n    }\n};\n","/**\n * Plugin Manager\n */\nclass PluginManager {\n    constructor(less) {\n        this.less = less;\n        this.visitors = [];\n        this.preProcessors = [];\n        this.postProcessors = [];\n        this.installedPlugins = [];\n        this.fileManagers = [];\n        this.iterator = -1;\n        this.pluginCache = {};\n        this.Loader = new less.PluginLoader(less);\n    }\n\n    /**\n     * Adds all the plugins in the array\n     * @param {Array} plugins\n     */\n    addPlugins(plugins) {\n        if (plugins) {\n            for (let i = 0; i < plugins.length; i++) {\n                this.addPlugin(plugins[i]);\n            }\n        }\n    }\n\n    /**\n     *\n     * @param plugin\n     * @param {String} filename\n     */\n    addPlugin(plugin, filename, functionRegistry) {\n        this.installedPlugins.push(plugin);\n        if (filename) {\n            this.pluginCache[filename] = plugin;\n        }\n        if (plugin.install) {\n            plugin.install(this.less, this, functionRegistry || this.less.functions.functionRegistry);\n        }\n    }\n\n    /**\n     *\n     * @param filename\n     */\n    get(filename) {\n        return this.pluginCache[filename];\n    }\n\n    /**\n     * Adds a visitor. The visitor object has options on itself to determine\n     * when it should run.\n     * @param visitor\n     */\n    addVisitor(visitor) {\n        this.visitors.push(visitor);\n    }\n\n    /**\n     * Adds a pre processor object\n     * @param {object} preProcessor\n     * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import\n     */\n    addPreProcessor(preProcessor, priority) {\n        let indexToInsertAt;\n        for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {\n            if (this.preProcessors[indexToInsertAt].priority >= priority) {\n                break;\n            }\n        }\n        this.preProcessors.splice(indexToInsertAt, 0, {preProcessor, priority});\n    }\n\n    /**\n     * Adds a post processor object\n     * @param {object} postProcessor\n     * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression\n     */\n    addPostProcessor(postProcessor, priority) {\n        let indexToInsertAt;\n        for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {\n            if (this.postProcessors[indexToInsertAt].priority >= priority) {\n                break;\n            }\n        }\n        this.postProcessors.splice(indexToInsertAt, 0, {postProcessor, priority});\n    }\n\n    /**\n     *\n     * @param manager\n     */\n    addFileManager(manager) {\n        this.fileManagers.push(manager);\n    }\n\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    getPreProcessors() {\n        const preProcessors = [];\n        for (let i = 0; i < this.preProcessors.length; i++) {\n            preProcessors.push(this.preProcessors[i].preProcessor);\n        }\n        return preProcessors;\n    }\n\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    getPostProcessors() {\n        const postProcessors = [];\n        for (let i = 0; i < this.postProcessors.length; i++) {\n            postProcessors.push(this.postProcessors[i].postProcessor);\n        }\n        return postProcessors;\n    }\n\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    getVisitors() {\n        return this.visitors;\n    }\n\n    visitor() {\n        const self = this;\n        return {\n            first: function() {\n                self.iterator = -1;\n                return self.visitors[self.iterator];\n            },\n            get: function() {\n                self.iterator += 1;\n                return self.visitors[self.iterator];\n            }\n        };\n    }\n\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    getFileManagers() {\n        return this.fileManagers;\n    }\n}\n\nlet pm;\n\nfunction PluginManagerFactory(less, newFactory) {\n    if (newFactory || !pm) {\n        pm = new PluginManager(less);\n    }\n    return pm;\n};\n\n//\nexport default PluginManagerFactory;\n","import Quoted from '../tree/quoted';\nimport Anonymous from '../tree/anonymous';\nimport JavaScript from '../tree/javascript';\n\nexport default {\n    e: function (str) {\n        return new Quoted('\"', str instanceof JavaScript ? str.evaluated : str.value, true);\n    },\n    escape: function (str) {\n        return new Anonymous(\n            encodeURI(str.value).replace(/=/g, '%3D').replace(/:/g, '%3A').replace(/#/g, '%23').replace(/;/g, '%3B')\n                .replace(/\\(/g, '%28').replace(/\\)/g, '%29'));\n    },\n    replace: function (string, pattern, replacement, flags) {\n        let result = string.value;\n        replacement = (replacement.type === 'Quoted') ?\n            replacement.value : replacement.toCSS();\n        result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);\n        return new Quoted(string.quote || '', result, string.escaped);\n    },\n    '%': function (string /* arg, arg, ... */) {\n        const args = Array.prototype.slice.call(arguments, 1);\n        let result = string.value;\n\n        for (let i = 0; i < args.length; i++) {\n            /* jshint loopfunc:true */\n            result = result.replace(/%[sda]/i, token => {\n                const value = ((args[i].type === 'Quoted') &&\n                    token.match(/s/i)) ? args[i].value : args[i].toCSS();\n                return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;\n            });\n        }\n        result = result.replace(/%%/g, '%');\n        return new Quoted(string.quote || '', result, string.escaped);\n    }\n};\n","import Keyword from '../tree/keyword';\nimport DetachedRuleset from '../tree/detached-ruleset';\nimport Dimension from '../tree/dimension';\nimport Color from '../tree/color';\nimport Quoted from '../tree/quoted';\nimport Anonymous from '../tree/anonymous';\nimport URL from '../tree/url';\nimport Operation from '../tree/operation';\n\nconst isa = (n, Type) => (n instanceof Type) ? Keyword.True : Keyword.False;\nconst isunit = (n, unit) => {\n    if (unit === undefined) {\n        throw { type: 'Argument', message: 'missing the required second argument to isunit.' };\n    }\n    unit = typeof unit.value === 'string' ? unit.value : unit;\n    if (typeof unit !== 'string') {\n        throw { type: 'Argument', message: 'Second argument to isunit should be a unit or a string.' };\n    }\n    return (n instanceof Dimension) && n.unit.is(unit) ? Keyword.True : Keyword.False;\n};\n\nexport default {\n    isruleset: function (n) {\n        return isa(n, DetachedRuleset);\n    },\n    iscolor: function (n) {\n        return isa(n, Color);\n    },\n    isnumber: function (n) {\n        return isa(n, Dimension);\n    },\n    isstring: function (n) {\n        return isa(n, Quoted);\n    },\n    iskeyword: function (n) {\n        return isa(n, Keyword);\n    },\n    isurl: function (n) {\n        return isa(n, URL);\n    },\n    ispixel: function (n) {\n        return isunit(n, 'px');\n    },\n    ispercentage: function (n) {\n        return isunit(n, '%');\n    },\n    isem: function (n) {\n        return isunit(n, 'em');\n    },\n    isunit,\n    unit: function (val, unit) {\n        if (!(val instanceof Dimension)) {\n            throw { type: 'Argument',\n                message: `the first argument to unit must be a number${val instanceof Operation ? '. Have you forgotten parenthesis?' : ''}` };\n        }\n        if (unit) {\n            if (unit instanceof Keyword) {\n                unit = unit.value;\n            } else {\n                unit = unit.toCSS();\n            }\n        } else {\n            unit = '';\n        }\n        return new Dimension(val.value, unit);\n    },\n    'get-unit': function (n) {\n        return new Anonymous(n.unit);\n    }\n};\n","import functionRegistry from './function-registry';\nimport functionCaller from './function-caller';\n\nimport boolean from './boolean';\nimport defaultFunc from './default';\nimport color from './color';\nimport colorBlending from './color-blending';\nimport dataUri from './data-uri';\nimport list from './list';\nimport math from './math';\nimport number from './number';\nimport string from './string';\nimport svg from './svg';\nimport types from './types';\n\nexport default environment => {\n    const functions = { functionRegistry, functionCaller };\n\n    // register functions\n    functionRegistry.addMultiple(boolean);\n    functionRegistry.add('default', defaultFunc.eval.bind(defaultFunc));\n    functionRegistry.addMultiple(color);\n    functionRegistry.addMultiple(colorBlending);\n    functionRegistry.addMultiple(dataUri(environment));\n    functionRegistry.addMultiple(list);\n    functionRegistry.addMultiple(math);\n    functionRegistry.addMultiple(number);\n    functionRegistry.addMultiple(string);\n    functionRegistry.addMultiple(svg(environment));\n    functionRegistry.addMultiple(types);\n\n    return functions;\n};\n","import Quoted from '../tree/quoted';\nimport URL from '../tree/url';\nimport * as utils from '../utils';\nimport logger from '../logger';\n\nexport default environment => {\n    \n    const fallback = (functionThis, node) => new URL(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context);    \n\n    return { 'data-uri': function(mimetypeNode, filePathNode) {\n\n        if (!filePathNode) {\n            filePathNode = mimetypeNode;\n            mimetypeNode = null;\n        }\n\n        let mimetype = mimetypeNode && mimetypeNode.value;\n        let filePath = filePathNode.value;\n        const currentFileInfo = this.currentFileInfo;\n        const currentDirectory = currentFileInfo.rewriteUrls ?\n            currentFileInfo.currentDirectory : currentFileInfo.entryPath;\n\n        const fragmentStart = filePath.indexOf('#');\n        let fragment = '';\n        if (fragmentStart !== -1) {\n            fragment = filePath.slice(fragmentStart);\n            filePath = filePath.slice(0, fragmentStart);\n        }\n        const context = utils.clone(this.context);\n        context.rawBuffer = true;\n\n        const fileManager = environment.getFileManager(filePath, currentDirectory, context, environment, true);\n\n        if (!fileManager) {\n            return fallback(this, filePathNode);\n        }\n\n        let useBase64 = false;\n\n        // detect the mimetype if not given\n        if (!mimetypeNode) {\n\n            mimetype = environment.mimeLookup(filePath);\n\n            if (mimetype === 'image/svg+xml') {\n                useBase64 = false;\n            } else {\n                // use base 64 unless it's an ASCII or UTF-8 format\n                const charset = environment.charsetLookup(mimetype);\n                useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;\n            }\n            if (useBase64) { mimetype += ';base64'; }\n        }\n        else {\n            useBase64 = /;base64$/.test(mimetype);\n        }\n\n        const fileSync = fileManager.loadFileSync(filePath, currentDirectory, context, environment);\n        if (!fileSync.contents) {\n            logger.warn(`Skipped data-uri embedding of ${filePath} because file not found`);\n            return fallback(this, filePathNode || mimetypeNode);\n        }\n        let buf = fileSync.contents;\n        if (useBase64 && !environment.encodeBase64) {\n            return fallback(this, filePathNode);\n        }\n\n        buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);\n\n        const uri = `data:${mimetype},${buf}${fragment}`;\n\n        return new URL(new Quoted(`\"${uri}\"`, uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);\n    }};\n};\n","import Dimension from '../tree/dimension';\nimport Color from '../tree/color';\nimport Expression from '../tree/expression';\nimport Quoted from '../tree/quoted';\nimport URL from '../tree/url';\n\nexport default environment => {\n    return { 'svg-gradient': function(direction) {\n        let stops;\n        let gradientDirectionSvg;\n        let gradientType = 'linear';\n        let rectangleDimension = 'x=\"0\" y=\"0\" width=\"1\" height=\"1\"';\n        const renderEnv = {compress: false};\n        let returner;\n        const directionValue = direction.toCSS(renderEnv);\n        let i;\n        let color;\n        let position;\n        let positionValue;\n        let alpha;\n\n        function throwArgumentDescriptor() {\n            throw { type: 'Argument',\n                message: 'svg-gradient expects direction, start_color [start_position], [color position,]...,' +\n                            ' end_color [end_position] or direction, color list' };\n        }\n\n        if (arguments.length == 2) {\n            if (arguments[1].value.length < 2) {\n                throwArgumentDescriptor();\n            }\n            stops = arguments[1].value;\n        } else if (arguments.length < 3) {\n            throwArgumentDescriptor();\n        } else {\n            stops = Array.prototype.slice.call(arguments, 1);\n        }\n\n        switch (directionValue) {\n            case 'to bottom':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"';\n                break;\n            case 'to right':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"';\n                break;\n            case 'to bottom right':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\"';\n                break;\n            case 'to top right':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"100%\" x2=\"100%\" y2=\"0%\"';\n                break;\n            case 'ellipse':\n            case 'ellipse at center':\n                gradientType = 'radial';\n                gradientDirectionSvg = 'cx=\"50%\" cy=\"50%\" r=\"75%\"';\n                rectangleDimension = 'x=\"-50\" y=\"-50\" width=\"101\" height=\"101\"';\n                break;\n            default:\n                throw { type: 'Argument', message: 'svg-gradient direction must be \\'to bottom\\', \\'to right\\',' +\n                    ' \\'to bottom right\\', \\'to top right\\' or \\'ellipse at center\\'' };\n        }\n        returner = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"><${gradientType}Gradient id=\"g\" ${gradientDirectionSvg}>`;\n\n        for (i = 0; i < stops.length; i += 1) {\n            if (stops[i] instanceof Expression) {\n                color = stops[i].value[0];\n                position = stops[i].value[1];\n            } else {\n                color = stops[i];\n                position = undefined;\n            }\n\n            if (!(color instanceof Color) || (!((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof Dimension))) {\n                throwArgumentDescriptor();\n            }\n            positionValue = position ? position.toCSS(renderEnv) : i === 0 ? '0%' : '100%';\n            alpha = color.alpha;\n            returner += `<stop offset=\"${positionValue}\" stop-color=\"${color.toRGB()}\"${alpha < 1 ? ` stop-opacity=\"${alpha}\"` : ''}/>`;\n        }\n        returner += `</${gradientType}Gradient><rect ${rectangleDimension} fill=\"url(#g)\" /></svg>`;\n\n        returner = encodeURIComponent(returner);\n\n        returner = `data:image/svg+xml,${returner}`;\n        return new URL(new Quoted(`'${returner}'`, returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);\n    }};\n};\n","import contexts from './contexts';\nimport visitor from './visitors';\nimport tree from './tree';\n\nexport default (root, options = {}) => {\n    let evaldRoot;\n    let variables = options.variables;\n    const evalEnv = new contexts.Eval(options);\n\n    //\n    // Allows setting variables with a hash, so:\n    //\n    //   `{ color: new tree.Color('#f01') }` will become:\n    //\n    //   new tree.Declaration('@color',\n    //     new tree.Value([\n    //       new tree.Expression([\n    //         new tree.Color('#f01')\n    //       ])\n    //     ])\n    //   )\n    //\n    if (typeof variables === 'object' && !Array.isArray(variables)) {\n        variables = Object.keys(variables).map(k => {\n            let value = variables[k];\n\n            if (!(value instanceof tree.Value)) {\n                if (!(value instanceof tree.Expression)) {\n                    value = new tree.Expression([value]);\n                }\n                value = new tree.Value([value]);\n            }\n            return new tree.Declaration(`@${k}`, value, false, null, 0);\n        });\n        evalEnv.frames = [new tree.Ruleset(null, variables)];\n    }\n\n    const visitors = [\n        new visitor.JoinSelectorVisitor(),\n        new visitor.MarkVisibleSelectorsVisitor(true),\n        new visitor.ExtendVisitor(),\n        new visitor.ToCSSVisitor({compress: Boolean(options.compress)})\n    ];\n\n    const preEvalVisitors = [];\n    let v;\n    let visitorIterator;\n\n    /**\n     * first() / get() allows visitors to be added while visiting\n     * \n     * @todo Add scoping for visitors just like functions for @plugin; right now they're global\n     */\n    if (options.pluginManager) {\n        visitorIterator = options.pluginManager.visitor();\n        for (var i = 0; i < 2; i++) {\n            visitorIterator.first();\n            while ((v = visitorIterator.get())) {\n                if (v.isPreEvalVisitor) {\n                    if (i === 0 || preEvalVisitors.indexOf(v) === -1) {\n                        preEvalVisitors.push(v);\n                        v.run(root);\n                    }\n                }\n                else {\n                    if (i === 0 || visitors.indexOf(v) === -1) {\n                        if (v.isPreVisitor) {\n                            visitors.unshift(v);\n                        }\n                        else {\n                            visitors.push(v);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    evaldRoot = root.eval(evalEnv);\n\n    for (var i = 0; i < visitors.length; i++) {\n        visitors[i].run(evaldRoot);\n    }\n\n    // Run any remaining visitors added after eval pass\n    if (options.pluginManager) {\n        visitorIterator.first();\n        while ((v = visitorIterator.get())) {\n            if (visitors.indexOf(v) === -1 && preEvalVisitors.indexOf(v) === -1) {\n                v.run(evaldRoot);\n            }\n        }\n    }\n\n    return evaldRoot;\n};\n","/* global window, XMLHttpRequest */\n\nimport AbstractFileManager from '../less/environment/abstract-file-manager.js';\n\nlet options;\nlet logger;\nlet fileCache = {};\n\n// TODOS - move log somewhere. pathDiff and doing something similar in node. use pathDiff in the other browser file for the initial load\nclass FileManager extends AbstractFileManager {\n    alwaysMakePathsAbsolute() {\n        return true;\n    }\n\n    join(basePath, laterPath) {\n        if (!basePath) {\n            return laterPath;\n        }\n        return this.extractUrlParts(laterPath, basePath).path;\n    }\n\n    doXHR(url, type, callback, errback) {\n        const xhr = new XMLHttpRequest();\n        const async = options.isFileProtocol ? options.fileAsync : true;\n\n        if (typeof xhr.overrideMimeType === 'function') {\n            xhr.overrideMimeType('text/css');\n        }\n        logger.debug(`XHR: Getting '${url}'`);\n        xhr.open('GET', url, async);\n        xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');\n        xhr.send(null);\n\n        function handleResponse(xhr, callback, errback) {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(xhr.responseText,\n                    xhr.getResponseHeader('Last-Modified'));\n            } else if (typeof errback === 'function') {\n                errback(xhr.status, url);\n            }\n        }\n\n        if (options.isFileProtocol && !options.fileAsync) {\n            if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {\n                callback(xhr.responseText);\n            } else {\n                errback(xhr.status, url);\n            }\n        } else if (async) {\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState == 4) {\n                    handleResponse(xhr, callback, errback);\n                }\n            };\n        } else {\n            handleResponse(xhr, callback, errback);\n        }\n    }\n\n    supports() {\n        return true;\n    }\n\n    clearFileCache() {\n        fileCache = {};\n    }\n\n    loadFile(filename, currentDirectory, options, environment) {\n        // TODO: Add prefix support like less-node?\n        // What about multiple paths?\n\n        if (currentDirectory && !this.isPathAbsolute(filename)) {\n            filename = currentDirectory + filename;\n        }\n\n        filename = options.ext ? this.tryAppendExtension(filename, options.ext) : filename;\n\n        options = options || {};\n\n        // sheet may be set to the stylesheet for the initial load or a collection of properties including\n        // some context variables for imports\n        const hrefParts = this.extractUrlParts(filename, window.location.href);\n        const href      = hrefParts.url;\n        const self      = this;\n        \n        return new Promise((resolve, reject) => {\n            if (options.useFileCache && fileCache[href]) {\n                try {\n                    const lessText = fileCache[href];\n                    return resolve({ contents: lessText, filename: href, webInfo: { lastModified: new Date() }});\n                } catch (e) {\n                    return reject({ filename: href, message: `Error loading file ${href} error was ${e.message}` });\n                }\n            }\n\n            self.doXHR(href, options.mime, function doXHRCallback(data, lastModified) {\n                // per file cache\n                fileCache[href] = data;\n\n                // Use remote copy (re-parse)\n                resolve({ contents: data, filename: href, webInfo: { lastModified }});\n            }, function doXHRError(status, url) {\n                reject({ type: 'File', message: `'${url}' wasn't found (${status})`, href });\n            });\n        });\n    }\n}\n\nexport default (opts, log) => {\n    options = opts;\n    logger = log;\n    return FileManager;\n}\n","import data from './data';\nimport tree from './tree';\nimport Environment from './environment/environment';\nimport AbstractFileManager from './environment/abstract-file-manager';\nimport AbstractPluginLoader from './environment/abstract-plugin-loader';\nimport visitors from './visitors';\nimport Parser from './parser/parser';\nimport Functions from './functions';\nimport contexts from './contexts';\nimport sourceMapOutput from './source-map-output';\nimport sourceMapBuilder from './source-map-builder';\nimport parseTree from './parse-tree';\nimport importManager from './import-manager';\nimport Render from './render';\nimport Parse from './parse';\nimport LessError from './less-error';\nimport transformTree from './transform-tree';\nimport * as utils from './utils';\nimport PluginManager from './plugin-manager';\nimport logger from './logger';\n\nexport default (environment, fileManagers) => {\n    /**\n     * @todo\n     * This original code could be improved quite a bit.\n     * Many classes / modules currently add side-effects / mutations to passed in objects,\n     * which makes it hard to refactor and reason about. \n     */\n    environment = new Environment(environment, fileManagers);\n\n    const SourceMapOutput = sourceMapOutput(environment);\n    const SourceMapBuilder = sourceMapBuilder(SourceMapOutput, environment);\n    const ParseTree = parseTree(SourceMapBuilder);\n    const ImportManager = importManager(environment);\n    const render = Render(environment, ParseTree, ImportManager);\n    const parse = Parse(environment, ParseTree, ImportManager);\n    const functions = Functions(environment);\n\n    /**\n     * @todo\n     * This root properties / methods need to be organized.\n     * It's not clear what should / must be public and why.\n     */\n    const initial = {\n        version: [3, 11, 0],\n        data,\n        tree,\n        Environment,\n        AbstractFileManager,\n        AbstractPluginLoader,\n        environment,\n        visitors,\n        Parser,\n        functions,\n        contexts,\n        SourceMapOutput,\n        SourceMapBuilder,\n        ParseTree,\n        ImportManager,\n        render,\n        parse,\n        LessError,\n        transformTree,\n        utils,\n        PluginManager,\n        logger\n    };\n\n    // Create a public API\n    const ctor = t => function (...args) {\n        return new t(...args);\n    };\n\n    let t;\n    const api = Object.create(initial);\n    for (const n in initial.tree) {\n        /* eslint guard-for-in: 0 */\n        t = initial.tree[n];\n        if (typeof t === 'function') {\n            api[n.toLowerCase()] = ctor(t);\n        }\n        else {\n            api[n] = Object.create(null);\n            for (const o in t) {\n                /* eslint guard-for-in: 0 */\n                api[n][o.toLowerCase()] = ctor(t[o]);\n            }\n        }\n    }\n\n    return api;\n};\n","export default environment => {\n    class SourceMapOutput {\n        constructor(options) {\n            this._css = [];\n            this._rootNode = options.rootNode;\n            this._contentsMap = options.contentsMap;\n            this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;\n            if (options.sourceMapFilename) {\n                this._sourceMapFilename = options.sourceMapFilename.replace(/\\\\/g, '/');\n            }\n            this._outputFilename = options.outputFilename;\n            this.sourceMapURL = options.sourceMapURL;\n            if (options.sourceMapBasepath) {\n                this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\\\/g, '/');\n            }\n            if (options.sourceMapRootpath) {\n                this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\\\/g, '/');\n                if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {\n                    this._sourceMapRootpath += '/';\n                }\n            } else {\n                this._sourceMapRootpath = '';\n            }\n            this._outputSourceFiles = options.outputSourceFiles;\n            this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();\n\n            this._lineNumber = 0;\n            this._column = 0;\n        }\n\n        removeBasepath(path) {\n            if (this._sourceMapBasepath && path.indexOf(this._sourceMapBasepath) === 0) {\n                path = path.substring(this._sourceMapBasepath.length);\n                if (path.charAt(0) === '\\\\' || path.charAt(0) === '/') {\n                    path = path.substring(1);\n                }\n            }\n\n            return path;\n        }\n\n        normalizeFilename(filename) {\n            filename = filename.replace(/\\\\/g, '/');\n            filename = this.removeBasepath(filename);\n            return (this._sourceMapRootpath || '') + filename;\n        }\n\n        add(chunk, fileInfo, index, mapLines) {\n            // ignore adding empty strings\n            if (!chunk) {\n                return;\n            }\n\n            let lines;\n            let sourceLines;\n            let columns;\n            let sourceColumns;\n            let i;\n\n            if (fileInfo && fileInfo.filename) {\n                let inputSource = this._contentsMap[fileInfo.filename];\n\n                // remove vars/banner added to the top of the file\n                if (this._contentsIgnoredCharsMap[fileInfo.filename]) {\n                    // adjust the index\n                    index -= this._contentsIgnoredCharsMap[fileInfo.filename];\n                    if (index < 0) { index = 0; }\n                    // adjust the source\n                    inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);\n                }\n\n                // ignore empty content\n                if (inputSource === undefined) {\n                    return;\n                }\n\n                inputSource = inputSource.substring(0, index);\n                sourceLines = inputSource.split('\\n');\n                sourceColumns = sourceLines[sourceLines.length - 1];\n            }\n\n            lines = chunk.split('\\n');\n            columns = lines[lines.length - 1];\n\n            if (fileInfo && fileInfo.filename) {\n                if (!mapLines) {\n                    this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column},\n                        original: { line: sourceLines.length, column: sourceColumns.length},\n                        source: this.normalizeFilename(fileInfo.filename)});\n                } else {\n                    for (i = 0; i < lines.length; i++) {\n                        this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0},\n                            original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0},\n                            source: this.normalizeFilename(fileInfo.filename)});\n                    }\n                }\n            }\n\n            if (lines.length === 1) {\n                this._column += columns.length;\n            } else {\n                this._lineNumber += lines.length - 1;\n                this._column = columns.length;\n            }\n\n            this._css.push(chunk);\n        }\n\n        isEmpty() {\n            return this._css.length === 0;\n        }\n\n        toCSS(context) {\n            this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });\n\n            if (this._outputSourceFiles) {\n                for (const filename in this._contentsMap) {\n                    if (this._contentsMap.hasOwnProperty(filename)) {\n                        let source = this._contentsMap[filename];\n                        if (this._contentsIgnoredCharsMap[filename]) {\n                            source = source.slice(this._contentsIgnoredCharsMap[filename]);\n                        }\n                        this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);\n                    }\n                }\n            }\n\n            this._rootNode.genCSS(context, this);\n\n            if (this._css.length > 0) {\n                let sourceMapURL;\n                const sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());\n\n                if (this.sourceMapURL) {\n                    sourceMapURL = this.sourceMapURL;\n                } else if (this._sourceMapFilename) {\n                    sourceMapURL = this._sourceMapFilename;\n                }\n                this.sourceMapURL = sourceMapURL;\n\n                this.sourceMap = sourceMapContent;\n            }\n\n            return this._css.join('');\n        }\n    }\n\n    return SourceMapOutput;\n};\n","export default (SourceMapOutput, environment) => {\n    class SourceMapBuilder {\n        constructor(options) {\n            this.options = options;\n        }\n\n        toCSS(rootNode, options, imports) {\n            const sourceMapOutput = new SourceMapOutput(\n                {\n                    contentsIgnoredCharsMap: imports.contentsIgnoredChars,\n                    rootNode,\n                    contentsMap: imports.contents,\n                    sourceMapFilename: this.options.sourceMapFilename,\n                    sourceMapURL: this.options.sourceMapURL,\n                    outputFilename: this.options.sourceMapOutputFilename,\n                    sourceMapBasepath: this.options.sourceMapBasepath,\n                    sourceMapRootpath: this.options.sourceMapRootpath,\n                    outputSourceFiles: this.options.outputSourceFiles,\n                    sourceMapGenerator: this.options.sourceMapGenerator,\n                    sourceMapFileInline: this.options.sourceMapFileInline\n                });\n\n            const css = sourceMapOutput.toCSS(options);\n            this.sourceMap = sourceMapOutput.sourceMap;\n            this.sourceMapURL = sourceMapOutput.sourceMapURL;\n            if (this.options.sourceMapInputFilename) {\n                this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);\n            }\n            if (this.options.sourceMapBasepath !== undefined && this.sourceMapURL !== undefined) {\n                this.sourceMapURL = sourceMapOutput.removeBasepath(this.sourceMapURL);\n            }\n            return css + this.getCSSAppendage();\n        }\n\n        getCSSAppendage() {\n\n            let sourceMapURL = this.sourceMapURL;\n            if (this.options.sourceMapFileInline) {\n                if (this.sourceMap === undefined) {\n                    return '';\n                }\n                sourceMapURL = `data:application/json;base64,${environment.encodeBase64(this.sourceMap)}`;\n            }\n\n            if (sourceMapURL) {\n                return `/*# sourceMappingURL=${sourceMapURL} */`;\n            }\n            return '';\n        }\n\n        getExternalSourceMap() {\n            return this.sourceMap;\n        }\n\n        setExternalSourceMap(sourceMap) {\n            this.sourceMap = sourceMap;\n        }\n\n        isInline() {\n            return this.options.sourceMapFileInline;\n        }\n\n        getSourceMapURL() {\n            return this.sourceMapURL;\n        }\n\n        getOutputFilename() {\n            return this.options.sourceMapOutputFilename;\n        }\n\n        getInputFilename() {\n            return this.sourceMapInputFilename;\n        }\n    }\n\n    return SourceMapBuilder;\n};\n","import LessError from './less-error';\nimport transformTree from './transform-tree';\nimport logger from './logger';\n\nexport default SourceMapBuilder => {\n    class ParseTree {\n        constructor(root, imports) {\n            this.root = root;\n            this.imports = imports;\n        }\n\n        toCSS(options) {\n            let evaldRoot;\n            const result = {};\n            let sourceMapBuilder;\n            try {\n                evaldRoot = transformTree(this.root, options);\n            } catch (e) {\n                throw new LessError(e, this.imports);\n            }\n\n            try {\n                const compress = Boolean(options.compress);\n                if (compress) {\n                    logger.warn('The compress option has been deprecated. ' + \n                        'We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.');\n                }\n\n                const toCSSOptions = {\n                    compress,\n                    dumpLineNumbers: options.dumpLineNumbers,\n                    strictUnits: Boolean(options.strictUnits),\n                    numPrecision: 8};\n\n                if (options.sourceMap) {\n                    sourceMapBuilder = new SourceMapBuilder(options.sourceMap);\n                    result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);\n                } else {\n                    result.css = evaldRoot.toCSS(toCSSOptions);\n                }\n            } catch (e) {\n                throw new LessError(e, this.imports);\n            }\n\n            if (options.pluginManager) {\n                const postProcessors = options.pluginManager.getPostProcessors();\n                for (let i = 0; i < postProcessors.length; i++) {\n                    result.css = postProcessors[i].process(result.css, { sourceMap: sourceMapBuilder, options, imports: this.imports });\n                }\n            }\n            if (options.sourceMap) {\n                result.map = sourceMapBuilder.getExternalSourceMap();\n            }\n\n            result.imports = [];\n            for (const file in this.imports.files) {\n                if (this.imports.files.hasOwnProperty(file) && file !== this.imports.rootFilename) {\n                    result.imports.push(file);\n                }\n            }\n            return result;\n        }\n    }\n\n    return ParseTree;\n};\n","import contexts from './contexts';\nimport Parser from './parser/parser';\nimport LessError from './less-error';\nimport * as utils from './utils';\nimport logger from './logger';\n\nexport default environment => {\n    // FileInfo = {\n    //  'rewriteUrls' - option - whether to adjust URL's to be relative\n    //  'filename' - full resolved filename of current file\n    //  'rootpath' - path to append to normal URLs for this node\n    //  'currentDirectory' - path to the current file, absolute\n    //  'rootFilename' - filename of the base file\n    //  'entryPath' - absolute path to the entry file\n    //  'reference' - whether the file should not be output and only output parts that are referenced\n\n    class ImportManager {\n        constructor(less, context, rootFileInfo) {\n            this.less = less;\n            this.rootFilename = rootFileInfo.filename;\n            this.paths = context.paths || [];  // Search paths, when importing\n            this.contents = {};             // map - filename to contents of all the files\n            this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore\n            this.mime = context.mime;\n            this.error = null;\n            this.context = context;\n            // Deprecated? Unused outside of here, could be useful.\n            this.queue = [];        // Files which haven't been imported yet\n            this.files = {};        // Holds the imported parse trees.\n        }\n\n        /**\n         * Add an import to be imported\n         * @param path - the raw path\n         * @param tryAppendExtension - whether to try appending a file extension (.less or .js if the path has no extension)\n         * @param currentFileInfo - the current file info (used for instance to work out relative paths)\n         * @param importOptions - import options\n         * @param callback - callback for when it is imported\n         */\n        push(path, tryAppendExtension, currentFileInfo, importOptions, callback) {\n            const importManager = this;\n            const pluginLoader = this.context.pluginManager.Loader;\n\n            this.queue.push(path);\n\n            const fileParsedFunc = (e, root, fullPath) => {\n                importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue\n\n                const importedEqualsRoot = fullPath === importManager.rootFilename;\n                if (importOptions.optional && e) {\n                    callback(null, {rules:[]}, false, null);\n                    logger.info(`The file ${fullPath} was skipped because it was not found and the import was marked optional.`);\n                }\n                else {\n                    // Inline imports aren't cached here.\n                    // If we start to cache them, please make sure they won't conflict with non-inline imports of the\n                    // same name as they used to do before this comment and the condition below have been added.\n                    if (!importManager.files[fullPath] && !importOptions.inline) {\n                        importManager.files[fullPath] = { root, options: importOptions };\n                    }\n                    if (e && !importManager.error) { importManager.error = e; }\n                    callback(e, root, importedEqualsRoot, fullPath);\n                }\n            };\n\n            const newFileInfo = {\n                rewriteUrls: this.context.rewriteUrls,\n                entryPath: currentFileInfo.entryPath,\n                rootpath: currentFileInfo.rootpath,\n                rootFilename: currentFileInfo.rootFilename\n            };\n\n            const fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);\n\n            if (!fileManager) {\n                fileParsedFunc({ message: `Could not find a file-manager for ${path}` });\n                return;\n            }\n\n            const loadFileCallback = loadedFile => {\n                let plugin;\n                const resolvedFilename = loadedFile.filename;\n                const contents = loadedFile.contents.replace(/^\\uFEFF/, '');\n\n                // Pass on an updated rootpath if path of imported file is relative and file\n                // is in a (sub|sup) directory\n                //\n                // Examples:\n                // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',\n                //   then rootpath should become 'less/module/nav/'\n                // - If path of imported file is '../mixins.less' and rootpath is 'less/',\n                //   then rootpath should become 'less/../'\n                newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);\n                if (newFileInfo.rewriteUrls) {\n                    newFileInfo.rootpath = fileManager.join(\n                        (importManager.context.rootpath || ''),\n                        fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));\n\n                    if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {\n                        newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);\n                    }\n                }\n                newFileInfo.filename = resolvedFilename;\n\n                const newEnv = new contexts.Parse(importManager.context);\n\n                newEnv.processImports = false;\n                importManager.contents[resolvedFilename] = contents;\n\n                if (currentFileInfo.reference || importOptions.reference) {\n                    newFileInfo.reference = true;\n                }\n\n                if (importOptions.isPlugin) {\n                    plugin = pluginLoader.evalPlugin(contents, newEnv, importManager, importOptions.pluginArgs, newFileInfo);\n                    if (plugin instanceof LessError) {\n                        fileParsedFunc(plugin, null, resolvedFilename);\n                    }\n                    else {\n                        fileParsedFunc(null, plugin, resolvedFilename);\n                    }\n                } else if (importOptions.inline) {\n                    fileParsedFunc(null, contents, resolvedFilename);\n                } else {\n\n                    // import (multiple) parse trees apparently get altered and can't be cached.\n                    // TODO: investigate why this is\n                    if (importManager.files[resolvedFilename]\n                        && !importManager.files[resolvedFilename].options.multiple\n                        && !importOptions.multiple) {\n\n                        fileParsedFunc(null, importManager.files[resolvedFilename].root, resolvedFilename);\n                    }\n                    else {\n                        new Parser(newEnv, importManager, newFileInfo).parse(contents, (e, root) => {\n                            fileParsedFunc(e, root, resolvedFilename);\n                        });\n                    }\n                }\n            };\n            let promise;\n            const context = utils.clone(this.context);\n\n            if (tryAppendExtension) {\n                context.ext = importOptions.isPlugin ? '.js' : '.less';\n            }\n\n            if (importOptions.isPlugin) {\n                context.mime = 'application/javascript';\n                promise = pluginLoader.loadPlugin(path, currentFileInfo.currentDirectory, context, environment, fileManager);\n            }\n            else {\n                promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, context, environment,\n                    (err, loadedFile) => {\n                        if (err) {\n                            fileParsedFunc(err);\n                        } else {\n                            loadFileCallback(loadedFile);\n                        }\n                    });\n            }\n            if (promise) {\n                promise.then(loadFileCallback, fileParsedFunc);\n            }\n        }\n    }\n\n    return ImportManager;\n};\n","let PromiseConstructor;\nimport * as utils from './utils';\n\nexport default (environment, ParseTree, ImportManager) => {\n    const render = function (input, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = utils.copyOptions(this.options, {});\n        }\n        else {\n            options = utils.copyOptions(this.options, options || {});\n        }\n\n        if (!callback) {\n            const self = this;\n            return new Promise((resolve, reject) => {\n                render.call(self, input, options, (err, output) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(output);\n                    }\n                });\n            });\n        } else {\n            this.parse(input, options, (err, root, imports, options) => {\n                if (err) { return callback(err); }\n\n                let result;\n                try {\n                    const parseTree = new ParseTree(root, imports);\n                    result = parseTree.toCSS(options);\n                }\n                catch (err) { return callback(err); }\n\n                callback(null, result);\n            });\n        }\n    };\n\n    return render;\n};\n","let PromiseConstructor;\nimport contexts from './contexts';\nimport Parser from './parser/parser';\nimport PluginManager from './plugin-manager';\nimport LessError from './less-error';\nimport * as utils from './utils';\n\nexport default (environment, ParseTree, ImportManager) => {\n    const parse = function (input, options, callback) {\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = utils.copyOptions(this.options, {});\n        }\n        else {\n            options = utils.copyOptions(this.options, options || {});\n        }\n\n        if (!callback) {\n            const self = this;\n            return new Promise((resolve, reject) => {\n                parse.call(self, input, options, (err, output) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(output);\n                    }\n                });\n            });\n        } else {\n            let context;\n            let rootFileInfo;\n            const pluginManager = new PluginManager(this, !options.reUsePluginManager);\n\n            options.pluginManager = pluginManager;\n\n            context = new contexts.Parse(options);\n\n            if (options.rootFileInfo) {\n                rootFileInfo = options.rootFileInfo;\n            } else {\n                const filename = options.filename || 'input';\n                const entryPath = filename.replace(/[^\\/\\\\]*$/, '');\n                rootFileInfo = {\n                    filename,\n                    rewriteUrls: context.rewriteUrls,\n                    rootpath: context.rootpath || '',\n                    currentDirectory: entryPath,\n                    entryPath,\n                    rootFilename: filename\n                };\n                // add in a missing trailing slash\n                if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== '/') {\n                    rootFileInfo.rootpath += '/';\n                }\n            }\n\n            const imports = new ImportManager(this, context, rootFileInfo);\n            this.importManager = imports;\n\n            // TODO: allow the plugins to be just a list of paths or names\n            // Do an async plugin queue like lessc\n\n            if (options.plugins) {\n                options.plugins.forEach(plugin => {\n                    let evalResult;\n                    let contents;\n                    if (plugin.fileContent) {\n                        contents = plugin.fileContent.replace(/^\\uFEFF/, '');\n                        evalResult = pluginManager.Loader.evalPlugin(contents, context, imports, plugin.options, plugin.filename);\n                        if (evalResult instanceof LessError) {\n                            return callback(evalResult);\n                        }\n                    }\n                    else {\n                        pluginManager.addPlugin(plugin);\n                    }\n                });\n            }\n\n            new Parser(context, imports, rootFileInfo)\n                .parse(input, (e, root) => {\n                    if (e) { return callback(e); }\n                    callback(null, root, imports, options);\n                }, options);\n        }\n    };\n    return parse;\n};\n","// TODO: Add tests for browser @plugin\n/* global window */\n\nimport AbstractPluginLoader from '../less/environment/abstract-plugin-loader.js';\n\n/**\n * Browser Plugin Loader\n */\nclass PluginLoader extends AbstractPluginLoader {\n    constructor(less) {\n        super();\n\n        this.less = less;\n        // Should we shim this.require for browser? Probably not?\n    }\n\n    loadPlugin(filename, basePath, context, environment, fileManager) {\n        return new Promise((fulfill, reject) => {\n            fileManager.loadFile(filename, basePath, context, environment)\n                .then(fulfill).catch(reject);\n        });\n    }\n}\n\nexport default PluginLoader;\n\n","import * as utils from './utils';\nimport browser from './browser';\n\nexport default (window, less, options) => {\n\n    function errorHTML(e, rootHref) {\n        const id = `less-error-message:${utils.extractId(rootHref || '')}`;\n        const template = '<li><label>{line}</label><pre class=\"{class}\">{content}</pre></li>';\n        const elem = window.document.createElement('div');\n        let timer;\n        let content;\n        const errors = [];\n        const filename = e.filename || rootHref;\n        const filenameNoPath = filename.match(/([^\\/]+(\\?.*)?)$/)[1];\n\n        elem.id        = id;\n        elem.className = 'less-error-message';\n\n        content = `<h3>${e.type || 'Syntax'}Error: ${e.message || 'There is an error in your .less file'}` + \n            `</h3><p>in <a href=\"${filename}\">${filenameNoPath}</a> `;\n\n        const errorline = (e, i, classname) => {\n            if (e.extract[i] !== undefined) {\n                errors.push(template.replace(/\\{line\\}/, (parseInt(e.line, 10) || 0) + (i - 1))\n                    .replace(/\\{class\\}/, classname)\n                    .replace(/\\{content\\}/, e.extract[i]));\n            }\n        };\n\n        if (e.line) {\n            errorline(e, 0, '');\n            errorline(e, 1, 'line');\n            errorline(e, 2, '');\n            content += `on line ${e.line}, column ${e.column + 1}:</p><ul>${errors.join('')}</ul>`;\n        }\n        if (e.stack && (e.extract || options.logLevel >= 4)) {\n            content += `<br/>Stack Trace</br />${e.stack.split('\\n').slice(1).join('<br/>')}`;\n        }\n        elem.innerHTML = content;\n\n        // CSS for error messages\n        browser.createCSS(window.document, [\n            '.less-error-message ul, .less-error-message li {',\n            'list-style-type: none;',\n            'margin-right: 15px;',\n            'padding: 4px 0;',\n            'margin: 0;',\n            '}',\n            '.less-error-message label {',\n            'font-size: 12px;',\n            'margin-right: 15px;',\n            'padding: 4px 0;',\n            'color: #cc7777;',\n            '}',\n            '.less-error-message pre {',\n            'color: #dd6666;',\n            'padding: 4px 0;',\n            'margin: 0;',\n            'display: inline-block;',\n            '}',\n            '.less-error-message pre.line {',\n            'color: #ff0000;',\n            '}',\n            '.less-error-message h3 {',\n            'font-size: 20px;',\n            'font-weight: bold;',\n            'padding: 15px 0 5px 0;',\n            'margin: 0;',\n            '}',\n            '.less-error-message a {',\n            'color: #10a',\n            '}',\n            '.less-error-message .error {',\n            'color: red;',\n            'font-weight: bold;',\n            'padding-bottom: 2px;',\n            'border-bottom: 1px dashed red;',\n            '}'\n        ].join('\\n'), { title: 'error-message' });\n\n        elem.style.cssText = [\n            'font-family: Arial, sans-serif',\n            'border: 1px solid #e00',\n            'background-color: #eee',\n            'border-radius: 5px',\n            '-webkit-border-radius: 5px',\n            '-moz-border-radius: 5px',\n            'color: #e00',\n            'padding: 15px',\n            'margin-bottom: 15px'\n        ].join(';');\n\n        if (options.env === 'development') {\n            timer = setInterval(() => {\n                const document = window.document;\n                const body = document.body;\n                if (body) {\n                    if (document.getElementById(id)) {\n                        body.replaceChild(elem, document.getElementById(id));\n                    } else {\n                        body.insertBefore(elem, body.firstChild);\n                    }\n                    clearInterval(timer);\n                }\n            }, 10);\n        }\n    }\n\n    function removeErrorHTML(path) {\n        const node = window.document.getElementById(`less-error-message:${utils.extractId(path)}`);\n        if (node) {\n            node.parentNode.removeChild(node);\n        }\n    }\n\n    function removeErrorConsole(path) {\n        // no action\n    }\n\n    function removeError(path) {\n        if (!options.errorReporting || options.errorReporting === 'html') {\n            removeErrorHTML(path);\n        } else if (options.errorReporting === 'console') {\n            removeErrorConsole(path);\n        } else if (typeof options.errorReporting === 'function') {\n            options.errorReporting('remove', path);\n        }\n    }\n\n    function errorConsole(e, rootHref) {\n        const template = '{line} {content}';\n        const filename = e.filename || rootHref;\n        const errors = [];\n        let content = `${e.type || 'Syntax'}Error: ${e.message || 'There is an error in your .less file'} in ${filename}`;\n\n        const errorline = (e, i, classname) => {\n            if (e.extract[i] !== undefined) {\n                errors.push(template.replace(/\\{line\\}/, (parseInt(e.line, 10) || 0) + (i - 1))\n                    .replace(/\\{class\\}/, classname)\n                    .replace(/\\{content\\}/, e.extract[i]));\n            }\n        };\n\n        if (e.line) {\n            errorline(e, 0, '');\n            errorline(e, 1, 'line');\n            errorline(e, 2, '');\n            content += ` on line ${e.line}, column ${e.column + 1}:\\n${errors.join('\\n')}`;\n        }\n        if (e.stack && (e.extract || options.logLevel >= 4)) {\n            content += `\\nStack Trace\\n${e.stack}`;\n        }\n        less.logger.error(content);\n    }\n\n    function error(e, rootHref) {\n        if (!options.errorReporting || options.errorReporting === 'html') {\n            errorHTML(e, rootHref);\n        } else if (options.errorReporting === 'console') {\n            errorConsole(e, rootHref);\n        } else if (typeof options.errorReporting === 'function') {\n            options.errorReporting('add', e, rootHref);\n        }\n    }\n\n    return {\n        add: error,\n        remove: removeError\n    };\n};\n","/**\n * Kicks off less and compiles any stylesheets\n * used in the browser distributed version of less\n * to kick-start less using the browser api\n */\n/* global window, document */\n\nimport defaultOptions from '../less/default-options';\nimport addDefaultOptions from './add-default-options';\nimport root from './index';\n\nconst options = defaultOptions();\n\nif (window.less) {\n    for (const key in window.less) {\n        if (window.less.hasOwnProperty(key)) {\n            options[key] = window.less[key];\n        }\n    }\n}\naddDefaultOptions(window, options);\n\noptions.plugins = options.plugins || [];\n\nif (window.LESS_PLUGINS) {\n    options.plugins = options.plugins.concat(window.LESS_PLUGINS);\n}\n\nconst less = root(window, options);\nexport default less;\n\nwindow.less = less;\n\nlet css;\nlet head;\nlet style;\n\n// Always restore page visibility\nfunction resolveOrReject(data) {\n    if (data.filename) {\n        console.warn(data);\n    }\n    if (!options.async) {\n        head.removeChild(style);\n    }\n}\n\nif (options.onReady) {\n    if (/!watch/.test(window.location.hash)) {\n        less.watch();\n    }\n    // Simulate synchronous stylesheet loading by hiding page rendering\n    if (!options.async) {\n        css = 'body { display: none !important }';\n        head = document.head || document.getElementsByTagName('head')[0];\n        style = document.createElement('style');\n\n        style.type = 'text/css';\n        if (style.styleSheet) {\n            style.styleSheet.cssText = css;\n        } else {\n            style.appendChild(document.createTextNode(css));\n        }\n\n        head.appendChild(style);\n    }\n    less.registerStylesheetsImmediately();\n    less.pageLoadFinished = less.refresh(less.env === 'development').then(resolveOrReject, resolveOrReject);\n}\n","// Export a new default each time\nexport default () => ({\n    /* Inline Javascript - @plugin still allowed */\n    javascriptEnabled: false,\n\n    /* Outputs a makefile import dependency list to stdout. */\n    depends: false,\n\n    /* (DEPRECATED) Compress using less built-in compression. \n  * This does an okay job but does not utilise all the tricks of \n  * dedicated css compression. */\n    compress: false,\n\n    /* Runs the less parser and just reports errors without any output. */\n    lint: false,\n\n    /* Sets available include paths.\n  * If the file in an @import rule does not exist at that exact location, \n  * less will look for it at the location(s) passed to this option. \n  * You might use this for instance to specify a path to a library which \n  * you want to be referenced simply and relatively in the less files. */\n    paths: [],\n\n    /* color output in the terminal */\n    color: true,\n\n    /* The strictImports controls whether the compiler will allow an @import inside of either \n  * @media blocks or (a later addition) other selector blocks.\n  * See: https://github.com/less/less.js/issues/656 */\n    strictImports: false,\n\n    /* Allow Imports from Insecure HTTPS Hosts */\n    insecure: false,\n\n    /* Allows you to add a path to every generated import and url in your css. \n  * This does not affect less import statements that are processed, just ones \n  * that are left in the output css. */\n    rootpath: '',\n\n    /* By default URLs are kept as-is, so if you import a file in a sub-directory \n  * that references an image, exactly the same URL will be output in the css. \n  * This option allows you to re-write URL's in imported files so that the \n  * URL is always relative to the base imported file */\n    rewriteUrls: false,\n\n    /* How to process math \n  *   0 always           - eagerly try to solve all operations\n  *   1 parens-division  - require parens for division \"/\"\n  *   2 parens | strict  - require parens for all operations\n  *   3 strict-legacy    - legacy strict behavior (super-strict)\n  */\n    math: 0,\n\n    /* Without this option, less attempts to guess at the output unit when it does maths. */\n    strictUnits: false,\n\n    /* Effectively the declaration is put at the top of your base Less file, \n  * meaning it can be used but it also can be overridden if this variable \n  * is defined in the file. */\n    globalVars: null,\n\n    /* As opposed to the global variable option, this puts the declaration at the\n  * end of your base file, meaning it will override anything defined in your Less file. */\n    modifyVars: null,\n\n    /* This option allows you to specify a argument to go on to every URL.  */\n    urlArgs: ''\n});","import {addDataAttr} from './utils';\nimport browser from './browser';\n\nexport default (window, options) => {\n\n    // use options from the current script tag data attribues\n    addDataAttr(options, browser.currentScript(window));\n\n    if (options.isFileProtocol === undefined) {\n        options.isFileProtocol = /^(file|(chrome|safari)(-extension)?|resource|qrc|app):/.test(window.location.protocol);\n    }\n\n    // Load styles asynchronously (default: false)\n    //\n    // This is set to `false` by default, so that the body\n    // doesn't start loading before the stylesheets are parsed.\n    // Setting this to `true` can result in flickering.\n    //\n    options.async = options.async || false;\n    options.fileAsync = options.fileAsync || false;\n\n    // Interval between watch polls\n    options.poll = options.poll || (options.isFileProtocol ? 1000 : 1500);\n\n    options.env = options.env || (window.location.hostname == '127.0.0.1' ||\n        window.location.hostname == '0.0.0.0'   ||\n        window.location.hostname == 'localhost' ||\n        (window.location.port &&\n            window.location.port.length > 0)      ||\n        options.isFileProtocol                   ? 'development'\n        : 'production');\n\n    const dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(window.location.hash);\n    if (dumpLineNumbers) {\n        options.dumpLineNumbers = dumpLineNumbers[1];\n    }\n\n    if (options.useFileCache === undefined) {\n        options.useFileCache = true;\n    }\n\n    if (options.onReady === undefined) {\n        options.onReady = true;\n    }\n\n    if (options.relativeUrls) {\n        options.rewriteUrls = 'all';\n    }\n};\n","//\n// index.js\n// Should expose the additional browser functions on to the less object\n//\nimport {addDataAttr} from './utils';\nimport lessRoot from '../less';\nimport browser from './browser';\nimport FM from './file-manager';\nimport PluginLoader from './plugin-loader';\nimport LogListener from './log-listener';\nimport ErrorReporting from './error-reporting';\nimport Cache from './cache';\nimport ImageSize from './image-size';\n\nexport default (window, options) => {\n    const document = window.document;\n    const less = lessRoot();\n\n    less.options = options;\n    const environment = less.environment;\n    const FileManager = FM(options, less.logger);\n    const fileManager = new FileManager();\n    environment.addFileManager(fileManager);\n    less.FileManager = FileManager;\n    less.PluginLoader = PluginLoader;\n\n    LogListener(less, options);\n    const errors = ErrorReporting(window, less, options);\n    const cache = less.cache = options.cache || Cache(window, options, less.logger);\n    ImageSize(less.environment);\n\n    // Setup user functions - Deprecate?\n    if (options.functions) {\n        less.functions.functionRegistry.addMultiple(options.functions);\n    }\n\n    const typePattern = /^text\\/(x-)?less$/;\n\n    function clone(obj) {\n        const cloned = {};\n        for (const prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                cloned[prop] = obj[prop];\n            }\n        }\n        return cloned;\n    }\n\n    // only really needed for phantom\n    function bind(func, thisArg) {\n        const curryArgs = Array.prototype.slice.call(arguments, 2);\n        return function() {\n            const args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));\n            return func.apply(thisArg, args);\n        };\n    }\n\n    function loadStyles(modifyVars) {\n        const styles = document.getElementsByTagName('style');\n        let style;\n\n        for (let i = 0; i < styles.length; i++) {\n            style = styles[i];\n            if (style.type.match(typePattern)) {\n                const instanceOptions = clone(options);\n                instanceOptions.modifyVars = modifyVars;\n                const lessText = style.innerHTML || '';\n                instanceOptions.filename = document.location.href.replace(/#.*$/, '');\n\n                /* jshint loopfunc:true */\n                // use closure to store current style\n                less.render(lessText, instanceOptions,\n                    bind((style, e, result) => {\n                        if (e) {\n                            errors.add(e, 'inline');\n                        } else {\n                            style.type = 'text/css';\n                            if (style.styleSheet) {\n                                style.styleSheet.cssText = result.css;\n                            } else {\n                                style.innerHTML = result.css;\n                            }\n                        }\n                    }, null, style));\n            }\n        }\n    }\n\n    function loadStyleSheet(sheet, callback, reload, remaining, modifyVars) {\n\n        const instanceOptions = clone(options);\n        addDataAttr(instanceOptions, sheet);\n        instanceOptions.mime = sheet.type;\n\n        if (modifyVars) {\n            instanceOptions.modifyVars = modifyVars;\n        }\n\n        function loadInitialFileCallback(loadedFile) {\n            const data = loadedFile.contents;\n            const path = loadedFile.filename;\n            const webInfo = loadedFile.webInfo;\n\n            const newFileInfo = {\n                currentDirectory: fileManager.getPath(path),\n                filename: path,\n                rootFilename: path,\n                rewriteUrls: instanceOptions.rewriteUrls\n            };\n\n            newFileInfo.entryPath = newFileInfo.currentDirectory;\n            newFileInfo.rootpath = instanceOptions.rootpath || newFileInfo.currentDirectory;\n\n            if (webInfo) {\n                webInfo.remaining = remaining;\n\n                const css = cache.getCSS(path, webInfo, instanceOptions.modifyVars);\n                if (!reload && css) {\n                    webInfo.local = true;\n                    callback(null, css, data, sheet, webInfo, path);\n                    return;\n                }\n\n            }\n\n            // TODO add tests around how this behaves when reloading\n            errors.remove(path);\n\n            instanceOptions.rootFileInfo = newFileInfo;\n            less.render(data, instanceOptions, (e, result) => {\n                if (e) {\n                    e.href = path;\n                    callback(e);\n                } else {\n                    cache.setCSS(sheet.href, webInfo.lastModified, instanceOptions.modifyVars, result.css);\n                    callback(null, result.css, data, sheet, webInfo, path);\n                }\n            });\n        }\n\n        fileManager.loadFile(sheet.href, null, instanceOptions, environment)\n            .then(loadedFile => {\n                loadInitialFileCallback(loadedFile);\n            }).catch(err => {\n                console.log(err);\n                callback(err);\n            });\n\n    }\n\n    function loadStyleSheets(callback, reload, modifyVars) {\n        for (let i = 0; i < less.sheets.length; i++) {\n            loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), modifyVars);\n        }\n    }\n\n    function initRunningMode() {\n        if (less.env === 'development') {\n            less.watchTimer = setInterval(() => {\n                if (less.watchMode) {\n                    fileManager.clearFileCache();\n                    loadStyleSheets((e, css, _, sheet, webInfo) => {\n                        if (e) {\n                            errors.add(e, e.href || sheet.href);\n                        } else if (css) {\n                            browser.createCSS(window.document, css, sheet);\n                        }\n                    });\n                }\n            }, options.poll);\n        }\n    }\n\n    //\n    // Watch mode\n    //\n    less.watch   = function () {\n        if (!less.watchMode ) {\n            less.env = 'development';\n            initRunningMode();\n        }\n        this.watchMode = true;\n        return true;\n    };\n\n    less.unwatch = function () {clearInterval(less.watchTimer); this.watchMode = false; return false; };\n\n    //\n    // Synchronously get all <link> tags with the 'rel' attribute set to\n    // \"stylesheet/less\".\n    //\n    less.registerStylesheetsImmediately = () => {\n        const links = document.getElementsByTagName('link');\n        less.sheets = [];\n\n        for (let i = 0; i < links.length; i++) {\n            if (links[i].rel === 'stylesheet/less' || (links[i].rel.match(/stylesheet/) &&\n                (links[i].type.match(typePattern)))) {\n                less.sheets.push(links[i]);\n            }\n        }\n    };\n\n    //\n    // Asynchronously get all <link> tags with the 'rel' attribute set to\n    // \"stylesheet/less\", returning a Promise.\n    //\n    less.registerStylesheets = () => new Promise((resolve, reject) => {\n        less.registerStylesheetsImmediately();\n        resolve();\n    });\n\n    //\n    // With this function, it's possible to alter variables and re-render\n    // CSS without reloading less-files\n    //\n    less.modifyVars = record => less.refresh(true, record, false);\n\n    less.refresh = (reload, modifyVars, clearFileCache) => {\n        if ((reload || clearFileCache) && clearFileCache !== false) {\n            fileManager.clearFileCache();\n        }\n        return new Promise((resolve, reject) => {\n            let startTime;\n            let endTime;\n            let totalMilliseconds;\n            let remainingSheets;\n            startTime = endTime = new Date();\n\n            // Set counter for remaining unprocessed sheets\n            remainingSheets = less.sheets.length;\n\n            if (remainingSheets === 0) {\n\n                endTime = new Date();\n                totalMilliseconds = endTime - startTime;\n                less.logger.info('Less has finished and no sheets were loaded.');\n                resolve({\n                    startTime,\n                    endTime,\n                    totalMilliseconds,\n                    sheets: less.sheets.length\n                });\n\n            } else {\n                // Relies on less.sheets array, callback seems to be guaranteed to be called for every element of the array\n                loadStyleSheets((e, css, _, sheet, webInfo) => {\n                    if (e) {\n                        errors.add(e, e.href || sheet.href);\n                        reject(e);\n                        return;\n                    }\n                    if (webInfo.local) {\n                        less.logger.info(`Loading ${sheet.href} from cache.`);\n                    } else {\n                        less.logger.info(`Rendered ${sheet.href} successfully.`);\n                    }\n                    browser.createCSS(window.document, css, sheet);\n                    less.logger.info(`CSS for ${sheet.href} generated in ${new Date() - endTime}ms`);\n\n                    // Count completed sheet\n                    remainingSheets--;\n\n                    // Check if the last remaining sheet was processed and then call the promise\n                    if (remainingSheets === 0) {\n                        totalMilliseconds = new Date() - startTime;\n                        less.logger.info(`Less has finished. CSS generated in ${totalMilliseconds}ms`);\n                        resolve({\n                            startTime,\n                            endTime,\n                            totalMilliseconds,\n                            sheets: less.sheets.length\n                        });\n                    }\n                    endTime = new Date();\n                }, reload, modifyVars);\n            }\n\n            loadStyles(modifyVars);\n        });\n    };\n\n    less.refreshStyles = loadStyles;\n    return less;\n};\n","export default (less, options) => {\n    const logLevel_debug = 4;\n    const logLevel_info = 3;\n    const logLevel_warn = 2;\n    const logLevel_error = 1;\n\n    // The amount of logging in the javascript console.\n    // 3 - Debug, information and errors\n    // 2 - Information and errors\n    // 1 - Errors\n    // 0 - None\n    // Defaults to 2\n    options.logLevel = typeof options.logLevel !== 'undefined' ? options.logLevel : (options.env === 'development' ?  logLevel_info : logLevel_error);\n\n    if (!options.loggers) {\n        options.loggers = [{\n            debug: function(msg) {\n                if (options.logLevel >= logLevel_debug) {\n                    console.log(msg);\n                }\n            },\n            info: function(msg) {\n                if (options.logLevel >= logLevel_info) {\n                    console.log(msg);\n                }\n            },\n            warn: function(msg) {\n                if (options.logLevel >= logLevel_warn) {\n                    console.warn(msg);\n                }\n            },\n            error: function(msg) {\n                if (options.logLevel >= logLevel_error) {\n                    console.error(msg);\n                }\n            }\n        }];\n    }\n    for (let i = 0; i < options.loggers.length; i++) {\n        less.logger.addListener(options.loggers[i]);\n    }\n};\n","// Cache system is a bit outdated and could do with work\n\nexport default (window, options, logger) => {\n    let cache = null;\n    if (options.env !== 'development') {\n        try {\n            cache = (typeof window.localStorage === 'undefined') ? null : window.localStorage;\n        } catch (_) {}\n    }\n    return {\n        setCSS: function(path, lastModified, modifyVars, styles) {\n            if (cache) {\n                logger.info(`saving ${path} to cache.`);\n                try {\n                    cache.setItem(path, styles);\n                    cache.setItem(`${path}:timestamp`, lastModified);\n                    if (modifyVars) {\n                        cache.setItem(`${path}:vars`, JSON.stringify(modifyVars));\n                    }\n                } catch (e) {\n                    // TODO - could do with adding more robust error handling\n                    logger.error(`failed to save \"${path}\" to local storage for caching.`);\n                }\n            }\n        },\n        getCSS: function(path, webInfo, modifyVars) {\n            const css       = cache && cache.getItem(path);\n            const timestamp = cache && cache.getItem(`${path}:timestamp`);\n            let vars      = cache && cache.getItem(`${path}:vars`);\n\n            modifyVars = modifyVars || {};\n            vars = vars || \"{}\"; // if not set, treat as the JSON representation of an empty object\n\n            if (timestamp && webInfo.lastModified &&\n                (new Date(webInfo.lastModified).valueOf() ===\n                    new Date(timestamp).valueOf()) &&\n                JSON.stringify(modifyVars) === vars) {\n                // Use local copy\n                return css;\n            }\n        }\n    };\n};\n","\nimport functionRegistry from './../less/functions/function-registry';\n\nexport default () => {\n    function imageSize() {\n        throw {\n            type: 'Runtime',\n            message: 'Image size functions are not supported in browser version of less'\n        };\n    }\n\n    const imageFunctions = {\n        'image-size': function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        },\n        'image-width': function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        },\n        'image-height': function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        }\n    };\n\n    functionRegistry.addMultiple(imageFunctions);\n};\n"],"names":["extractId","href","replace","addDataAttr","options","tag","opt","dataset","hasOwnProperty","JSON","parse","_","createCSS","document","styles","sheet","id","title","utils.extractId","oldStyleNode","getElementById","keepOldStyleNode","styleNode","createElement","setAttribute","media","styleSheet","appendChild","createTextNode","childNodes","length","firstChild","nodeValue","head","getElementsByTagName","nextEl","nextSibling","parentNode","insertBefore","removeChild","cssText","e","Error","currentScript","window","scripts","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgrey","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","m","cm","mm","in","px","pt","pc","duration","s","ms","angle","rad","Math","PI","deg","grad","turn","colors","unitConversions","this","parent","visibilityBlocks","undefined","nodeVisible","rootNode","parsed","self","Object","defineProperty","get","fileInfo","getIndex","Node","nodes","set","node","Array","isArray","forEach","_index","_fileInfo","context","strs","genCSS","add","chunk","index","push","isEmpty","join","output","value","visitor","visit","op","a","b","precision","numPrecision","Number","toFixed","info","compare","type","i_1","numericCompare","rgb","originalForm","_super","_this","match","map","c","i","parseInt","alpha","split","__extends","Color","r","g","pow","toCSS","doNotCompress","color","colorFunction","compress","args","fround","indexOf","clamp","round","concat","toHSL","h","l","toRGB","splitcolor","other","_operate","toHex","max","min","d","v","x","toString","prototype","fromKeyword","keyword","key","toLowerCase","slice","Paren","eval","_noSpaceCombinators"," ","|","emptyOrWhitespace","trim","Combinator","spaceOrEmpty","combinator","isVariable","currentFileInfo","visibilityInfo","copyVisibilityInfo","setParent","Element","firstSelector","charAt","ALWAYS","PARENS_DIVISION","PARENS","STRICT_LEGACY","RewriteUrls","OFF","LOCAL","ALL","clone","_instanceof","obj","nativeMap","nativeSet","nativePromise","Map","Set","Promise","circular","depth","includeNonEnumerable","allParents","allChildren","useBuffer","Buffer","Infinity","_clone","child","proto","resolve","reject","then","err","__isArray","__isRegExp","RegExp","source","__getRegExpFlags","lastIndex","__isDate","Date","getTime","isBuffer","allocUnsafe","copy","create","getPrototypeOf","keyChild","valueChild","entryChild","attrs","getOwnPropertyDescriptor","getOwnPropertySymbols","symbols","symbol","descriptor","enumerable","allPropertyNames","getOwnPropertyNames","propertyName","__objToStr","o","call","re","flags","global","ignoreCase","multiline","clonePrototype","module","exports","getLocation","inputStream","n","line","column","copyArray","arr","cloned","prop","defaults","obj1","obj2","newObj","_defaults","defaults_1","CloneHelper","assign","copyOptions","opts","strictMath","math","Constants.Math","relativeUrls","rewriteUrls","Constants.RewriteUrls","flattenArray","result","length_1","anonymousFunc","LessError","fileContentMap","currentFilename","filename","message","stack","input","contents","loc","utils.getLocation","col","callLine","lines","found","func","Function","lineAdjust","callExtract","extract","F","constructor","error","stylize","str","errorTxt","substr","elements","extendList","condition","evaldCondition","getElements","mixinElements_","Selector","visitArray","newSelector","mediaEmpty","els","parseNode","imports","sels","olen","len","mixinElements","shift","extend","createDerived","Value","Keyword","True","False","mapLines","rulesetLike","allowRoot","Anonymous","Boolean","MATH","name","important","merge","inline","variable","Declaration","lastRule","prevMath","evaldValue","mathBypass","evalName","importantScope","importantResult","pop","debugInfo","ctx","lineSeparator","dumpLineNumbers","asComment","asMediaQuery","lineNumber","fileName","filenameWithProtocol","test","isLineComment","Comment","getDebugInfo","isCompressed","contexts","copyFromOriginal","original","destination","propertiesToCopy","parseCopyProperties","Parse","paths","evalCopyProperties","isPathRelative","path","isPathLocalRelative","Eval","frames","inCalc","mathOn","calcStack","parensStack","rootpath","newPath","normalizePath","segment","segments","reverse","makeRegistry","base","_data","addMultiple","functions","keys","getLocalFunctions","inherit","defaultFunc","value_","error_","reset","selectors","rules","strictImports","_lookups","_variables","_properties","Ruleset","selCnt","selector","hasVariable","hasOnePassingSelector","j","toParseSelectors","utils.flattenArray","rule","subRule","utils.copyArray","ruleset","originalRuleset","root","firstRoot","allowImports","functionRegistry","globalFunctionRegistry","ctxFrames","unshift","ctxSelectors","evalImports","rsRules","evalFirst","mediaBlockCount","mediaBlocks","filter","splice","resetCache","isJustParentSelector","bubbleSelectors","importRules","makeImportant","lastSelector","_rulesets","reduce","hash","variables","vars","name_1","name_2","decl","parseValue","properties","toParse","transformDeclaration","nodes_1","filtRules","isRuleset","foundMixins","rulesets","find","i_2","apply","ruleNodes","tabLevel","sep","tabRuleStr","tabSetStr","charsetNodeIndex","importNodeIndex","isCharset","pathCnt","pathSubCnt","currentLastRule","isRulesetLike","isVisible","joinSelector","createParenthesis","elementsToPak","originalElement","replacementParen","insideParent","createSelector","containedElement","element","addReplacementIntoPath","beginningPath","addPath","replacedElement","originalSelector","newSelectorPath","newJoinedSelector","parentEl","restOfPath","addAllReplacementsIntoPath","addPaths","mergeElementsOnToSelectors","sel","deriveSelector","deriveFrom","newPaths","replaceParentSelector","inSelector","k","currentElements","newSelectors","selectorsMultiplied","el","maybeSelector","hadParentSelector","nestedSelector","replaced","nestedPaths","replacedNewSelectors","concatenated","bind","isRooted","createEmptySelectors","AtRule","outputRuleset","mediaPathBackup","mediaBlocksBackup","mediaPath","_i","ruleCnt","DetachedRuleset","numerator","denominator","backupUnit","sort","Unit","strictUnits","returnStr","is","unitString","toUpperCase","callback","group","mapUnit","groupName","atomicUnit","counter","count","unit","parseFloat","isNaN","Dimension","isSingular","strValue","String","isLength","convertTo","usedUnits","cancel","unify","conversions","targetUnit","applyUnit","derivedConversions","operands","isSpaced","Operation","isMathOn","toColor","operate","noSpacing","Expression","returnValue","inParenthesis","parens","parensInOp","doubleParen","outOfParenthesis","functionCaller","item","subNodes","calc","Call","currentMathContext","enterCalc","exitCalc","funcCaller","FunctionCaller","isValid","columnNumber","Variable","evaluating","frame","fun","Property","property","mergeRules","pluginManager","less","visitors","ToCSSVisitor","_mergeRules","vArr","Attribute","content","escaped","quote","variableRegex","propRegex","Quoted","that","iterativeReplace","regexp","replacementFnc","evaluatedValue","val","isEvald","URL","pathRequiresRewrite","rewritePath","urlArgs","features","Media","evalTop","evalNested","multiMedia","permute","fragment","rest","css","pathValue","getPath","Import","isPlugin","reference","containsVariables","doEval","blocksVisibility","addVisibilityBlock","registry","skip","importedFilename","newImport","evalPath","string","expression","JavaScript","evaluateJavaScript","JsEvalNode","evalContext","javascriptEnabled","jsify","toJS","Assignment","negate","lvalue","rvalue","Condition","UnicodeDescriptor","Negative","option","object_id","Extend","next_id","parent_ids","allowBefore","allowAfter","selectorElements","selfElements","selfSelectors","VariableCall","detachedRuleset","callEval","ruleCall","lookups","NamespaceValue","lastDeclaration","substring","params","variadic","arity","optionalParameters","required","p","Definition","mixinEnv","evaldArguments","varargs","arg","isNamedFound","argIndex","argsLength","prependRule","_arguments","mixinFrames","evalParams","allArgsCnt","requiredArgsCnt","arguments","MixinCall","mixins","mixin","mixinPath","argValue","f","isRecursive","isOneFound","candidate","defaultResult","noArgumentsFilter","candidates","conditionResult","defFalseEitherCase","defNone","defTrue","defFalse","calcDefGroup","namespace","matchCondition","expand","matchArgs","MixinDefinition","format","newRules","evalCall","_setVisibilityToReplacement","replacement","msg","_fireEvent","warn","debug","addListener","listener","_listeners","removeListener","logFunction","externalEnvironment","fileManagers","requiredFunctions","propName","environmentFunc","environment","currentDirectory","isSync","logger","getFileManagers","fileManager","AbstractFileManager","lastIndexOf","ext","tryAppendExtension","basePath","laterPath","url","baseUrl","urlDirectories","baseUrlDirectories","urlParts","extractUrlParts","baseUrlParts","diff","hostPart","directories","urlPartsRegex","returner","rawDirectories","rawPath","fileUrl","require","AbstractPluginLoader","pluginOptions","pluginObj","localModule","shortname","FileManager","trySetOptions","use","loader","tree","validatePlugin","minVersion","compareVersion","addPlugin","plugin","setOptions","version","versionToString","aVersion","bVersion","versionString","plugins","i_3","printUsage","_visitArgs","visitDeeper","_hasIndexed","_noop","implementation","_implementation","_visitInCache","_visitOutCache","indexNodeTypes","ticker","typeIndex","Visitor","nodeTypeIndex","fnName","impl","funcOut","visitArgs","newNode","isReplacing","accept","nonReplacing","cnt","out","evald","flatten","nestedCnt","nestedItem","onSequencerEmpty","variableImports","_onSequencerEmpty","_currentDepth","ImportSequencer","importSequencer","importItem","isReady","tryRun","variableImport","ImportVisitor","importer","finish","_visitor","_importer","_finish","importCount","onceFileDetectionMap","recursionDetector","_sequencer","run","isFinished","visitImport","importNode","inlineCSS","importParent","isVariableImport","addVariableImport","processImportNode","evaldImportNode","evalForImport","multiple","importMultiple","tryAppendLessExtension","onImported","sequencedOnImported","addImport","importedAtRoot","fullPath","importVisitor","isOptional","optional","duplicateImport","oldContext","visitDeclaration","declNode","visitDeclarationOut","visitAtRule","atRuleNode","visitAtRuleOut","visitMixinDefinition","mixinDefinitionNode","visitMixinDefinitionOut","visitRuleset","rulesetNode","visitRulesetOut","visitMedia","mediaNode","visitMediaOut","visible","SetTreeVisibilityVisitor","ensureVisibility","ensureInvisibility","allExtendsStack","ExtendFinderVisitor","allExtends","allSelectorsExtendList","extendOnEveryPath","selectorPath","selExtendList","allSelectorsExtend","foundExtends","findSelfSelectors","firstExtendOnThisSelectorPath","ProcessExtendsVisitor","extendFinder","extendIndices","doExtendChaining","newRoot","checkExtendsForNonMatched","indices","hasFoundMatches","extendsList","extendsListTarget","iterationCount","extendIndex","targetExtendIndex","matches","targetExtend","newExtend","extendsToAdd","extendVisitor","findMatch","selfSelector","extendSelector","extendChainCount","selectorOne","selectorTwo","ruleNode","selectorNode","pathIndex","selectorsToAdd","extendedSelectors","haystackSelectorPath","haystackSelectorIndex","hackstackSelector","hackstackElementIndex","haystackElement","targetCombinator","potentialMatch","needleElements","potentialMatches","matched","initialCombinator","isElementValuesEqual","finished","endPathIndex","endPathElementIndex","elementValue1","elementValue2","replacementSelector","matchIndex","firstElement","newElements","currentSelectorPathIndex","currentSelectorPathElementIndex","currentValue","derived","newAllExtends","JoinSelectorVisitor","getIsOutput","joinSelectors","_context","CSSVisitorUtils","bodyRules","isSilent","owner","thing","originalRules","containsSilentNonBlockedChild","compiledRulesBody","keepOnlyVisibleChilds","removeVisibilityBlock","hasVisibleSelector","utils","mixinNode","visitExtend","extendNode","visitComment","commentNode","resolveVisibility","visitAtRuleWithBody","visitAtRuleWithoutBody","visitAnonymous","anonymousNode","nodeRules","hasFakeRuleset","getBodyRules","charset","comment","checkValidNodes","isRoot","_compileRulesetPaths","nodeRuleCnt","_removeDuplicateRules","isVisibleRuleset","ruleList","ruleCache","ruleCSS","groups","groupsArr","result_1","space_1","comma_1","MarkVisibleSelectorsVisitor","ExtendVisitor","furthest","furthestPossibleErrorMessage","chunks","current","currentPos","saveStack","parserInput","CHARCODE_SPACE","CHARCODE_TAB","CHARCODE_LF","CHARCODE_CR","CHARCODE_FORWARD_SLASH","skipWhitespace","nextChar","oldi","oldj","curr","endIndex","mem","inp","charCodeAt","autoCommentAbsorb","nextNewLine","text","commentStore","nextStarSlash","save","restore","possibleErrorMessage","state","forget","isWhitespace","offset","pos","code","$re","tok","exec","$char","$str","tokLength","$quoted","startChar","currentPosition","$parseUntil","testChar","returnVal","inComment","blockDepth","blockStack","parseGroups","startPos","lastPos","loop","char","expected","peek","peekChar","currentChar","prevChar","getInput","peekNotNumeric","start","chunkInput","failFunction","fail","lastOpening","lastOpeningParen","lastMultiComment","lastMultiCommentEndBrace","chunkerCurrentIndex","currentChunkStartIndex","cc","cc2","level","parenLevel","emitFrom","emitChunk","force","fromCharCode","chunker","end","furthestReachedEnd","furthestChar","Parser","parsers","getParserInput","expect","expectChar","parseList","currentIndex","returnNodes","parser","additionalData","globalVars","modifyVars","ignored","preText","serializeVars","preProcessors","getPreProcessors","process","banner","contentsIgnoredChars","primary","endInfo","processImports","extendRule","definition","declaration","variableCall","entities","atrule","foundSemiColon","mixinLookup","quoted","forceEscaped","isEscaped","customFuncCall","stop","ieAlpha","boolean","if","prevArgs","isSemiColonSeparated","argsComma","argsSemiColon","assignment","literal","dimension","unicodeDescriptor","entity","ch","variableCurly","curly","propertyCurly","colorKeyword","ud","javascript","js","escape","parsedName","inValue","ruleLookups","isRule","getLookup","hasParens","elem","elemIndex","isCall","expressionContainsNamed","nameLoop","expressions","hasSep","throwAwayComments","cond","argInfo","conditions","block","lookupValue","attribute","slashedCombinator","isLess","when","blockRuleset","hasDR","ruleProperty","permissiveValue","anonymousValue","untilTokens","done","testCurrentChar","import","dir","options_1","importOptions","mediaFeatures","optionName","importOption","mediaFeature","pluginArgs","nonVendorSpecificName","hasIdentifier","hasExpression","hasUnknown","hasBlock","sub","addition","multiplication","operation","operand","needsParens","logical","next","conditionAnd","negatedCondition","parenthesisCondition","atomicCondition","body","me","tryConditionFollowedByParenthesis","delim","simpleProperty","colorFunctions","trueValue","falseValue","hsla","origColor","hsl","toHSV","number","rgba","size","m1_1","m2_1","hue","hsv","hsva","vs","floor","perm","saturation","lightness","hsvhue","hsvsaturation","hsvvalue","luma","luminance","saturate","amount","method","desaturate","lighten","darken","fadein","fadeout","fade","spin","mix","color1","color2","weight","w","w1","w2","greyscale","contrast","dark","light","threshold","t","argb","toARGB","tint","shade","colorBlend","mode","cb","cs","ar","cr","ab","as","colorBlendModeFunctions","multiply","screen","overlay","softlight","sqrt","hardlight","difference","abs","exclusion","average","negation","getItemsFromNode","_SELF","values","range","step","from","to","stepValue","list","each","rs","iterator","Quote","valueName","keyName","indexName","MathHelper","fn","mathFunctions","ceil","sin","cos","atan","asin","acos","mathHelper","fraction","num","pm","minMax","isMin","currentUnified","referenceUnified","unitStatic","unitClone","order","convert","pi","mod","y","percentage","evaluated","encodeURI","pattern","%","token","encodeURIComponent","isa","Type","isunit","isruleset","iscolor","isnumber","isstring","iskeyword","isurl","ispixel","ispercentage","isem","get-unit","colorBlending","fallback","functionThis","data-uri","mimetypeNode","filePathNode","mimetype","filePath","entryPath","fragmentStart","utils.clone","rawBuffer","getFileManager","useBase64","mimeLookup","charsetLookup","fileSync","loadFileSync","buf","encodeBase64","uri","dataUri","svg-gradient","direction","stops","gradientDirectionSvg","position","positionValue","gradientType","rectangleDimension","renderEnv","directionValue","throwArgumentDescriptor","types","evaldRoot","evalEnv","visitorIterator","preEvalVisitors","first","isPreEvalVisitor","isPreVisitor","postProcessors","installedPlugins","pluginCache","Loader","PluginLoader","PluginManager","install","preProcessor","priority","indexToInsertAt","postProcessor","manager","PluginManagerFactory","newFactory","SourceMapOutput","_css","_rootNode","_contentsMap","contentsMap","_contentsIgnoredCharsMap","contentsIgnoredCharsMap","sourceMapFilename","_sourceMapFilename","_outputFilename","outputFilename","sourceMapURL","sourceMapBasepath","_sourceMapBasepath","sourceMapRootpath","_sourceMapRootpath","_outputSourceFiles","outputSourceFiles","_sourceMapGeneratorConstructor","getSourceMapGenerator","_lineNumber","_column","removeBasepath","sourceLines","columns","sourceColumns","inputSource","_sourceMapGenerator","addMapping","generated","normalizeFilename","file","sourceRoot","setSourceContent","sourceMapContent","stringify","toJSON","sourceMap","sourceMapOutput","Environment","SourceMapBuilder","sourceMapOutputFilename","sourceMapGenerator","sourceMapFileInline","sourceMapInputFilename","getCSSAppendage","sourceMapBuilder","ParseTree","transformTree","toCSSOptions","getPostProcessors","file_1","getExternalSourceMap","files","rootFilename","parseTree","ImportManager","rootFileInfo","mime","queue","importManager","pluginLoader","fileParsedFunc","importedEqualsRoot","newFileInfo","promise","loadFileCallback","loadedFile","resolvedFilename","pathDiff","isPathAbsolute","alwaysMakePathsAbsolute","newEnv","evalPlugin","loadPlugin","loadFile","render","utils.copyOptions","self_1","Render","context_1","pluginManager_1","reUsePluginManager","imports_1","evalResult","fileContent","Functions","initial","data","ctor","api","fileCache","errback","xhr","XMLHttpRequest","async","isFileProtocol","fileAsync","handleResponse","status","responseText","getResponseHeader","overrideMimeType","open","setRequestHeader","send","onreadystatechange","readyState","location","useFileCache","lessText_1","webInfo","lastModified","doXHR","log","fulfill","catch","rootHref","errorReporting","errors","errorline","classname","logLevel","errorConsole","timer","filenameNoPath","className","innerHTML","browser","style","env","setInterval","replaceChild","clearInterval","errorHTML","remove","removeErrorHTML","depends","lint","insecure","protocol","poll","hostname","port","onReady","addDefaultOptions","LESS_PLUGINS","lessRoot","FM","addFileManager","loggers","console","LogListener","ErrorReporting","cache","localStorage","setCSS","setItem","getCSS","getItem","timestamp","valueOf","Cache","imageSize","imageFunctions","image-size","image-width","image-height","ImageSize","typePattern","thisArg","curryArgs","loadStyles","instanceOptions","loadStyleSheet","reload","remaining","local","loadInitialFileCallback","loadStyleSheets","sheets","watch","watchMode","watchTimer","clearFileCache","unwatch","registerStylesheetsImmediately","links","rel","registerStylesheets","record","refresh","startTime","endTime","totalMilliseconds","remainingSheets","refreshStyles","resolveOrReject","pageLoadFinished"],"mappings":"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"}